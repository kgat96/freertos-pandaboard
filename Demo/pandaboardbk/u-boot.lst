
u-boot.elf:     file format elf32-littlearm

SYMBOL TABLE:
80800000 l    d  .text	00000000 .text
80809c10 l    d  .data	00000000 .data
8080c000 l    d  .bss	00000000 .bss
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 obj/Demo/pandaboard/startup.o
00000020 l       *ABS*	00000000 T_bit
80800020 l       .text	00000000 Reset_Addr
80800024 l       .text	00000000 Undefined_Addr
80800028 l       .text	00000000 SWI_Addr
8080002c l       .text	00000000 Prefetch_Addr
80800030 l       .text	00000000 Abort_Addr
80800034 l       .text	00000000 IRQ_Addr
80800038 l       .text	00000000 FIQ_Addr
8080003c l       .text	00000000 Reset_Handler
80800048 l       .text	00000000 Undefined_Handler
808000c8 l       .text	00000000 SWI_Handler
80800078 l       .text	00000000 Prefetch_Handler
808000a0 l       .text	00000000 Abort_Handler
808000cc l       .text	00000000 IRQ_Handler
808000cc l       .text	00000000 FIQ_Handler
80800044 l       .text	00000000 Stack_Addr
808000d0 l       .text	00000000 __bss_begin_addr
808000d4 l       .text	00000000 __bss_end_addr
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 queue.c
00000000 l    df *ABS*	00000000 tasks.c
808018d0 l     F .text	00000004 prvIdleTask
808018d4 l     F .text	000000b8 vTaskExitCritical.part.7
808031b4 l     F .text	00000244 prvListTasksWithinSingleList.part.8
8080c004 l     O .bss	00000004 xSchedulerRunning
8080c008 l     O .bss	00000004 uxCurrentNumberOfTasks
8080c00c l     O .bss	000000c8 pxReadyTasksLists
8080c0d4 l     O .bss	00000014 xDelayedTaskList1
8080c0e8 l     O .bss	00000014 xDelayedTaskList2
8080c0fc l     O .bss	00000014 xPendingReadyList
8080c110 l     O .bss	00000014 xSuspendedTaskList
8080c124 l     O .bss	00000004 pxDelayedTaskList
8080c128 l     O .bss	00000004 pxOverflowDelayedTaskList
8080c12c l     O .bss	00000004 uxTaskNumber
8080c130 l     O .bss	00000004 uxTopReadyPriority
8080c134 l     O .bss	00000004 uxSchedulerSuspended
8080c138 l     O .bss	00000004 xYieldPending
8080c13c l     O .bss	00000004 xNextTaskUnblockTime
8080c140 l     O .bss	00000004 xIdleTaskHandle
8080c144 l     O .bss	00000004 xTickCount
8080c148 l     O .bss	00000004 xNumOfOverflows
8080c14c l     O .bss	00000004 uxPendedTicks
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 port.c
80804df0 l       .text	00000000 pxCurrentTCBConst2
80810000 l     O .bss	00000400 puxSVCStack
80810500 l     O .bss	00000400 puxFIQStack
80810900 l     O .bss	00000400 puxIRQStack
80810d00 l     O .bss	00000400 puxAbortStack
80814000 l     O .bss	00004000 PageTable
00000000 l    df *ABS*	00000000 heap_2.c
80809c10 l     O .data	00000004 xFreeBytesRemaining
80818000 l     O .bss	00000008 xStart
80818008 l     O .bss	00000004 xHeapHasBeenInitialised.4810
8081800c l     O .bss	00800000 ucHeap
8101800c l     O .bss	00000008 xEnd
00000000 l    df *ABS*	00000000 main.c
8080598c l     F .text	000001f0 vCheckTask
00000000 l    df *ABS*	00000000 omap4_uart.c
00000000 l    df *ABS*	00000000 pl031_rtc.c
00000000 l    df *ABS*	00000000 printf-stdarg.c
80805f34 l     F .text	0000018c printstring
808060c0 l     F .text	00000618 print
808066d8 l     F .text	00000b4c print.constprop.1
00000000 l    df *ABS*	00000000 serial.c
00000000 l    df *ABS*	00000000 sp804_timer.c
00000000 l    df *ABS*	00000000 BlockQ.c
8080746c l     F .text	00000060 vBlockingQueueProducer
808074cc l     F .text	0000006c vBlockingQueueConsumer
81018014 l     O .bss	00000006 sBlockingConsumerCount
8101801c l     O .bss	00000006 sBlockingProducerCount
81018024 l     O .bss	00000006 sLastBlockingConsumerCount.4945
8101802c l     O .bss	00000006 sLastBlockingProducerCount.4946
00000000 l    df *ABS*	00000000 blocktim.c
808077b8 l     F .text	000000e0 vSecondaryBlockTimeTestTask
80807898 l     F .text	00000344 vPrimaryBlockTimeTestTask
81018034 l     O .bss	00000004 xRunIndicator
81018038 l     O .bss	00000004 xTestQueue
8101803c l     O .bss	00000004 xErrorOccurred
81018040 l     O .bss	00000004 xSecondaryCycles
81018044 l     O .bss	00000004 xSecondary
81018048 l     O .bss	00000004 xPrimaryCycles
8101804c l     O .bss	00000004 xLastPrimaryCycleCount.4579
81018050 l     O .bss	00000004 xLastSecondaryCycleCount.4580
00000000 l    df *ABS*	00000000 comtest.c
80807cac l     F .text	00000094 vComRxTask
80807d40 l     F .text	00000070 vComTxTask
81018054 l     O .bss	00000004 xPort
81018058 l     O .bss	00000004 uxRxLoops
00000000 l    df *ABS*	00000000 countsem.c
80807e4c l     F .text	000001a0 prvCountingSemaphoreTask
8101805c l     O .bss	00000004 xErrorDetected
81018060 l     O .bss	00000018 xParameters
81018078 l     O .bss	00000004 uxLastCount0.4560
8101807c l     O .bss	00000004 uxLastCount1.4561
00000000 l    df *ABS*	00000000 dynamic.c
80808100 l     F .text	00000078 vQueueReceiveWhenSuspendedTask
80808178 l     F .text	0000005c vQueueSendWhenSuspendedTask
808081d4 l     F .text	00000030 vLimitedIncrementTask
80808204 l     F .text	000000b4 vCounterControlTask
808082b8 l     F .text	00000040 vContinuousIncrementTask
81018080 l     O .bss	00000004 ulReceivedValue.4954
81018084 l     O .bss	00000004 xSuspendedQueueReceiveError
81018088 l     O .bss	00000004 ulExpectedValue.4953
8101808c l     O .bss	00000004 ulValueToSend.4948
81018090 l     O .bss	00000004 xSuspendedQueueSendError
81018094 l     O .bss	00000004 ulCounter
81018098 l     O .bss	00000004 xContinousIncrementHandle
8101809c l     O .bss	00000004 xLimitedIncrementHandle
810180a0 l     O .bss	00000002 usCheckVariable
810180a2 l     O .bss	00000002 usLastTaskCheck.4962
00000000 l    df *ABS*	00000000 GenQTest.c
80808434 l     F .text	00000024 prvMediumPriorityMutexTask
80808458 l     F .text	00000058 prvHighPriorityMutexTask
808084b0 l     F .text	000000e8 prvLowPriorityMutexTask
80808598 l     F .text	00000364 prvSendFrontAndBackTest
810180a4 l     O .bss	00000004 ulGuardedVariable
810180a8 l     O .bss	00000004 xErrorDetected
810180ac l     O .bss	00000004 xHighPriorityMutexTask
810180b0 l     O .bss	00000004 xMediumPriorityMutexTask
810180b4 l     O .bss	00000004 ulLoopCounter2
810180b8 l     O .bss	00000004 ulLoopCounter
810180bc l     O .bss	00000004 ulLastLoopCounter.4959
810180c0 l     O .bss	00000004 ulLastLoopCounter2.4960
00000000 l    df *ABS*	00000000 integer.c
80808a30 l     F .text	00000098 vCompeteingIntMathTask
810180c4 l     O .bss	00000004 xTaskCheck
00000000 l    df *ABS*	00000000 PollQ.c
80808b24 l     F .text	0000008c vPolledQueueProducer
80808bb0 l     F .text	00000090 vPolledQueueConsumer
810180c8 l     O .bss	00000004 xPollingProducerCount
810180cc l     O .bss	00000004 xPollingConsumerCount
810180d0 l     O .bss	00000004 xPolledQueue.4912
00000000 l    df *ABS*	00000000 QPeek.c
80808ce8 l     F .text	0000010c prvHighestPriorityPeekTask
80808df4 l     F .text	000000ac prvHighPriorityPeekTask
80808ea0 l     F .text	00000070 prvMediumPriorityPeekTask
80808f10 l     F .text	00000130 prvLowPriorityPeekTask
810180d4 l     O .bss	00000004 xErrorDetected
810180d8 l     O .bss	00000004 ulLoopCounter
810180dc l     O .bss	00000004 ulLastLoopCounter.4948
00000000 l    df *ABS*	00000000 recmutex.c
80809150 l     F .text	0000009c prvRecursiveMutexPollingTask
808091ec l     F .text	00000088 prvRecursiveMutexBlockingTask
80809274 l     F .text	000000a4 prvRecursiveMutexControllingTask
810180e0 l     O .bss	00000004 xMutex
810180e4 l     O .bss	00000004 xBlockingIsSuspended
810180e8 l     O .bss	00000004 xControllingIsSuspended
810180ec l     O .bss	00000004 xErrorOccurred
810180f0 l     O .bss	00000004 uxPollingCycles
810180f4 l     O .bss	00000004 xBlockingTaskHandle
810180f8 l     O .bss	00000004 xControllingTaskHandle
810180fc l     O .bss	00000004 uxBlockingCycles
81018100 l     O .bss	00000004 uxControllingCycles
81018104 l     O .bss	00000004 uxLastControllingCycles.4559
81018108 l     O .bss	00000004 uxLastBlockingCycles.4560
8101810c l     O .bss	00000004 uxLastPollingCycles.4561
00000000 l    df *ABS*	00000000 semtest.c
8080943c l     F .text	000001c0 prvSemaphoreTest
81018110 l     O .bss	00000002 sNextCheckVariable
81018114 l     O .bss	00000008 sCheckVariables
8101811c l     O .bss	00000008 sLastCheckVariables.4935
00000000 l    df *ABS*	00000000 lib_a-memcpy.o
00000000 l    df *ABS*	00000000 memset.c
808072fc g     F .text	00000020 putchar
80805764 g     F .text	00000020 Undefined_Handler_Panic
80807538 g     F .text	000001cc vStartBlockingQueueTasks
808039c8 g     F .text	000000e4 vTaskPlaceOnUnorderedEventList
80805978 g     F .text	00000010 xPortGetFreeHeapSize
80801e90 g     F .text	00000074 uxTaskPriorityGet
8080911c g     F .text	00000034 xAreQueuePeekTasksStillRunning
80807224 g     F .text	00000030 printf
80803d9c g     F .text	000001bc vTaskGetInfo
80805094 g     F .text	00000054 kputc
80805e14 g     F .text	00000024 vRTCInitialise
80807390 g     F .text	00000014 vTimer0Enable
808089d4 g     F .text	0000005c xAreGenericQueueTasksStillRunning
808099b8 g     O .text	00000004 ulKernelPriority
80807c60 g     F .text	0000004c xAreBlockTimeTestTasksStillRunning
80804100 g     F .text	00000030 vTaskEnterCritical
80800c70 g     F .text	000001e0 xQueueGenericSendFromISR
80802a2c g     F .text	00000040 pcTaskGetName
80800000 g       .text	00000000 __isr_vector_start
80800c04 g     F .text	0000006c xQueueGiveMutexRecursive
80809318 g     F .text	000000a8 vStartRecursiveMutexTasks
8080c000 g     O .bss	00000004 pxCurrentTCB
808073a4 g     F .text	000000c8 vTimer0InterruptHandler
80809c10 g       .text	00000000 _etext
80801f30 g     F .text	00000208 vTaskPrioritySet
80807e2c g     F .text	00000020 xAreComTestTasksStillRunning
80804e5c g     F .text	000000d8 xPortStartScheduler
8080295c g     F .text	00000020 vTaskEndScheduler
808097f0 g     F .text	000000ec memcpy
80803918 g     F .text	000000b0 vTaskPlaceOnEventList
808093c0 g     F .text	0000007c xAreRecursiveMutexTasksStillRunning
81018128 g     O .bss	00000004 xHighPriorityTask
808016b0 g     F .text	000000d0 xQueuePeekFromISR
80805e5c g     F .text	000000d8 vRTCAcknowledgeInterrupt
8080728c g     F .text	00000070 puts
80805918 g     F .text	00000060 vPortFree
80801850 g     F .text	00000008 uxQueueGetQueueNumber
8101812c g     O .bss	00000004 xMediumPriorityTask
80800104 g     F .text	00000028 vListInsertEnd
80800000 g       .text	00000000 Vector_Init
80804d18 g     F .text	00000088 itoa
808082f8 g     F .text	000000f8 vStartDynamicPriorityTasks
80804f38 g     F .text	000000ec vPortInstallInterruptHandler
808027dc g     F .text	000000f0 xTaskResumeFromISR
808000f8 g     F .text	0000000c vListInitialiseItem
80804c50 g     F .text	000000c8 vPortSysTickHandler
80805080 g     F .text	00000010 vPortClearInterruptMask
80801f04 g     F .text	0000002c uxTaskPriorityGetFromISR
81018124 g       .bss	00000000 __bss_end
80807704 g     F .text	000000b4 xAreBlockingQueuesStillRunning
808057c0 g     F .text	00000158 pvPortMalloc
80808cb8 g     F .text	00000030 xArePollingQueuesStillRunning
80805198 g     F .text	000005cc _init
8080181c g     F .text	00000034 vQueueDelete
80804f34 g     F .text	00000004 vPortEndScheduler
808000d8 g     F .text	00000020 vListInitialise
80802994 g     F .text	00000068 xTaskGetTickCount
808004bc g     F .text	000006a0 xQueueGenericSend
81018124 g       .bss	00000000 _ebss
80805024 g     F .text	00000044 vPortGICInterruptHandler
80804e5c g     F .text	00000000 vPortSMCHandler
808088fc g     F .text	000000d8 vStartGenericQueueTasks
808033f8 g     F .text	00000250 uxTaskGetSystemState
808080b0 g     F .text	00000050 xAreCountingSemaphoreTasksStillRunning
8080401c g     F .text	000000e4 xTaskPriorityDisinherit
80805bd0 g     F .text	00000008 vApplicationMallocFailedHook
80803aac g     F .text	000000b8 xTaskRemoveFromEventList
80805b7c g     F .text	00000014 vApplicationTickHook
80807338 g     F .text	00000040 vSerialPutString
8080737c g     F .text	00000004 xSerialPutChar
80805d00 g     F .text	0000008c xUARTSendCharacter
80805784 g     F .text	00000020 Prefetch_Handler_Panic
80805bd8 g     F .text	00000020 vAssertCalled
8080422c g     F .text	00000028 pvTaskIncrementMutexHeldCount
80803c64 g     F .text	0000010c xTaskCheckForTimeOut
80807db0 g     F .text	0000007c vAltStartComTestTasks
8080c000 g       .bss	00000000 _bss
80804254 g     F .text	00000244 ulTaskNotifyTake
8080297c g     F .text	00000018 vTaskSuspendAll
80801db4 g     F .text	000000dc eTaskGetState
808029fc g     F .text	00000020 xTaskGetTickCountFromISR
80800188 g     F .text	0000003c uxListRemove
80803f68 g     F .text	000000b4 vTaskPriorityInherit
80804ba8 g     F .text	0000008c xTaskNotifyStateClear
8080262c g     F .text	000001b0 vTaskResume
80803648 g     F .text	000002d0 vTaskSwitchContext
80804498 g     F .text	0000026c xTaskNotifyWait
80803d90 g     F .text	0000000c vTaskSetTaskNumber
80802138 g     F .text	000004f4 vTaskSuspend
80802a1c g     F .text	00000010 uxTaskGetNumberOfTasks
80800000 g       .text	00000000 _text
80801548 g     F .text	00000070 xQueueTakeMutexRecursive
81018130 g     O .bss	00000004 xHighestPriorityTask
80804704 g     F .text	00000228 xTaskGenericNotify
80803d84 g     F .text	0000000c uxTaskGetTaskNumber
808098dc g     F .text	000000a4 memset
80805bf8 g     F .text	00000104 main
80807bdc g     F .text	00000084 vCreateBlockTimeTasks
8080012c g     F .text	0000005c vListInsert
80804e3c g     F .text	00000020 vPortStartFirstTask
80804dd0 g     F .text	00000024 vPortSVCHandler
80801860 g     F .text	00000008 ucQueueGetQueueType
80802e78 g     F .text	000001e0 vTaskDelayUntil
80807380 g     F .text	00000010 vTimer0Initialise
80809774 g     F .text	0000007c xAreSemaphoreTasksStillRunning
80810400 g     O .bss	00000100 pxInterruptHandlers
808015b8 g     F .text	000000f8 xQueueReceiveFromISR
80803f58 g     F .text	00000010 xTaskGetCurrentTaskHandle
8080031c g     F .text	000000b4 xQueueGenericCreate
808003d0 g     F .text	000000ec xQueueCreateCountingSemaphore
80804df4 g     F .text	00000048 vPortInterruptContext
8080492c g     F .text	00000170 xTaskGenericNotifyFromISR
80801858 g     F .text	00000008 vQueueSetQueueNumber
80808ac8 g     F .text	0000003c vStartIntegerMathTasks
80803b64 g     F .text	000000c8 xTaskRemoveFromUnorderedEventList
80805d8c g     F .text	00000088 xUARTReceiveCharacter
80802c1c g     F .text	0000025c xTaskResumeAll
808017b4 g     F .text	0000003c uxQueueSpacesAvailable
80807254 g     F .text	00000038 sprintf
80805068 g     F .text	00000018 xPortSetInterruptMask
808028cc g     F .text	00000090 vTaskStartScheduler
8080c000 g       .bss	00000000 __bss_begin
80801898 g     F .text	00000038 xQueueIsQueueFullFromISR
80809040 g     F .text	000000dc vStartQueuePeekTasks
80807378 g     F .text	00000004 xSerialGetChar
80804c34 g     F .text	0000001c vPortYieldFromISR
8080513c g     F .text	0000005c kputs
80808b04 g     F .text	00000020 xAreIntegerMathsTaskStillRunning
80808c40 g     F .text	00000078 vStartPolledQueueTasks
80807fec g     F .text	000000c4 vStartCountingSemaphoreTasks
80809c10 g       .data	00000000 _data
80803d70 g     F .text	00000014 vTaskMissedYield
808000d8 g       .text	00000000 __isr_vector_end
80801780 g     F .text	00000034 uxQueueMessagesWaiting
80800f44 g     F .text	00000604 xQueueGenericReceive
80802a6c g     F .text	000001b0 xTaskIncrementTick
80700000 g       *ABS*	00000000 __stack
808001c4 g     F .text	00000158 xQueueGenericReset
80809c14 g       .data	00000000 _edata
8080198c g     F .text	00000428 xTaskCreate
80805988 g     F .text	00000004 vPortInitialiseBlocks
808050e8 g     F .text	00000054 kputhex
80803058 g     F .text	0000015c vTaskDelay
81018124 g     O .bss	00000004 xSuspendedTestQueue
80804130 g     F .text	000000d4 vTaskExitCritical
808083f0 g     F .text	00000044 xAreDynamicPriorityTasksStillRunning
80804da0 g     F .text	00000030 pxPortInitialiseStack
80803c2c g     F .text	00000038 vTaskSetTimeOutState
808017f0 g     F .text	0000002c uxQueueMessagesWaitingFromISR
80801868 g     F .text	00000030 xQueueIsQueueEmptyFromISR
808095fc g     F .text	00000178 vStartSemaphoreTasks
80805090 g     F .text	00000004 vPortUnknownInterruptHandler
80805e38 g     F .text	00000024 vRTCEnable
80804204 g     F .text	00000028 uxTaskResetEventItemValue
80800b5c g     F .text	000000a8 xQueueCreateMutex
80805cfc g     F .text	00000004 vUARTInitialise
8080731c g     F .text	0000001c xSerialPortInitMinimal
80804a9c g     F .text	0000010c vTaskNotifyGiveFromISR
808057a4 g     F .text	0000001c Abort_Handler_Panic
80800e50 g     F .text	000000f4 xQueueGiveFromISR
80805b90 g     F .text	00000040 vApplicationIdleHook



Disassembly of section .text:

80800000 <Vector_Init>:
        .section .isr_vector, "x"

.global Vector_Init

Vector_Init:
        LDR     PC, Reset_Addr
80800000:	e59ff018 	ldr	pc, [pc, #24]	; 80800020 <Reset_Addr>
        LDR     PC, Undefined_Addr
80800004:	e59ff018 	ldr	pc, [pc, #24]	; 80800024 <Undefined_Addr>
        LDR     PC, SWI_Addr
80800008:	e59ff018 	ldr	pc, [pc, #24]	; 80800028 <SWI_Addr>
        LDR     PC, Prefetch_Addr
8080000c:	e59ff018 	ldr	pc, [pc, #24]	; 8080002c <Prefetch_Addr>
        LDR     PC, Abort_Addr
80800010:	e59ff018 	ldr	pc, [pc, #24]	; 80800030 <Abort_Addr>
        NOP
80800014:	e320f000 	nop	{0}
        LDR     PC, IRQ_Addr
80800018:	e59ff014 	ldr	pc, [pc, #20]	; 80800034 <IRQ_Addr>
        LDR     PC, FIQ_Addr
8080001c:	e59ff014 	ldr	pc, [pc, #20]	; 80800038 <FIQ_Addr>

80800020 <Reset_Addr>:
80800020:	8080003c 	.word	0x8080003c

80800024 <Undefined_Addr>:
80800024:	80800048 	.word	0x80800048

80800028 <SWI_Addr>:
80800028:	808000c8 	.word	0x808000c8

8080002c <Prefetch_Addr>:
8080002c:	80800078 	.word	0x80800078

80800030 <Abort_Addr>:
80800030:	808000a0 	.word	0x808000a0

80800034 <IRQ_Addr>:
80800034:	808000cc 	.word	0x808000cc

80800038 <FIQ_Addr>:
80800038:	808000cc 	.word	0x808000cc

8080003c <Reset_Handler>:
// ************************
// Exception Handlers
// ************************

Reset_Handler:
    LDR			SP, Stack_Addr
8080003c:	e59fd000 	ldr	sp, [pc]	; 80800044 <Stack_Addr>
    //LDR         SP, =stack_top
    B           _init
80800040:	ea001454 	b	80805198 <_init>

80800044 <Stack_Addr>:
80800044:	80700000 	.word	0x80700000

80800048 <Undefined_Handler>:
    .word __stack

Undefined_Handler:
    // Put system/user mode R14-R0, exception address (LR - (4(ARM) or 2(THUMB))) and SPSR on stack
    // used for logging
    STMDB      SP, {R0-LR}^
80800048:	e94d7fff 	stmdb	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    NOP
8080004c:	e320f000 	nop	{0}
    SUB        SP, SP, #60
80800050:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    MRS        R0, SPSR
80800054:	e14f0000 	mrs	r0, SPSR
    SUB        R1, LR, #2
80800058:	e24e1002 	sub	r1, lr, #2
    // if ARM mode subtract 2 more
    TST        R0, #T_bit
8080005c:	e3100020 	tst	r0, #32
    SUBEQ      R1, R1, #2
80800060:	02411002 	subeq	r1, r1, #2
    STMDB      SP!, {R1}
80800064:	e92d0002 	stmfd	sp!, {r1}
    STMDB      SP!, {R0}
80800068:	e92d0001 	stmfd	sp!, {r0}
    NOP
8080006c:	e320f000 	nop	{0}
    MOV        R0, SP
80800070:	e1a0000d 	mov	r0, sp
    BL         Undefined_Handler_Panic
80800074:	eb0015ba 	bl	80805764 <Undefined_Handler_Panic>

80800078 <Prefetch_Handler>:
Prefetch_Handler:
    // Put system/user mode R14-R0, exception address (LR - 4) and SPSR on stack
    // used for logging
    STMDB      SP, {R0-LR}^
80800078:	e94d7fff 	stmdb	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    NOP
8080007c:	e320f000 	nop	{0}
    SUB        SP, SP, #60
80800080:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    SUB        R0, LR, #4
80800084:	e24e0004 	sub	r0, lr, #4
    STMDB      SP!, {R0}
80800088:	e92d0001 	stmfd	sp!, {r0}
    MRS        R0, SPSR
8080008c:	e14f0000 	mrs	r0, SPSR
    STMDB      SP!, {R0}
80800090:	e92d0001 	stmfd	sp!, {r0}
    NOP
80800094:	e320f000 	nop	{0}
    MOV        R0, SP
80800098:	e1a0000d 	mov	r0, sp
    BL         Prefetch_Handler_Panic
8080009c:	eb0015b8 	bl	80805784 <Prefetch_Handler_Panic>

808000a0 <Abort_Handler>:
Abort_Handler:
    // Put system/user mode R14-R0, exception address (LR - 8) and SPSR on stack
    // used for logging
    STMDB      SP, {R0-LR}^
808000a0:	e94d7fff 	stmdb	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    NOP
808000a4:	e320f000 	nop	{0}
    SUB        SP, SP, #60
808000a8:	e24dd03c 	sub	sp, sp, #60	; 0x3c
    SUB        R0, LR, #8
808000ac:	e24e0008 	sub	r0, lr, #8
    STMDB      SP!, {R0}
808000b0:	e92d0001 	stmfd	sp!, {r0}
    MRS        R0, SPSR
808000b4:	e14f0000 	mrs	r0, SPSR
    STMDB      SP!, {R0}
808000b8:	e92d0001 	stmfd	sp!, {r0}
    NOP
808000bc:	e320f000 	nop	{0}
    MOV        R0, SP
808000c0:	e1a0000d 	mov	r0, sp
    BL         Abort_Handler_Panic
808000c4:	eb0015b6 	bl	808057a4 <Abort_Handler_Panic>

808000c8 <SWI_Handler>:
// 		B       FIQ_Handler


// The following SWI handler support just the taskswitch for OpenRTOS
SWI_Handler:
		B				vPortSVCHandler
808000c8:	ea001340 	b	80804dd0 <vPortSVCHandler>

808000cc <FIQ_Handler>:

FIQ_Handler:
IRQ_Handler:
	B					vPortInterruptContext
808000cc:	ea001348 	b	80804df4 <vPortInterruptContext>

808000d0 <__bss_begin_addr>:
808000d0:	8080c000 	.word	0x8080c000

808000d4 <__bss_end_addr>:
808000d4:	81018124 	.word	0x81018124

808000d8 <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
808000d8:	e2803008 	add	r3, r0, #8

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
808000dc:	e3e01000 	mvn	r1, #0
	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
808000e0:	e3a02000 	mov	r2, #0
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
808000e4:	e5801008 	str	r1, [r0, #8]
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
808000e8:	e880000c 	stm	r0, {r2, r3}
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
808000ec:	e580300c 	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
808000f0:	e5803010 	str	r3, [r0, #16]
808000f4:	e12fff1e 	bx	lr

808000f8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
808000f8:	e3a03000 	mov	r3, #0
808000fc:	e5803010 	str	r3, [r0, #16]
80800100:	e12fff1e 	bx	lr

80800104 <vListInsertEnd>:
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
80800104:	e890000c 	ldm	r0, {r2, r3}

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80800108:	e593c008 	ldr	ip, [r3, #8]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
8080010c:	e2822001 	add	r2, r2, #1

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
80800110:	e9811008 	stmib	r1, {r3, ip}

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
80800114:	e593c008 	ldr	ip, [r3, #8]
80800118:	e58c1004 	str	r1, [ip, #4]
	pxIndex->pxPrevious = pxNewListItem;
8080011c:	e5831008 	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80800120:	e5810010 	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
80800124:	e5802000 	str	r2, [r0]
80800128:	e12fff1e 	bx	lr

8080012c <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
8080012c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
80800130:	e591e000 	ldr	lr, [r1]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
80800134:	e37e0001 	cmn	lr, #1
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80800138:	12802008 	addne	r2, r0, #8
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
8080013c:	1a000001 	bne	80800148 <vListInsert+0x1c>
80800140:	ea00000d 	b	8080017c <vListInsert+0x50>
80800144:	e1a02003 	mov	r2, r3
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80800148:	e5923004 	ldr	r3, [r2, #4]
8080014c:	e593c000 	ldr	ip, [r3]
80800150:	e15e000c 	cmp	lr, ip
80800154:	2afffffa 	bcs	80800144 <vListInsert+0x18>

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
80800158:	e590c000 	ldr	ip, [r0]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8080015c:	e5813004 	str	r3, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80800160:	e5831008 	str	r1, [r3, #8]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
80800164:	e28c3001 	add	r3, ip, #1
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
	pxNewListItem->pxPrevious = pxIterator;
80800168:	e5812008 	str	r2, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
8080016c:	e5821004 	str	r1, [r2, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80800170:	e5810010 	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
80800174:	e5803000 	str	r3, [r0]
80800178:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
8080017c:	e5902010 	ldr	r2, [r0, #16]
80800180:	e5923004 	ldr	r3, [r2, #4]
80800184:	eafffff3 	b	80800158 <vListInsert+0x2c>

80800188 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
80800188:	e5902010 	ldr	r2, [r0, #16]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8080018c:	e5903004 	ldr	r3, [r0, #4]
80800190:	e5901008 	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80800194:	e592c004 	ldr	ip, [r2, #4]
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
80800198:	e5831008 	str	r1, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
8080019c:	e5901008 	ldr	r1, [r0, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
808001a0:	e150000c 	cmp	r0, ip
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
808001a4:	e5813004 	str	r3, [r1, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
	( pxList->uxNumberOfItems )--;
808001a8:	e5923000 	ldr	r3, [r2]
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
808001ac:	05821004 	streq	r1, [r2, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
808001b0:	e3a01000 	mov	r1, #0
808001b4:	e5801010 	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
808001b8:	e2430001 	sub	r0, r3, #1
808001bc:	e5820000 	str	r0, [r2]

	return pxList->uxNumberOfItems;
}
808001c0:	e12fff1e 	bx	lr

808001c4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
808001c4:	e92d4070 	push	{r4, r5, r6, lr}
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808001c8:	e2504000 	subs	r4, r0, #0
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
808001cc:	e1a05001 	mov	r5, r1
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808001d0:	0a00004c 	beq	80800308 <xQueueGenericReset+0x144>

	taskENTER_CRITICAL();
808001d4:	eb000fc9 	bl	80804100 <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
808001d8:	e5941040 	ldr	r1, [r4, #64]	; 0x40
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
		pxQueue->cTxLock = queueUNLOCKED;

		if( xNewQueue == pdFALSE )
808001dc:	e3550000 	cmp	r5, #0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
808001e0:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
808001e4:	e3e00000 	mvn	r0, #0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
808001e8:	e5942000 	ldr	r2, [r4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
808001ec:	e3a0c000 	mov	ip, #0
808001f0:	e584c038 	str	ip, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
808001f4:	e5c40044 	strb	r0, [r4, #68]	; 0x44

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
808001f8:	e0030193 	mul	r3, r3, r1
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
808001fc:	e5842008 	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
		pxQueue->cTxLock = queueUNLOCKED;
80800200:	e5c40045 	strb	r0, [r4, #69]	; 0x45
	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800204:	e0611003 	rsb	r1, r1, r3

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800208:	e0823003 	add	r3, r2, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
8080020c:	e0822001 	add	r2, r2, r1

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800210:	e5843004 	str	r3, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800214:	e584200c 	str	r2, [r4, #12]
		pxQueue->cRxLock = queueUNLOCKED;
		pxQueue->cTxLock = queueUNLOCKED;

		if( xNewQueue == pdFALSE )
80800218:	1a000035 	bne	808002f4 <xQueueGenericReset+0x130>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8080021c:	e5943010 	ldr	r3, [r4, #16]
80800220:	e153000c 	cmp	r3, ip
80800224:	1a000002 	bne	80800234 <xQueueGenericReset+0x70>
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
		}
	}
	taskEXIT_CRITICAL();
80800228:	eb000fc0 	bl	80804130 <vTaskExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
8080022c:	e3a00001 	mov	r0, #1
80800230:	e8bd8070 	pop	{r4, r5, r6, pc}
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80800234:	e2840010 	add	r0, r4, #16
80800238:	eb000e1b 	bl	80803aac <xTaskRemoveFromEventList>
8080023c:	e3500000 	cmp	r0, #0
80800240:	0afffff8 	beq	80800228 <xQueueGenericReset+0x64>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80800244:	e3a03a01 	mov	r3, #4096	; 0x1000
80800248:	e3443824 	movt	r3, #18468	; 0x4824
8080024c:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80800250:	e3120001 	tst	r2, #1
80800254:	1afffff3 	bne	80800228 <xQueueGenericReset+0x64>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80800258:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
8080025c:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80800260:	e2022003 	and	r2, r2, #3
80800264:	e1a02211 	lsl	r2, r1, r2
80800268:	e3822001 	orr	r2, r2, #1
8080026c:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80800270:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80800274:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800278:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080027c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800280:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800284:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800288:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080028c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800290:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800294:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800298:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080029c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002a0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002a4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002a8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002ac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002b0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002b4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002b8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002bc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002c0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002c4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002c8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002cc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002d0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002d4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002d8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002dc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002e0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002e4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002e8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808002ec:	e320f000 	nop	{0}
808002f0:	eaffffcc 	b	80800228 <xQueueGenericReset+0x64>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
808002f4:	e2840010 	add	r0, r4, #16
808002f8:	ebffff76 	bl	808000d8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
808002fc:	e2840024 	add	r0, r4, #36	; 0x24
80800300:	ebffff74 	bl	808000d8 <vListInitialise>
80800304:	eaffffc7 	b	80800228 <xQueueGenericReset+0x64>

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80800308:	e3090980 	movw	r0, #39296	; 0x9980
8080030c:	e300111b 	movw	r1, #283	; 0x11b
80800310:	e3480080 	movt	r0, #32896	; 0x8080
80800314:	eb00162f 	bl	80805bd8 <vAssertCalled>
80800318:	eaffffad 	b	808001d4 <xQueueGenericReset+0x10>

8080031c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
8080031c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
80800320:	e2507000 	subs	r7, r0, #0
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
80800324:	e1a06001 	mov	r6, r1
80800328:	e1a05002 	mov	r5, r2
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
8080032c:	0a000022 	beq	808003bc <xQueueGenericCreate+0xa0>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
80800330:	e0000796 	mul	r0, r6, r7
80800334:	e2800050 	add	r0, r0, #80	; 0x50
80800338:	eb001520 	bl	808057c0 <pvPortMalloc>

		if( pxNewQueue != NULL )
8080033c:	e2504000 	subs	r4, r0, #0
80800340:	0a00001b 	beq	808003b4 <xQueueGenericCreate+0x98>
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
80800344:	e3560000 	cmp	r6, #0
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
80800348:	e584703c 	str	r7, [r4, #60]	; 0x3c

		if( pxNewQueue != NULL )
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
8080034c:	12843050 	addne	r3, r4, #80	; 0x50
{
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
80800350:	01a03004 	moveq	r3, r4
80800354:	e5843000 	str	r3, [r4]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
	pxNewQueue->uxItemSize = uxItemSize;
80800358:	e5846040 	str	r6, [r4, #64]	; 0x40
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
8080035c:	eb000f67 	bl	80804100 <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800360:	e5941040 	ldr	r1, [r4, #64]	; 0x40
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
80800364:	e3e0c000 	mvn	ip, #0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800368:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
8080036c:	e3a0e000 	mov	lr, #0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800370:	e5942000 	ldr	r2, [r4]
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80800374:	e2840010 	add	r0, r4, #16
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
80800378:	e584e038 	str	lr, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
8080037c:	e5c4c044 	strb	ip, [r4, #68]	; 0x44

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800380:	e0030193 	mul	r3, r3, r1
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
80800384:	e5842008 	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
		pxQueue->cTxLock = queueUNLOCKED;
80800388:	e5c4c045 	strb	ip, [r4, #69]	; 0x45
	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
8080038c:	e0611003 	rsb	r1, r1, r3

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800390:	e0823003 	add	r3, r2, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800394:	e0822001 	add	r2, r2, r1

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800398:	e5843004 	str	r3, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
8080039c:	e584200c 	str	r2, [r4, #12]
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
808003a0:	ebffff4c 	bl	808000d8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
808003a4:	e2840024 	add	r0, r4, #36	; 0x24
808003a8:	ebffff4a 	bl	808000d8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
808003ac:	eb000f5f 	bl	80804130 <vTaskExitCritical>
	pxNewQueue->uxItemSize = uxItemSize;
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
808003b0:	e5c4504c 	strb	r5, [r4, #76]	; 0x4c

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
		}

		return pxNewQueue;
	}
808003b4:	e1a00004 	mov	r0, r4
808003b8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	{
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
808003bc:	e3090980 	movw	r0, #39296	; 0x9980
808003c0:	e3a01f62 	mov	r1, #392	; 0x188
808003c4:	e3480080 	movt	r0, #32896	; 0x8080
808003c8:	eb001602 	bl	80805bd8 <vAssertCalled>
808003cc:	eaffffd7 	b	80800330 <xQueueGenericCreate+0x14>

808003d0 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
808003d0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
808003d4:	e2507000 	subs	r7, r0, #0
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
808003d8:	e1a05001 	mov	r5, r1
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
808003dc:	0a000022 	beq	8080046c <xQueueCreateCountingSemaphore+0x9c>
		configASSERT( uxInitialCount <= uxMaxCount );
808003e0:	e1570001 	cmp	r7, r1
808003e4:	3a00002f 	bcc	808004a8 <xQueueCreateCountingSemaphore+0xd8>
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
808003e8:	e3a00050 	mov	r0, #80	; 0x50
808003ec:	eb0014f3 	bl	808057c0 <pvPortMalloc>

		if( pxNewQueue != NULL )
808003f0:	e2504000 	subs	r4, r0, #0
808003f4:	0a00001a 	beq	80800464 <xQueueCreateCountingSemaphore+0x94>
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
	pxNewQueue->uxItemSize = uxItemSize;
808003f8:	e3a06000 	mov	r6, #0
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
808003fc:	e5844000 	str	r4, [r4]
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
80800400:	e584703c 	str	r7, [r4, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
80800404:	e5846040 	str	r6, [r4, #64]	; 0x40
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
80800408:	eb000f3c 	bl	80804100 <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
8080040c:	e5941040 	ldr	r1, [r4, #64]	; 0x40
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
80800410:	e3e0c000 	mvn	ip, #0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800414:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80800418:	e2840010 	add	r0, r4, #16

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
8080041c:	e5942000 	ldr	r2, [r4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
80800420:	e5846038 	str	r6, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
80800424:	e5c4c044 	strb	ip, [r4, #68]	; 0x44

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800428:	e0030193 	mul	r3, r3, r1
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
8080042c:	e5842008 	str	r2, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
		pxQueue->cTxLock = queueUNLOCKED;
80800430:	e5c4c045 	strb	ip, [r4, #69]	; 0x45
	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800434:	e0611003 	rsb	r1, r1, r3

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800438:	e0823003 	add	r3, r2, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
8080043c:	e0822001 	add	r2, r2, r1

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800440:	e5843004 	str	r3, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800444:	e584200c 	str	r2, [r4, #12]
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80800448:	ebffff22 	bl	808000d8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
8080044c:	e2840024 	add	r0, r4, #36	; 0x24
80800450:	ebffff20 	bl	808000d8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
80800454:	eb000f35 	bl	80804130 <vTaskExitCritical>
	pxNewQueue->uxItemSize = uxItemSize;
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
80800458:	e3a03002 	mov	r3, #2

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );

		if( xHandle != NULL )
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
8080045c:	e5845038 	str	r5, [r4, #56]	; 0x38
	pxNewQueue->uxItemSize = uxItemSize;
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
80800460:	e5c4304c 	strb	r3, [r4, #76]	; 0x4c
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
	}
80800464:	e1a00004 	mov	r0, r4
80800468:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
8080046c:	e3090980 	movw	r0, #39296	; 0x9980
80800470:	e30012bd 	movw	r1, #701	; 0x2bd
80800474:	e3480080 	movt	r0, #32896	; 0x8080
80800478:	eb0015d6 	bl	80805bd8 <vAssertCalled>
		configASSERT( uxInitialCount <= uxMaxCount );
8080047c:	e3550000 	cmp	r5, #0
80800480:	0a000003 	beq	80800494 <xQueueCreateCountingSemaphore+0xc4>
80800484:	e3090980 	movw	r0, #39296	; 0x9980
80800488:	e30012be 	movw	r1, #702	; 0x2be
8080048c:	e3480080 	movt	r0, #32896	; 0x8080
80800490:	eb0015d0 	bl	80805bd8 <vAssertCalled>
	{
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
80800494:	e3090980 	movw	r0, #39296	; 0x9980
80800498:	e3a01f62 	mov	r1, #392	; 0x188
8080049c:	e3480080 	movt	r0, #32896	; 0x8080
808004a0:	eb0015cc 	bl	80805bd8 <vAssertCalled>
808004a4:	eaffffcf 	b	808003e8 <xQueueCreateCountingSemaphore+0x18>
	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
		configASSERT( uxInitialCount <= uxMaxCount );
808004a8:	e3090980 	movw	r0, #39296	; 0x9980
808004ac:	e30012be 	movw	r1, #702	; 0x2be
808004b0:	e3480080 	movt	r0, #32896	; 0x8080
808004b4:	eb0015c7 	bl	80805bd8 <vAssertCalled>
808004b8:	eaffffca 	b	808003e8 <xQueueCreateCountingSemaphore+0x18>

808004bc <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
808004bc:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808004c0:	e2505000 	subs	r5, r0, #0

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
808004c4:	e24dd014 	sub	sp, sp, #20
808004c8:	e1a09001 	mov	r9, r1
808004cc:	e1a0a003 	mov	sl, r3
808004d0:	e58d2004 	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808004d4:	0a00015e 	beq	80800a54 <xQueueGenericSend+0x598>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
808004d8:	e3590000 	cmp	r9, #0
808004dc:	0a00012d 	beq	80800998 <xQueueGenericSend+0x4dc>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
808004e0:	e35a0002 	cmp	sl, #2
808004e4:	0a0000c8 	beq	8080080c <xQueueGenericSend+0x350>

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808004e8:	e3a08801 	mov	r8, #65536	; 0x10000
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808004ec:	e3a07a01 	mov	r7, #4096	; 0x1000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808004f0:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808004f4:	e2033003 	and	r3, r3, #3
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808004f8:	e3447824 	movt	r7, #18468	; 0x4824
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808004fc:	e1a03318 	lsl	r3, r8, r3
80800500:	e3a06000 	mov	r6, #0
80800504:	e3838001 	orr	r8, r3, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80800508:	eb000efc 	bl	80804100 <vTaskEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
8080050c:	e5952038 	ldr	r2, [r5, #56]	; 0x38
80800510:	e595303c 	ldr	r3, [r5, #60]	; 0x3c
80800514:	e1520003 	cmp	r2, r3
80800518:	3a000126 	bcc	808009b8 <xQueueGenericSend+0x4fc>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
8080051c:	e59d4004 	ldr	r4, [sp, #4]
80800520:	e3540000 	cmp	r4, #0
80800524:	0a000117 	beq	80800988 <xQueueGenericSend+0x4cc>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
80800528:	e3560000 	cmp	r6, #0
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
8080052c:	e28d4008 	add	r4, sp, #8
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
80800530:	0a0000b2 	beq	80800800 <xQueueGenericSend+0x344>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
80800534:	eb000efd 	bl	80804130 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80800538:	eb00090f 	bl	8080297c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
8080053c:	eb000eef 	bl	80804100 <vTaskEnterCritical>
80800540:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
80800544:	e35300ff 	cmp	r3, #255	; 0xff
80800548:	03a03000 	moveq	r3, #0
8080054c:	05c53044 	strbeq	r3, [r5, #68]	; 0x44
80800550:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
80800554:	e35300ff 	cmp	r3, #255	; 0xff
80800558:	03a03000 	moveq	r3, #0
8080055c:	05c53045 	strbeq	r3, [r5, #69]	; 0x45
80800560:	eb000ef2 	bl	80804130 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80800564:	e1a00004 	mov	r0, r4
80800568:	e28d1004 	add	r1, sp, #4
8080056c:	eb000dbc 	bl	80803c64 <xTaskCheckForTimeOut>
80800570:	e3500000 	cmp	r0, #0
80800574:	1a0000c7 	bne	80800898 <xQueueGenericSend+0x3dc>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
80800578:	eb000ee0 	bl	80804100 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
8080057c:	e5952038 	ldr	r2, [r5, #56]	; 0x38
80800580:	e595303c 	ldr	r3, [r5, #60]	; 0x3c
80800584:	e1520003 	cmp	r2, r3
80800588:	0a00003b 	beq	8080067c <xQueueGenericSend+0x1c0>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
8080058c:	eb000ee7 	bl	80804130 <vTaskExitCritical>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80800590:	eb000eda 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
80800594:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
80800598:	e6ef4073 	uxtb	r4, r3

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
8080059c:	e6af3074 	sxtb	r3, r4
808005a0:	e3530000 	cmp	r3, #0
808005a4:	da000012 	ble	808005f4 <xQueueGenericSend+0x138>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808005a8:	e5953024 	ldr	r3, [r5, #36]	; 0x24
808005ac:	e3530000 	cmp	r3, #0
808005b0:	0a00000f 	beq	808005f4 <xQueueGenericSend+0x138>
808005b4:	e2856024 	add	r6, r5, #36	; 0x24
808005b8:	ea000007 	b	808005dc <xQueueGenericSend+0x120>
808005bc:	e2443001 	sub	r3, r4, #1
808005c0:	e6ef3073 	uxtb	r3, r3
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
808005c4:	e3530000 	cmp	r3, #0
808005c8:	e6ef4073 	uxtb	r4, r3
808005cc:	0a000008 	beq	808005f4 <xQueueGenericSend+0x138>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808005d0:	e5953024 	ldr	r3, [r5, #36]	; 0x24
808005d4:	e3530000 	cmp	r3, #0
808005d8:	0a000005 	beq	808005f4 <xQueueGenericSend+0x138>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
808005dc:	e1a00006 	mov	r0, r6
808005e0:	eb000d31 	bl	80803aac <xTaskRemoveFromEventList>
808005e4:	e3500000 	cmp	r0, #0
808005e8:	0afffff3 	beq	808005bc <xQueueGenericSend+0x100>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
808005ec:	eb000ddf 	bl	80803d70 <vTaskMissedYield>
808005f0:	eafffff1 	b	808005bc <xQueueGenericSend+0x100>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
808005f4:	e3e03000 	mvn	r3, #0
808005f8:	e5c53045 	strb	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
808005fc:	eb000ecb 	bl	80804130 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80800600:	eb000ebe 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
80800604:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
80800608:	e6ef4073 	uxtb	r4, r3

		while( cRxLock > queueLOCKED_UNMODIFIED )
8080060c:	e6af3074 	sxtb	r3, r4
80800610:	e3530000 	cmp	r3, #0
80800614:	da000012 	ble	80800664 <xQueueGenericSend+0x1a8>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80800618:	e5953010 	ldr	r3, [r5, #16]
8080061c:	e3530000 	cmp	r3, #0
80800620:	0a00000f 	beq	80800664 <xQueueGenericSend+0x1a8>
80800624:	e2856010 	add	r6, r5, #16
80800628:	ea000007 	b	8080064c <xQueueGenericSend+0x190>
8080062c:	e2443001 	sub	r3, r4, #1
80800630:	e6ef3073 	uxtb	r3, r3
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
80800634:	e3530000 	cmp	r3, #0
80800638:	e6ef4073 	uxtb	r4, r3
8080063c:	0a000008 	beq	80800664 <xQueueGenericSend+0x1a8>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80800640:	e5953010 	ldr	r3, [r5, #16]
80800644:	e3530000 	cmp	r3, #0
80800648:	0a000005 	beq	80800664 <xQueueGenericSend+0x1a8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8080064c:	e1a00006 	mov	r0, r6
80800650:	eb000d15 	bl	80803aac <xTaskRemoveFromEventList>
80800654:	e3500000 	cmp	r0, #0
80800658:	0afffff3 	beq	8080062c <xQueueGenericSend+0x170>
				{
					vTaskMissedYield();
8080065c:	eb000dc3 	bl	80803d70 <vTaskMissedYield>
80800660:	eafffff1 	b	8080062c <xQueueGenericSend+0x170>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
80800664:	e3e03000 	mvn	r3, #0
80800668:	e5c53044 	strb	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
8080066c:	eb000eaf 	bl	80804130 <vTaskExitCritical>
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
80800670:	eb000969 	bl	80802c1c <xTaskResumeAll>
80800674:	e3a06001 	mov	r6, #1
80800678:	eaffffa2 	b	80800508 <xQueueGenericSend+0x4c>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
8080067c:	e2856010 	add	r6, r5, #16
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
80800680:	eb000eaa 	bl	80804130 <vTaskExitCritical>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
80800684:	e1a00006 	mov	r0, r6
80800688:	e59d1004 	ldr	r1, [sp, #4]
8080068c:	eb000ca1 	bl	80803918 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80800690:	eb000e9a 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
80800694:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
80800698:	e6efb073 	uxtb	fp, r3

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
8080069c:	e6af307b 	sxtb	r3, fp
808006a0:	e3530000 	cmp	r3, #0
808006a4:	da000012 	ble	808006f4 <xQueueGenericSend+0x238>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808006a8:	e5953024 	ldr	r3, [r5, #36]	; 0x24
808006ac:	e3530000 	cmp	r3, #0
808006b0:	0a00000f 	beq	808006f4 <xQueueGenericSend+0x238>
808006b4:	e2854024 	add	r4, r5, #36	; 0x24
808006b8:	ea000007 	b	808006dc <xQueueGenericSend+0x220>
808006bc:	e24b3001 	sub	r3, fp, #1
808006c0:	e6ef3073 	uxtb	r3, r3
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
808006c4:	e3530000 	cmp	r3, #0
808006c8:	e6efb073 	uxtb	fp, r3
808006cc:	0a000008 	beq	808006f4 <xQueueGenericSend+0x238>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808006d0:	e5953024 	ldr	r3, [r5, #36]	; 0x24
808006d4:	e3530000 	cmp	r3, #0
808006d8:	0a000005 	beq	808006f4 <xQueueGenericSend+0x238>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
808006dc:	e1a00004 	mov	r0, r4
808006e0:	eb000cf1 	bl	80803aac <xTaskRemoveFromEventList>
808006e4:	e3500000 	cmp	r0, #0
808006e8:	0afffff3 	beq	808006bc <xQueueGenericSend+0x200>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
808006ec:	eb000d9f 	bl	80803d70 <vTaskMissedYield>
808006f0:	eafffff1 	b	808006bc <xQueueGenericSend+0x200>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
808006f4:	e3e03000 	mvn	r3, #0
808006f8:	e5c53045 	strb	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
808006fc:	eb000e8b 	bl	80804130 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80800700:	eb000e7e 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
80800704:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
80800708:	e6ef4073 	uxtb	r4, r3

		while( cRxLock > queueLOCKED_UNMODIFIED )
8080070c:	e6af3074 	sxtb	r3, r4
80800710:	e3530000 	cmp	r3, #0
80800714:	ca000005 	bgt	80800730 <xQueueGenericSend+0x274>
80800718:	ea00000d 	b	80800754 <xQueueGenericSend+0x298>
8080071c:	e2443001 	sub	r3, r4, #1
80800720:	e6ef3073 	uxtb	r3, r3
80800724:	e3530000 	cmp	r3, #0
80800728:	e6ef4073 	uxtb	r4, r3
8080072c:	0a000008 	beq	80800754 <xQueueGenericSend+0x298>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80800730:	e5953010 	ldr	r3, [r5, #16]
80800734:	e3530000 	cmp	r3, #0
80800738:	0a000005 	beq	80800754 <xQueueGenericSend+0x298>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
8080073c:	e1a00006 	mov	r0, r6
80800740:	eb000cd9 	bl	80803aac <xTaskRemoveFromEventList>
80800744:	e3500000 	cmp	r0, #0
80800748:	0afffff3 	beq	8080071c <xQueueGenericSend+0x260>
				{
					vTaskMissedYield();
8080074c:	eb000d87 	bl	80803d70 <vTaskMissedYield>
80800750:	eafffff1 	b	8080071c <xQueueGenericSend+0x260>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
80800754:	e3e03000 	mvn	r3, #0
80800758:	e5c53044 	strb	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
8080075c:	eb000e73 	bl	80804130 <vTaskExitCritical>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
80800760:	eb00092d 	bl	80802c1c <xTaskResumeAll>
80800764:	e3500000 	cmp	r0, #0
80800768:	1affffc1 	bne	80800674 <xQueueGenericSend+0x1b8>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
8080076c:	e5973200 	ldr	r3, [r7, #512]	; 0x200
80800770:	e3130001 	tst	r3, #1
80800774:	1affffbe 	bne	80800674 <xQueueGenericSend+0x1b8>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80800778:	e5878f00 	str	r8, [r7, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
8080077c:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80800780:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800784:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800788:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080078c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800790:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800794:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800798:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080079c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007a0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007a4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007a8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007ac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007b0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007b4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007b8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007bc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007c0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007c4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007c8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007cc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007d0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007d4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007d8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007dc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007e0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007e4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007e8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007ec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007f4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808007f8:	e320f000 	nop	{0}
808007fc:	eaffff9c 	b	80800674 <xQueueGenericSend+0x1b8>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80800800:	e1a00004 	mov	r0, r4
80800804:	eb000d08 	bl	80803c2c <vTaskSetTimeOutState>
80800808:	eaffff49 	b	80800534 <xQueueGenericSend+0x78>
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
8080080c:	e595303c 	ldr	r3, [r5, #60]	; 0x3c
80800810:	e3530001 	cmp	r3, #1
80800814:	0a000003 	beq	80800828 <xQueueGenericSend+0x36c>
80800818:	e3090980 	movw	r0, #39296	; 0x9980
8080081c:	e30012db 	movw	r1, #731	; 0x2db
80800820:	e3480080 	movt	r0, #32896	; 0x8080
80800824:	eb0014eb 	bl	80805bd8 <vAssertCalled>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
80800828:	eb000e34 	bl	80804100 <vTaskEnterCritical>

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
8080082c:	e5952040 	ldr	r2, [r5, #64]	; 0x40
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800830:	e5953038 	ldr	r3, [r5, #56]	; 0x38
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80800834:	e5954038 	ldr	r4, [r5, #56]	; 0x38

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800838:	e3520000 	cmp	r2, #0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
8080083c:	13a06001 	movne	r6, #1

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800840:	1a000071 	bne	80800a0c <xQueueGenericSend+0x550>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80800844:	e5956000 	ldr	r6, [r5]
80800848:	e3560000 	cmp	r6, #0
8080084c:	0a0000ac 	beq	80800b04 <xQueueGenericSend+0x648>
80800850:	e2844001 	add	r4, r4, #1
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800854:	e5953024 	ldr	r3, [r5, #36]	; 0x24
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
80800858:	e5854038 	str	r4, [r5, #56]	; 0x38
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8080085c:	e3530000 	cmp	r3, #0
80800860:	0a000008 	beq	80800888 <xQueueGenericSend+0x3cc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80800864:	e2850024 	add	r0, r5, #36	; 0x24
80800868:	eb000c8f 	bl	80803aac <xTaskRemoveFromEventList>
8080086c:	e3500000 	cmp	r0, #0
80800870:	0a000004 	beq	80800888 <xQueueGenericSend+0x3cc>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80800874:	e3a01a01 	mov	r1, #4096	; 0x1000
80800878:	e3441824 	movt	r1, #18468	; 0x4824
8080087c:	e5913200 	ldr	r3, [r1, #512]	; 0x200
80800880:	e3130001 	tst	r3, #1
80800884:	0a000077 	beq	80800a68 <xQueueGenericSend+0x5ac>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
80800888:	eb000e28 	bl	80804130 <vTaskExitCritical>
				return pdPASS;
8080088c:	e3a00001 	mov	r0, #1

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80800890:	e28dd014 	add	sp, sp, #20
80800894:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80800898:	eb000e18 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
8080089c:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
808008a0:	e6ef4073 	uxtb	r4, r3

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
808008a4:	e6af3074 	sxtb	r3, r4
808008a8:	e3530000 	cmp	r3, #0
808008ac:	da000012 	ble	808008fc <xQueueGenericSend+0x440>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808008b0:	e5953024 	ldr	r3, [r5, #36]	; 0x24
808008b4:	e3530000 	cmp	r3, #0
808008b8:	0a00000f 	beq	808008fc <xQueueGenericSend+0x440>
808008bc:	e2856024 	add	r6, r5, #36	; 0x24
808008c0:	ea000007 	b	808008e4 <xQueueGenericSend+0x428>
808008c4:	e2443001 	sub	r3, r4, #1
808008c8:	e6ef3073 	uxtb	r3, r3
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
808008cc:	e3530000 	cmp	r3, #0
808008d0:	e6ef4073 	uxtb	r4, r3
808008d4:	0a000008 	beq	808008fc <xQueueGenericSend+0x440>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808008d8:	e5953024 	ldr	r3, [r5, #36]	; 0x24
808008dc:	e3530000 	cmp	r3, #0
808008e0:	0a000005 	beq	808008fc <xQueueGenericSend+0x440>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
808008e4:	e1a00006 	mov	r0, r6
808008e8:	eb000c6f 	bl	80803aac <xTaskRemoveFromEventList>
808008ec:	e3500000 	cmp	r0, #0
808008f0:	0afffff3 	beq	808008c4 <xQueueGenericSend+0x408>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
808008f4:	eb000d1d 	bl	80803d70 <vTaskMissedYield>
808008f8:	eafffff1 	b	808008c4 <xQueueGenericSend+0x408>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
808008fc:	e3e03000 	mvn	r3, #0
80800900:	e5c53045 	strb	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
80800904:	eb000e09 	bl	80804130 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80800908:	eb000dfc 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
8080090c:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
80800910:	e6ef4073 	uxtb	r4, r3

		while( cRxLock > queueLOCKED_UNMODIFIED )
80800914:	e6af3074 	sxtb	r3, r4
80800918:	e3530000 	cmp	r3, #0
8080091c:	da000012 	ble	8080096c <xQueueGenericSend+0x4b0>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80800920:	e5953010 	ldr	r3, [r5, #16]
80800924:	e3530000 	cmp	r3, #0
80800928:	0a00000f 	beq	8080096c <xQueueGenericSend+0x4b0>
8080092c:	e2856010 	add	r6, r5, #16
80800930:	ea000007 	b	80800954 <xQueueGenericSend+0x498>
80800934:	e2443001 	sub	r3, r4, #1
80800938:	e6ef3073 	uxtb	r3, r3
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
8080093c:	e3530000 	cmp	r3, #0
80800940:	e6ef4073 	uxtb	r4, r3
80800944:	0a000008 	beq	8080096c <xQueueGenericSend+0x4b0>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80800948:	e5953010 	ldr	r3, [r5, #16]
8080094c:	e3530000 	cmp	r3, #0
80800950:	0a000005 	beq	8080096c <xQueueGenericSend+0x4b0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80800954:	e1a00006 	mov	r0, r6
80800958:	eb000c53 	bl	80803aac <xTaskRemoveFromEventList>
8080095c:	e3500000 	cmp	r0, #0
80800960:	0afffff3 	beq	80800934 <xQueueGenericSend+0x478>
				{
					vTaskMissedYield();
80800964:	eb000d01 	bl	80803d70 <vTaskMissedYield>
80800968:	eafffff1 	b	80800934 <xQueueGenericSend+0x478>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
8080096c:	e3e03000 	mvn	r3, #0
80800970:	e5c53044 	strb	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
80800974:	eb000ded 	bl	80804130 <vTaskExitCritical>
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
80800978:	eb0008a7 	bl	80802c1c <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
8080097c:	e3a00000 	mov	r0, #0
		}
	}
}
80800980:	e28dd014 	add	sp, sp, #20
80800984:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80800988:	eb000de8 	bl	80804130 <vTaskExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8080098c:	e1a00004 	mov	r0, r4

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
80800990:	e28dd014 	add	sp, sp, #20
80800994:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80800998:	e5953040 	ldr	r3, [r5, #64]	; 0x40
8080099c:	e3530000 	cmp	r3, #0
808009a0:	0afffece 	beq	808004e0 <xQueueGenericSend+0x24>
808009a4:	e3090980 	movw	r0, #39296	; 0x9980
808009a8:	e30012da 	movw	r1, #730	; 0x2da
808009ac:	e3480080 	movt	r0, #32896	; 0x8080
808009b0:	eb001488 	bl	80805bd8 <vAssertCalled>
808009b4:	eafffec9 	b	808004e0 <xQueueGenericSend+0x24>

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
808009b8:	e5952040 	ldr	r2, [r5, #64]	; 0x40
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
808009bc:	e5954038 	ldr	r4, [r5, #56]	; 0x38

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
808009c0:	e3520000 	cmp	r2, #0
808009c4:	0affff9e 	beq	80800844 <xQueueGenericSend+0x388>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
808009c8:	e35a0000 	cmp	sl, #0
808009cc:	1a00000d 	bne	80800a08 <xQueueGenericSend+0x54c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
808009d0:	e1a01009 	mov	r1, r9
808009d4:	e5950008 	ldr	r0, [r5, #8]
808009d8:	fa002384 	blx	808097f0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
808009dc:	e5953008 	ldr	r3, [r5, #8]
808009e0:	e5951040 	ldr	r1, [r5, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
808009e4:	e5952004 	ldr	r2, [r5, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
808009e8:	e0833001 	add	r3, r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
808009ec:	e1530002 	cmp	r3, r2
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
808009f0:	e5853008 	str	r3, [r5, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
808009f4:	3affff95 	bcc	80800850 <xQueueGenericSend+0x394>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
808009f8:	e5953000 	ldr	r3, [r5]
808009fc:	e2844001 	add	r4, r4, #1
80800a00:	e5853008 	str	r3, [r5, #8]
80800a04:	eaffff92 	b	80800854 <xQueueGenericSend+0x398>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800a08:	e3a06000 	mov	r6, #0
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80800a0c:	e1a01009 	mov	r1, r9
80800a10:	e595000c 	ldr	r0, [r5, #12]
80800a14:	fa002375 	blx	808097f0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80800a18:	e5952040 	ldr	r2, [r5, #64]	; 0x40
80800a1c:	e595300c 	ldr	r3, [r5, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800a20:	e5951000 	ldr	r1, [r5]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80800a24:	e2622000 	rsb	r2, r2, #0
80800a28:	e0833002 	add	r3, r3, r2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800a2c:	e1530001 	cmp	r3, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80800a30:	e585300c 	str	r3, [r5, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80800a34:	35953004 	ldrcc	r3, [r5, #4]
80800a38:	30832002 	addcc	r2, r3, r2
80800a3c:	3585200c 	strcc	r2, [r5, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
80800a40:	e3560000 	cmp	r6, #0
80800a44:	0affff81 	beq	80800850 <xQueueGenericSend+0x394>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80800a48:	e3540000 	cmp	r4, #0
80800a4c:	03a04001 	moveq	r4, #1
80800a50:	eaffff7f 	b	80800854 <xQueueGenericSend+0x398>
{
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80800a54:	e3090980 	movw	r0, #39296	; 0x9980
80800a58:	e30012d9 	movw	r1, #729	; 0x2d9
80800a5c:	e3480080 	movt	r0, #32896	; 0x8080
80800a60:	eb00145c 	bl	80805bd8 <vAssertCalled>
80800a64:	eafffe9b 	b	808004d8 <xQueueGenericSend+0x1c>
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80800a68:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80800a6c:	e3a03801 	mov	r3, #65536	; 0x10000
80800a70:	e2022003 	and	r2, r2, #3
80800a74:	e1a03213 	lsl	r3, r3, r2
80800a78:	e3833001 	orr	r3, r3, #1
80800a7c:	e5813f00 	str	r3, [r1, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80800a80:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80800a84:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800a88:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800a8c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800a90:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800a94:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800a98:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800a9c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800aa0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800aa4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800aa8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800aac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ab0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ab4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ab8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800abc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ac0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ac4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ac8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800acc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ad0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ad4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ad8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800adc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ae0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ae4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800ae8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800aec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800af0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800af4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800af8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80800afc:	e320f000 	nop	{0}
80800b00:	eaffff60 	b	80800888 <xQueueGenericSend+0x3cc>
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80800b04:	e5950004 	ldr	r0, [r5, #4]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
80800b08:	e2844001 	add	r4, r4, #1
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80800b0c:	eb000d42 	bl	8080401c <xTaskPriorityDisinherit>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800b10:	e5953024 	ldr	r3, [r5, #36]	; 0x24
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
80800b14:	e5854038 	str	r4, [r5, #56]	; 0x38
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
				pxQueue->pxMutexHolder = NULL;
80800b18:	e5856004 	str	r6, [r5, #4]
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800b1c:	e3530000 	cmp	r3, #0
80800b20:	1affff4f 	bne	80800864 <xQueueGenericSend+0x3a8>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
80800b24:	e3500000 	cmp	r0, #0
80800b28:	0affff56 	beq	80800888 <xQueueGenericSend+0x3cc>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80800b2c:	e3a03a01 	mov	r3, #4096	; 0x1000
80800b30:	e3443824 	movt	r3, #18468	; 0x4824
80800b34:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80800b38:	e3120001 	tst	r2, #1
80800b3c:	1affff51 	bne	80800888 <xQueueGenericSend+0x3cc>
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80800b40:	ee101fb0 	mrc	15, 0, r1, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80800b44:	e3a02801 	mov	r2, #65536	; 0x10000
80800b48:	e2011003 	and	r1, r1, #3
80800b4c:	e1a02112 	lsl	r2, r2, r1
80800b50:	e3822001 	orr	r2, r2, #1
80800b54:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
80800b58:	eaffffc8 	b	80800a80 <xQueueGenericSend+0x5c4>

80800b5c <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
80800b5c:	e92d4070 	push	{r4, r5, r6, lr}
80800b60:	e1a06000 	mov	r6, r0
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
80800b64:	e3a00050 	mov	r0, #80	; 0x50
80800b68:	eb001314 	bl	808057c0 <pvPortMalloc>

		if( pxNewQueue != NULL )
80800b6c:	e2504000 	subs	r4, r0, #0
80800b70:	0a000021 	beq	80800bfc <xQueueCreateMutex+0xa0>
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
	pxNewQueue->uxItemSize = uxItemSize;
80800b74:	e3a05000 	mov	r5, #0
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
80800b78:	e3a03001 	mov	r3, #1
80800b7c:	e584303c 	str	r3, [r4, #60]	; 0x3c
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
80800b80:	e5844000 	str	r4, [r4]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
	pxNewQueue->uxItemSize = uxItemSize;
80800b84:	e5845040 	str	r5, [r4, #64]	; 0x40
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
80800b88:	eb000d5c 	bl	80804100 <vTaskEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800b8c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
80800b90:	e3e0c000 	mvn	ip, #0

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800b94:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80800b98:	e2840010 	add	r0, r4, #16

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800b9c:	e5941000 	ldr	r1, [r4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
80800ba0:	e5845038 	str	r5, [r4, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
80800ba4:	e5c4c044 	strb	ip, [r4, #68]	; 0x44

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800ba8:	e0020392 	mul	r2, r2, r3
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
80800bac:	e5841008 	str	r1, [r4, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
		pxQueue->cRxLock = queueUNLOCKED;
		pxQueue->cTxLock = queueUNLOCKED;
80800bb0:	e5c4c045 	strb	ip, [r4, #69]	; 0x45
	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800bb4:	e0633002 	rsb	r3, r3, r2

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800bb8:	e0812002 	add	r2, r1, r2
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800bbc:	e0811003 	add	r1, r1, r3

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
80800bc0:	e5842004 	str	r2, [r4, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
		pxQueue->pcWriteTo = pxQueue->pcHead;
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
80800bc4:	e584100c 	str	r1, [r4, #12]
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80800bc8:	ebfffd42 	bl	808000d8 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
80800bcc:	e2840024 	add	r0, r4, #36	; 0x24
80800bd0:	ebfffd40 	bl	808000d8 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
80800bd4:	eb000d55 	bl	80804130 <vTaskExitCritical>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
80800bd8:	e5845004 	str	r5, [r4, #4]
			pxNewQueue->u.uxRecursiveCallCount = 0;

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
80800bdc:	e1a03005 	mov	r3, r5
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
80800be0:	e5845000 	str	r5, [r4]
			pxNewQueue->u.uxRecursiveCallCount = 0;

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
80800be4:	e1a02005 	mov	r2, r5
			in particular the information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;

			/* In case this is a recursive mutex. */
			pxNewQueue->u.uxRecursiveCallCount = 0;
80800be8:	e584500c 	str	r5, [r4, #12]

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
80800bec:	e1a01005 	mov	r1, r5
	pxNewQueue->uxItemSize = uxItemSize;
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
80800bf0:	e5c4604c 	strb	r6, [r4, #76]	; 0x4c
			pxNewQueue->u.uxRecursiveCallCount = 0;

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
80800bf4:	e1a00004 	mov	r0, r4
80800bf8:	ebfffe2f 	bl	808004bc <xQueueGenericSend>

		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
		prvInitialiseMutex( pxNewQueue );

		return pxNewQueue;
	}
80800bfc:	e1a00004 	mov	r0, r4
80800c00:	e8bd8070 	pop	{r4, r5, r6, pc}

80800c04 <xQueueGiveMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
80800c04:	e92d4070 	push	{r4, r5, r6, lr}
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;

		configASSERT( pxMutex );
80800c08:	e2504000 	subs	r4, r0, #0
80800c0c:	0a000012 	beq	80800c5c <xQueueGiveMutexRecursive+0x58>
		change outside of this task.  If this task does not hold the mutex then
		pxMutexHolder can never coincidentally equal the tasks handle, and as
		this is the only condition we are interested in it does not matter if
		pxMutexHolder is accessed simultaneously by another task.  Therefore no
		mutual exclusion is required to test the pxMutexHolder variable. */
		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
80800c10:	e5945004 	ldr	r5, [r4, #4]
80800c14:	eb000ccf 	bl	80803f58 <xTaskGetCurrentTaskHandle>
80800c18:	e1550000 	cmp	r5, r0
80800c1c:	0a000001 	beq	80800c28 <xQueueGiveMutexRecursive+0x24>
		}
		else
		{
			/* The mutex cannot be given because the calling task is not the
			holder. */
			xReturn = pdFAIL;
80800c20:	e3a00000 	mov	r0, #0
80800c24:	e8bd8070 	pop	{r4, r5, r6, pc}
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
80800c28:	e594300c 	ldr	r3, [r4, #12]
80800c2c:	e2433001 	sub	r3, r3, #1

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
80800c30:	e3530000 	cmp	r3, #0
			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
			the task handle, therefore no underflow check is required.  Also,
			uxRecursiveCallCount is only modified by the mutex holder, and as
			there can only be one, no mutual exclusion is required to modify the
			uxRecursiveCallCount member. */
			( pxMutex->u.uxRecursiveCallCount )--;
80800c34:	e584300c 	str	r3, [r4, #12]

			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
80800c38:	0a000001 	beq	80800c44 <xQueueGiveMutexRecursive+0x40>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
80800c3c:	e3a00001 	mov	r0, #1

			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
		}

		return xReturn;
	}
80800c40:	e8bd8070 	pop	{r4, r5, r6, pc}
			/* Has the recursive call count unwound to 0? */
			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
			{
				/* Return the mutex.  This will automatically unblock any other
				task that might be waiting to access the mutex. */
				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
80800c44:	e1a00004 	mov	r0, r4
80800c48:	e1a02003 	mov	r2, r3
80800c4c:	e1a01003 	mov	r1, r3
80800c50:	ebfffe19 	bl	808004bc <xQueueGenericSend>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			xReturn = pdPASS;
80800c54:	e3a00001 	mov	r0, #1
80800c58:	e8bd8070 	pop	{r4, r5, r6, pc}
	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
	{
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;

		configASSERT( pxMutex );
80800c5c:	e3090980 	movw	r0, #39296	; 0x9980
80800c60:	e3001241 	movw	r1, #577	; 0x241
80800c64:	e3480080 	movt	r0, #32896	; 0x8080
80800c68:	eb0013da 	bl	80805bd8 <vAssertCalled>
80800c6c:	eaffffe7 	b	80800c10 <xQueueGiveMutexRecursive+0xc>

80800c70 <xQueueGenericSendFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
80800c70:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80800c74:	e2504000 	subs	r4, r0, #0
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
80800c78:	e1a07001 	mov	r7, r1
80800c7c:	e1a09002 	mov	r9, r2
80800c80:	e1a06003 	mov	r6, r3
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80800c84:	0a000068 	beq	80800e2c <xQueueGenericSendFromISR+0x1bc>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80800c88:	e3570000 	cmp	r7, #0
80800c8c:	0a00004a 	beq	80800dbc <xQueueGenericSendFromISR+0x14c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
80800c90:	e3560002 	cmp	r6, #2
80800c94:	0a00000a 	beq	80800cc4 <xQueueGenericSendFromISR+0x54>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80800c98:	eb0010f2 	bl	80805068 <xPortSetInterruptMask>
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800c9c:	e5942038 	ldr	r2, [r4, #56]	; 0x38
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80800ca0:	e1a08000 	mov	r8, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800ca4:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
80800ca8:	e1520003 	cmp	r2, r3
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
80800cac:	23a06000 	movcs	r6, #0
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800cb0:	3a000020 	bcc	80800d38 <xQueueGenericSendFromISR+0xc8>
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
80800cb4:	e1a00008 	mov	r0, r8
80800cb8:	eb0010f0 	bl	80805080 <vPortClearInterruptMask>

	return xReturn;
}
80800cbc:	e1a00006 	mov	r0, r6
80800cc0:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
80800cc4:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
80800cc8:	e3530001 	cmp	r3, #1
80800ccc:	0a000003 	beq	80800ce0 <xQueueGenericSendFromISR+0x70>
80800cd0:	e3090980 	movw	r0, #39296	; 0x9980
80800cd4:	e30013a1 	movw	r1, #929	; 0x3a1
80800cd8:	e3480080 	movt	r0, #32896	; 0x8080
80800cdc:	eb0013bd 	bl	80805bd8 <vAssertCalled>
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80800ce0:	eb0010e0 	bl	80805068 <xPortSetInterruptMask>

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800ce4:	e5942040 	ldr	r2, [r4, #64]	; 0x40
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80800ce8:	e1a08000 	mov	r8, r0
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800cec:	e5943038 	ldr	r3, [r4, #56]	; 0x38
		{
			const int8_t cTxLock = pxQueue->cTxLock;
80800cf0:	e5d45045 	ldrb	r5, [r4, #69]	; 0x45

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800cf4:	e3520000 	cmp	r2, #0
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80800cf8:	e594a038 	ldr	sl, [r4, #56]	; 0x38
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800cfc:	13a06001 	movne	r6, #1
		{
			const int8_t cTxLock = pxQueue->cTxLock;
80800d00:	e6ef5075 	uxtb	r5, r5

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800d04:	1a000035 	bne	80800de0 <xQueueGenericSendFromISR+0x170>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
80800d08:	e5946000 	ldr	r6, [r4]
80800d0c:	e3560000 	cmp	r6, #0
80800d10:	0a00004a 	beq	80800e40 <xQueueGenericSendFromISR+0x1d0>
80800d14:	e28a3001 	add	r3, sl, #1
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
80800d18:	e35500ff 	cmp	r5, #255	; 0xff
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
80800d1c:	e5843038 	str	r3, [r4, #56]	; 0x38
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
80800d20:	0a00001a 	beq	80800d90 <xQueueGenericSendFromISR+0x120>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
80800d24:	e2855001 	add	r5, r5, #1
			}

			xReturn = pdPASS;
80800d28:	e3a06001 	mov	r6, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
80800d2c:	e6ef5075 	uxtb	r5, r5
80800d30:	e5c45045 	strb	r5, [r4, #69]	; 0x45
80800d34:	eaffffde 	b	80800cb4 <xQueueGenericSendFromISR+0x44>

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800d38:	e5942040 	ldr	r2, [r4, #64]	; 0x40
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
			const int8_t cTxLock = pxQueue->cTxLock;
80800d3c:	e5d45045 	ldrb	r5, [r4, #69]	; 0x45
BaseType_t xReturn = pdFALSE;
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80800d40:	e594a038 	ldr	sl, [r4, #56]	; 0x38

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800d44:	e3520000 	cmp	r2, #0
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
			const int8_t cTxLock = pxQueue->cTxLock;
80800d48:	e6ef5075 	uxtb	r5, r5

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
80800d4c:	0affffed 	beq	80800d08 <xQueueGenericSendFromISR+0x98>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
80800d50:	e3560000 	cmp	r6, #0
80800d54:	1a000020 	bne	80800ddc <xQueueGenericSendFromISR+0x16c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
80800d58:	e1a01007 	mov	r1, r7
80800d5c:	e5940008 	ldr	r0, [r4, #8]
80800d60:	fa0022a2 	blx	808097f0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80800d64:	e5943008 	ldr	r3, [r4, #8]
80800d68:	e5941040 	ldr	r1, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800d6c:	e5942004 	ldr	r2, [r4, #4]
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80800d70:	e0833001 	add	r3, r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800d74:	e1530002 	cmp	r3, r2
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
80800d78:	e5843008 	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800d7c:	3affffe4 	bcc	80800d14 <xQueueGenericSendFromISR+0xa4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80800d80:	e5942000 	ldr	r2, [r4]
80800d84:	e28a3001 	add	r3, sl, #1
80800d88:	e5842008 	str	r2, [r4, #8]
80800d8c:	eaffffe1 	b	80800d18 <xQueueGenericSendFromISR+0xa8>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800d90:	e5943024 	ldr	r3, [r4, #36]	; 0x24
80800d94:	e3530000 	cmp	r3, #0
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
			}

			xReturn = pdPASS;
80800d98:	03a06001 	moveq	r6, #1
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800d9c:	0affffc4 	beq	80800cb4 <xQueueGenericSendFromISR+0x44>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80800da0:	e2840024 	add	r0, r4, #36	; 0x24
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
80800da4:	e3a06001 	mov	r6, #1
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80800da8:	eb000b3f 	bl	80803aac <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
80800dac:	e3500000 	cmp	r0, #0
80800db0:	13590000 	cmpne	r9, #0
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
80800db4:	15896000 	strne	r6, [r9]
80800db8:	eaffffbd 	b	80800cb4 <xQueueGenericSendFromISR+0x44>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80800dbc:	e5943040 	ldr	r3, [r4, #64]	; 0x40
80800dc0:	e3530000 	cmp	r3, #0
80800dc4:	0affffb1 	beq	80800c90 <xQueueGenericSendFromISR+0x20>
80800dc8:	e3090980 	movw	r0, #39296	; 0x9980
80800dcc:	e3a01e3a 	mov	r1, #928	; 0x3a0
80800dd0:	e3480080 	movt	r0, #32896	; 0x8080
80800dd4:	eb00137f 	bl	80805bd8 <vAssertCalled>
80800dd8:	eaffffac 	b	80800c90 <xQueueGenericSendFromISR+0x20>
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
80800ddc:	e3a06000 	mov	r6, #0
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80800de0:	e1a01007 	mov	r1, r7
80800de4:	e594000c 	ldr	r0, [r4, #12]
80800de8:	fa002280 	blx	808097f0 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80800dec:	e5942040 	ldr	r2, [r4, #64]	; 0x40
80800df0:	e594300c 	ldr	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800df4:	e5941000 	ldr	r1, [r4]
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80800df8:	e2622000 	rsb	r2, r2, #0
80800dfc:	e0833002 	add	r3, r3, r2
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800e00:	e1530001 	cmp	r3, r1
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80800e04:	e584300c 	str	r3, [r4, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
80800e08:	35943004 	ldrcc	r3, [r4, #4]
80800e0c:	30832002 	addcc	r2, r3, r2
80800e10:	3584200c 	strcc	r2, [r4, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
80800e14:	e3560000 	cmp	r6, #0
80800e18:	0affffbd 	beq	80800d14 <xQueueGenericSendFromISR+0xa4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
80800e1c:	e35a0000 	cmp	sl, #0
80800e20:	11a0300a 	movne	r3, sl
80800e24:	03a03001 	moveq	r3, #1
80800e28:	eaffffba 	b	80800d18 <xQueueGenericSendFromISR+0xa8>
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80800e2c:	e3090980 	movw	r0, #39296	; 0x9980
80800e30:	e300139f 	movw	r1, #927	; 0x39f
80800e34:	e3480080 	movt	r0, #32896	; 0x8080
80800e38:	eb001366 	bl	80805bd8 <vAssertCalled>
80800e3c:	eaffff91 	b	80800c88 <xQueueGenericSendFromISR+0x18>
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
80800e40:	e5940004 	ldr	r0, [r4, #4]
80800e44:	eb000c74 	bl	8080401c <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
80800e48:	e5846004 	str	r6, [r4, #4]
80800e4c:	eaffffb0 	b	80800d14 <xQueueGenericSendFromISR+0xa4>

80800e50 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
80800e50:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
80800e54:	e2504000 	subs	r4, r0, #0
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
80800e58:	e1a07001 	mov	r7, r1
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
80800e5c:	0a000033 	beq	80800f30 <xQueueGiveFromISR+0xe0>

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
80800e60:	e5943040 	ldr	r3, [r4, #64]	; 0x40
80800e64:	e3530000 	cmp	r3, #0
80800e68:	1a000017 	bne	80800ecc <xQueueGiveFromISR+0x7c>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
80800e6c:	e5943000 	ldr	r3, [r4]
80800e70:	e3530000 	cmp	r3, #0
80800e74:	0a00001b 	beq	80800ee8 <xQueueGiveFromISR+0x98>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80800e78:	eb00107a 	bl	80805068 <xPortSetInterruptMask>
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80800e7c:	e5942038 	ldr	r2, [r4, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80800e80:	e1a06000 	mov	r6, r0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
80800e84:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
80800e88:	e1520003 	cmp	r2, r3
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
80800e8c:	23a05000 	movcs	r5, #0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
80800e90:	2a000009 	bcs	80800ebc <xQueueGiveFromISR+0x6c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
80800e94:	e5d43045 	ldrb	r3, [r4, #69]	; 0x45
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
80800e98:	e2822001 	add	r2, r2, #1
80800e9c:	e5842038 	str	r2, [r4, #56]	; 0x38
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
		{
			const int8_t cTxLock = pxQueue->cTxLock;
80800ea0:	e6ef3073 	uxtb	r3, r3
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
80800ea4:	e35300ff 	cmp	r3, #255	; 0xff
80800ea8:	0a000016 	beq	80800f08 <xQueueGiveFromISR+0xb8>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
80800eac:	e2833001 	add	r3, r3, #1
			}

			xReturn = pdPASS;
80800eb0:	e3a05001 	mov	r5, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
80800eb4:	e6ef3073 	uxtb	r3, r3
80800eb8:	e5c43045 	strb	r3, [r4, #69]	; 0x45
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
80800ebc:	e1a00006 	mov	r0, r6
80800ec0:	eb00106e 	bl	80805080 <vPortClearInterruptMask>

	return xReturn;
}
80800ec4:	e1a00005 	mov	r0, r5
80800ec8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

	configASSERT( pxQueue );

	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
	if the item size is not 0. */
	configASSERT( pxQueue->uxItemSize == 0 );
80800ecc:	e3090980 	movw	r0, #39296	; 0x9980
80800ed0:	e3a01d11 	mov	r1, #1088	; 0x440
80800ed4:	e3480080 	movt	r0, #32896	; 0x8080
80800ed8:	eb00133e 	bl	80805bd8 <vAssertCalled>

	/* Normally a mutex would not be given from an interrupt, especially if
	there is a mutex holder, as priority inheritance makes no sense for an
	interrupts, only tasks. */
	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
80800edc:	e5943000 	ldr	r3, [r4]
80800ee0:	e3530000 	cmp	r3, #0
80800ee4:	1affffe3 	bne	80800e78 <xQueueGiveFromISR+0x28>
80800ee8:	e5943004 	ldr	r3, [r4, #4]
80800eec:	e3530000 	cmp	r3, #0
80800ef0:	0affffe0 	beq	80800e78 <xQueueGiveFromISR+0x28>
80800ef4:	e3090980 	movw	r0, #39296	; 0x9980
80800ef8:	e3001445 	movw	r1, #1093	; 0x445
80800efc:	e3480080 	movt	r0, #32896	; 0x8080
80800f00:	eb001334 	bl	80805bd8 <vAssertCalled>
80800f04:	eaffffdb 	b	80800e78 <xQueueGiveFromISR+0x28>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800f08:	e5943024 	ldr	r3, [r4, #36]	; 0x24
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
80800f0c:	e3a05001 	mov	r5, #1
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800f10:	e3530000 	cmp	r3, #0
80800f14:	0affffe8 	beq	80800ebc <xQueueGiveFromISR+0x6c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80800f18:	e2840024 	add	r0, r4, #36	; 0x24
80800f1c:	eb000ae2 	bl	80803aac <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
80800f20:	e3500000 	cmp	r0, #0
80800f24:	13570000 	cmpne	r7, #0
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
80800f28:	15875000 	strne	r5, [r7]
80800f2c:	eaffffe2 	b	80800ebc <xQueueGiveFromISR+0x6c>
	item size is 0.  Don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */

	configASSERT( pxQueue );
80800f30:	e3090980 	movw	r0, #39296	; 0x9980
80800f34:	e300143c 	movw	r1, #1084	; 0x43c
80800f38:	e3480080 	movt	r0, #32896	; 0x8080
80800f3c:	eb001325 	bl	80805bd8 <vAssertCalled>
80800f40:	eaffffc6 	b	80800e60 <xQueueGiveFromISR+0x10>

80800f44 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
80800f44:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80800f48:	e2505000 	subs	r5, r0, #0
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
80800f4c:	e24dd010 	sub	sp, sp, #16
80800f50:	e1a09001 	mov	r9, r1
80800f54:	e1a0a003 	mov	sl, r3
80800f58:	e58d2004 	str	r2, [sp, #4]
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80800f5c:	0a000171 	beq	80801528 <xQueueGenericReceive+0x5e4>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80800f60:	e3590000 	cmp	r9, #0
80800f64:	0a000167 	beq	80801508 <xQueueGenericReceive+0x5c4>
80800f68:	e3a07801 	mov	r7, #65536	; 0x10000
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80800f6c:	e3a08a01 	mov	r8, #4096	; 0x1000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80800f70:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80800f74:	e2033003 	and	r3, r3, #3
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80800f78:	e3448824 	movt	r8, #18468	; 0x4824
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80800f7c:	e1a03317 	lsl	r3, r7, r3
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
80800f80:	e3a06000 	mov	r6, #0
80800f84:	e3837001 	orr	r7, r3, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80800f88:	eb000c5c 	bl	80804100 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80800f8c:	e5954038 	ldr	r4, [r5, #56]	; 0x38

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80800f90:	e3540000 	cmp	r4, #0
80800f94:	1a000077 	bne	80801178 <xQueueGenericReceive+0x234>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
80800f98:	e59d3004 	ldr	r3, [sp, #4]
80800f9c:	e3530000 	cmp	r3, #0
80800fa0:	0a000116 	beq	80801400 <xQueueGenericReceive+0x4bc>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
80800fa4:	e3560000 	cmp	r6, #0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80800fa8:	e28d4008 	add	r4, sp, #8
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
80800fac:	0a0000ef 	beq	80801370 <xQueueGenericReceive+0x42c>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
80800fb0:	eb000c5e 	bl	80804130 <vTaskExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
80800fb4:	eb000670 	bl	8080297c <vTaskSuspendAll>
		prvLockQueue( pxQueue );
80800fb8:	eb000c50 	bl	80804100 <vTaskEnterCritical>
80800fbc:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
80800fc0:	e35300ff 	cmp	r3, #255	; 0xff
80800fc4:	03a03000 	moveq	r3, #0
80800fc8:	05c53044 	strbeq	r3, [r5, #68]	; 0x44
80800fcc:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
80800fd0:	e35300ff 	cmp	r3, #255	; 0xff
80800fd4:	03a03000 	moveq	r3, #0
80800fd8:	05c53045 	strbeq	r3, [r5, #69]	; 0x45
80800fdc:	eb000c53 	bl	80804130 <vTaskExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80800fe0:	e1a00004 	mov	r0, r4
80800fe4:	e28d1004 	add	r1, sp, #4
80800fe8:	eb000b1d 	bl	80803c64 <xTaskCheckForTimeOut>
80800fec:	e3500000 	cmp	r0, #0
80800ff0:	1a00001d 	bne	8080106c <xQueueGenericReceive+0x128>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
80800ff4:	eb000c41 	bl	80804100 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
80800ff8:	e5953038 	ldr	r3, [r5, #56]	; 0x38
80800ffc:	e3530000 	cmp	r3, #0
80801000:	0a000076 	beq	808011e0 <xQueueGenericReceive+0x29c>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
80801004:	eb000c49 	bl	80804130 <vTaskExitCritical>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80801008:	eb000c3c 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
8080100c:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
80801010:	e6ef4073 	uxtb	r4, r3

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
80801014:	e6af3074 	sxtb	r3, r4
80801018:	e3530000 	cmp	r3, #0
8080101c:	da0000d6 	ble	8080137c <xQueueGenericReceive+0x438>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80801020:	e5953024 	ldr	r3, [r5, #36]	; 0x24
80801024:	e3530000 	cmp	r3, #0
80801028:	0a0000d3 	beq	8080137c <xQueueGenericReceive+0x438>
8080102c:	e2856024 	add	r6, r5, #36	; 0x24
80801030:	ea000007 	b	80801054 <xQueueGenericReceive+0x110>
80801034:	e2443001 	sub	r3, r4, #1
80801038:	e6ef3073 	uxtb	r3, r3
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
8080103c:	e3530000 	cmp	r3, #0
80801040:	e6ef4073 	uxtb	r4, r3
80801044:	0a0000cc 	beq	8080137c <xQueueGenericReceive+0x438>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80801048:	e5953024 	ldr	r3, [r5, #36]	; 0x24
8080104c:	e3530000 	cmp	r3, #0
80801050:	0a0000c9 	beq	8080137c <xQueueGenericReceive+0x438>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80801054:	e1a00006 	mov	r0, r6
80801058:	eb000a93 	bl	80803aac <xTaskRemoveFromEventList>
8080105c:	e3500000 	cmp	r0, #0
80801060:	0afffff3 	beq	80801034 <xQueueGenericReceive+0xf0>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
80801064:	eb000b41 	bl	80803d70 <vTaskMissedYield>
80801068:	eafffff1 	b	80801034 <xQueueGenericReceive+0xf0>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
8080106c:	eb000c23 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
80801070:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
80801074:	e6ef4073 	uxtb	r4, r3

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
80801078:	e6af3074 	sxtb	r3, r4
8080107c:	e3530000 	cmp	r3, #0
80801080:	da000012 	ble	808010d0 <xQueueGenericReceive+0x18c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80801084:	e5953024 	ldr	r3, [r5, #36]	; 0x24
80801088:	e3530000 	cmp	r3, #0
8080108c:	0a00000f 	beq	808010d0 <xQueueGenericReceive+0x18c>
80801090:	e2856024 	add	r6, r5, #36	; 0x24
80801094:	ea000007 	b	808010b8 <xQueueGenericReceive+0x174>
80801098:	e2443001 	sub	r3, r4, #1
8080109c:	e6ef3073 	uxtb	r3, r3
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
808010a0:	e3530000 	cmp	r3, #0
808010a4:	e6ef4073 	uxtb	r4, r3
808010a8:	0a000008 	beq	808010d0 <xQueueGenericReceive+0x18c>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808010ac:	e5953024 	ldr	r3, [r5, #36]	; 0x24
808010b0:	e3530000 	cmp	r3, #0
808010b4:	0a000005 	beq	808010d0 <xQueueGenericReceive+0x18c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
808010b8:	e1a00006 	mov	r0, r6
808010bc:	eb000a7a 	bl	80803aac <xTaskRemoveFromEventList>
808010c0:	e3500000 	cmp	r0, #0
808010c4:	0afffff3 	beq	80801098 <xQueueGenericReceive+0x154>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
808010c8:	eb000b28 	bl	80803d70 <vTaskMissedYield>
808010cc:	eafffff1 	b	80801098 <xQueueGenericReceive+0x154>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
808010d0:	e3e03000 	mvn	r3, #0
808010d4:	e5c53045 	strb	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
808010d8:	eb000c14 	bl	80804130 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
808010dc:	eb000c07 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
808010e0:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
808010e4:	e6ef4073 	uxtb	r4, r3

		while( cRxLock > queueLOCKED_UNMODIFIED )
808010e8:	e6af3074 	sxtb	r3, r4
808010ec:	e3530000 	cmp	r3, #0
808010f0:	da000012 	ble	80801140 <xQueueGenericReceive+0x1fc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
808010f4:	e5953010 	ldr	r3, [r5, #16]
808010f8:	e3530000 	cmp	r3, #0
808010fc:	0a00000f 	beq	80801140 <xQueueGenericReceive+0x1fc>
80801100:	e2856010 	add	r6, r5, #16
80801104:	ea000007 	b	80801128 <xQueueGenericReceive+0x1e4>
80801108:	e2443001 	sub	r3, r4, #1
8080110c:	e6ef3073 	uxtb	r3, r3
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
80801110:	e3530000 	cmp	r3, #0
80801114:	e6ef4073 	uxtb	r4, r3
80801118:	0a000008 	beq	80801140 <xQueueGenericReceive+0x1fc>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8080111c:	e5953010 	ldr	r3, [r5, #16]
80801120:	e3530000 	cmp	r3, #0
80801124:	0a000005 	beq	80801140 <xQueueGenericReceive+0x1fc>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80801128:	e1a00006 	mov	r0, r6
8080112c:	eb000a5e 	bl	80803aac <xTaskRemoveFromEventList>
80801130:	e3500000 	cmp	r0, #0
80801134:	0afffff3 	beq	80801108 <xQueueGenericReceive+0x1c4>
				{
					vTaskMissedYield();
80801138:	eb000b0c 	bl	80803d70 <vTaskMissedYield>
8080113c:	eafffff1 	b	80801108 <xQueueGenericReceive+0x1c4>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
80801140:	e3e03000 	mvn	r3, #0
80801144:	e5c53044 	strb	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
80801148:	eb000bf8 	bl	80804130 <vTaskExitCritical>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
8080114c:	eb0006b2 	bl	80802c1c <xTaskResumeAll>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
80801150:	eb000bea 	bl	80804100 <vTaskEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
80801154:	e5953038 	ldr	r3, [r5, #56]	; 0x38
80801158:	e3530000 	cmp	r3, #0
8080115c:	0a0000a7 	beq	80801400 <xQueueGenericReceive+0x4bc>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
80801160:	eb000bf2 	bl	80804130 <vTaskExitCritical>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
80801164:	eb000be5 	bl	80804100 <vTaskEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80801168:	e5954038 	ldr	r4, [r5, #56]	; 0x38
8080116c:	e3a06001 	mov	r6, #1

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80801170:	e3540000 	cmp	r4, #0
80801174:	0affff87 	beq	80800f98 <xQueueGenericReceive+0x54>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80801178:	e5952040 	ldr	r2, [r5, #64]	; 0x40
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
8080117c:	e595600c 	ldr	r6, [r5, #12]
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80801180:	e3520000 	cmp	r2, #0
80801184:	0a000007 	beq	808011a8 <xQueueGenericReceive+0x264>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80801188:	e5953004 	ldr	r3, [r5, #4]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
8080118c:	e0861002 	add	r1, r6, r2
80801190:	e585100c 	str	r1, [r5, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
80801194:	e1a00009 	mov	r0, r9
static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80801198:	e1510003 	cmp	r1, r3
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
8080119c:	25951000 	ldrcs	r1, [r5]
808011a0:	2585100c 	strcs	r1, [r5, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
808011a4:	fa002191 	blx	808097f0 <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
808011a8:	e35a0000 	cmp	sl, #0
808011ac:	1a00009c 	bne	80801424 <xQueueGenericReceive+0x4e0>
					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
808011b0:	e5953000 	ldr	r3, [r5]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
808011b4:	e2444001 	sub	r4, r4, #1
808011b8:	e5854038 	str	r4, [r5, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
808011bc:	e3530000 	cmp	r3, #0
808011c0:	0a0000dd 	beq	8080153c <xQueueGenericReceive+0x5f8>
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
808011c4:	e5953010 	ldr	r3, [r5, #16]
808011c8:	e3530000 	cmp	r3, #0
808011cc:	1a0000c8 	bne	808014f4 <xQueueGenericReceive+0x5b0>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
808011d0:	eb000bd6 	bl	80804130 <vTaskExitCritical>
				return pdPASS;
808011d4:	e3a00001 	mov	r0, #1
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
808011d8:	e28dd010 	add	sp, sp, #16
808011dc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
808011e0:	eb000bd2 	bl	80804130 <vTaskExitCritical>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
808011e4:	e5953000 	ldr	r3, [r5]
808011e8:	e3530000 	cmp	r3, #0
808011ec:	0a000087 	beq	80801410 <xQueueGenericReceive+0x4cc>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
808011f0:	e2856024 	add	r6, r5, #36	; 0x24
808011f4:	e59d1004 	ldr	r1, [sp, #4]
808011f8:	e1a00006 	mov	r0, r6
808011fc:	eb0009c5 	bl	80803918 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
80801200:	eb000bbe 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
80801204:	e5d53045 	ldrb	r3, [r5, #69]	; 0x45
80801208:	e6ef4073 	uxtb	r4, r3

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
8080120c:	e6af3074 	sxtb	r3, r4
80801210:	e3530000 	cmp	r3, #0
80801214:	ca000005 	bgt	80801230 <xQueueGenericReceive+0x2ec>
80801218:	ea00000d 	b	80801254 <xQueueGenericReceive+0x310>
8080121c:	e2443001 	sub	r3, r4, #1
80801220:	e6ef3073 	uxtb	r3, r3
80801224:	e3530000 	cmp	r3, #0
80801228:	e6ef4073 	uxtb	r4, r3
8080122c:	0a000008 	beq	80801254 <xQueueGenericReceive+0x310>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80801230:	e5953024 	ldr	r3, [r5, #36]	; 0x24
80801234:	e3530000 	cmp	r3, #0
80801238:	0a000005 	beq	80801254 <xQueueGenericReceive+0x310>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
8080123c:	e1a00006 	mov	r0, r6
80801240:	eb000a19 	bl	80803aac <xTaskRemoveFromEventList>
80801244:	e3500000 	cmp	r0, #0
80801248:	0afffff3 	beq	8080121c <xQueueGenericReceive+0x2d8>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
8080124c:	eb000ac7 	bl	80803d70 <vTaskMissedYield>
80801250:	eafffff1 	b	8080121c <xQueueGenericReceive+0x2d8>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
80801254:	e3e03000 	mvn	r3, #0
80801258:	e5c53045 	strb	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
8080125c:	eb000bb3 	bl	80804130 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80801260:	eb000ba6 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
80801264:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
80801268:	e6ef4073 	uxtb	r4, r3

		while( cRxLock > queueLOCKED_UNMODIFIED )
8080126c:	e6af3074 	sxtb	r3, r4
80801270:	e3530000 	cmp	r3, #0
80801274:	da000012 	ble	808012c4 <xQueueGenericReceive+0x380>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80801278:	e5953010 	ldr	r3, [r5, #16]
8080127c:	e3530000 	cmp	r3, #0
80801280:	0a00000f 	beq	808012c4 <xQueueGenericReceive+0x380>
80801284:	e2856010 	add	r6, r5, #16
80801288:	ea000007 	b	808012ac <xQueueGenericReceive+0x368>
8080128c:	e2443001 	sub	r3, r4, #1
80801290:	e6ef3073 	uxtb	r3, r3
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
80801294:	e3530000 	cmp	r3, #0
80801298:	e6ef4073 	uxtb	r4, r3
8080129c:	0a000008 	beq	808012c4 <xQueueGenericReceive+0x380>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
808012a0:	e5953010 	ldr	r3, [r5, #16]
808012a4:	e3530000 	cmp	r3, #0
808012a8:	0a000005 	beq	808012c4 <xQueueGenericReceive+0x380>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
808012ac:	e1a00006 	mov	r0, r6
808012b0:	eb0009fd 	bl	80803aac <xTaskRemoveFromEventList>
808012b4:	e3500000 	cmp	r0, #0
808012b8:	0afffff3 	beq	8080128c <xQueueGenericReceive+0x348>
				{
					vTaskMissedYield();
808012bc:	eb000aab 	bl	80803d70 <vTaskMissedYield>
808012c0:	eafffff1 	b	8080128c <xQueueGenericReceive+0x348>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
808012c4:	e3e03000 	mvn	r3, #0
808012c8:	e5c53044 	strb	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
808012cc:	eb000b97 	bl	80804130 <vTaskExitCritical>
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
808012d0:	eb000651 	bl	80802c1c <xTaskResumeAll>
808012d4:	e3500000 	cmp	r0, #0
808012d8:	1affffa1 	bne	80801164 <xQueueGenericReceive+0x220>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808012dc:	e5983200 	ldr	r3, [r8, #512]	; 0x200
808012e0:	e3130001 	tst	r3, #1
808012e4:	1affff9e 	bne	80801164 <xQueueGenericReceive+0x220>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808012e8:	e5887f00 	str	r7, [r8, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
808012ec:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
808012f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808012f4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808012f8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808012fc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801300:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801304:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801308:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080130c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801310:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801314:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801318:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080131c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801320:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801324:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801328:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080132c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801330:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801334:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801338:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080133c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801340:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801344:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801348:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080134c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801350:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801354:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801358:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080135c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801360:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801364:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801368:	e320f000 	nop	{0}
8080136c:	eaffff7c 	b	80801164 <xQueueGenericReceive+0x220>
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80801370:	e1a00004 	mov	r0, r4
80801374:	eb000a2c 	bl	80803c2c <vTaskSetTimeOutState>
80801378:	eaffff0c 	b	80800fb0 <xQueueGenericReceive+0x6c>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
8080137c:	e3e03000 	mvn	r3, #0
80801380:	e5c53045 	strb	r3, [r5, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
80801384:	eb000b69 	bl	80804130 <vTaskExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
80801388:	eb000b5c 	bl	80804100 <vTaskEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
8080138c:	e5d53044 	ldrb	r3, [r5, #68]	; 0x44
80801390:	e6ef4073 	uxtb	r4, r3

		while( cRxLock > queueLOCKED_UNMODIFIED )
80801394:	e6af3074 	sxtb	r3, r4
80801398:	e3530000 	cmp	r3, #0
8080139c:	da000012 	ble	808013ec <xQueueGenericReceive+0x4a8>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
808013a0:	e5953010 	ldr	r3, [r5, #16]
808013a4:	e3530000 	cmp	r3, #0
808013a8:	0a00000f 	beq	808013ec <xQueueGenericReceive+0x4a8>
808013ac:	e2856010 	add	r6, r5, #16
808013b0:	ea000007 	b	808013d4 <xQueueGenericReceive+0x490>
808013b4:	e2443001 	sub	r3, r4, #1
808013b8:	e6ef3073 	uxtb	r3, r3
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
808013bc:	e3530000 	cmp	r3, #0
808013c0:	e6ef4073 	uxtb	r4, r3
808013c4:	0a000008 	beq	808013ec <xQueueGenericReceive+0x4a8>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
808013c8:	e5953010 	ldr	r3, [r5, #16]
808013cc:	e3530000 	cmp	r3, #0
808013d0:	0a000005 	beq	808013ec <xQueueGenericReceive+0x4a8>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
808013d4:	e1a00006 	mov	r0, r6
808013d8:	eb0009b3 	bl	80803aac <xTaskRemoveFromEventList>
808013dc:	e3500000 	cmp	r0, #0
808013e0:	0afffff3 	beq	808013b4 <xQueueGenericReceive+0x470>
				{
					vTaskMissedYield();
808013e4:	eb000a61 	bl	80803d70 <vTaskMissedYield>
808013e8:	eafffff1 	b	808013b4 <xQueueGenericReceive+0x470>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
808013ec:	e3e03000 	mvn	r3, #0
808013f0:	e5c53044 	strb	r3, [r5, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
808013f4:	eb000b4d 	bl	80804130 <vTaskExitCritical>
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
808013f8:	eb000607 	bl	80802c1c <xTaskResumeAll>
808013fc:	eaffff58 	b	80801164 <xQueueGenericReceive+0x220>
			{
				if( xTicksToWait == ( TickType_t ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
80801400:	eb000b4a 	bl	80804130 <vTaskExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
80801404:	e3a00000 	mov	r0, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
80801408:	e28dd010 	add	sp, sp, #16
8080140c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						taskENTER_CRITICAL();
80801410:	eb000b3a 	bl	80804100 <vTaskEnterCritical>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
80801414:	e5950004 	ldr	r0, [r5, #4]
80801418:	eb000ad2 	bl	80803f68 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
8080141c:	eb000b43 	bl	80804130 <vTaskExitCritical>
80801420:	eaffff72 	b	808011f0 <xQueueGenericReceive+0x2ac>
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80801424:	e5953024 	ldr	r3, [r5, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
80801428:	e585600c 	str	r6, [r5, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8080142c:	e3530000 	cmp	r3, #0
80801430:	0affff66 	beq	808011d0 <xQueueGenericReceive+0x28c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80801434:	e2850024 	add	r0, r5, #36	; 0x24
80801438:	eb00099b 	bl	80803aac <xTaskRemoveFromEventList>
8080143c:	e3500000 	cmp	r0, #0
80801440:	0affff62 	beq	808011d0 <xQueueGenericReceive+0x28c>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80801444:	e3a01a01 	mov	r1, #4096	; 0x1000
80801448:	e3441824 	movt	r1, #18468	; 0x4824
8080144c:	e5913200 	ldr	r3, [r1, #512]	; 0x200
80801450:	e3130001 	tst	r3, #1
80801454:	1affff5d 	bne	808011d0 <xQueueGenericReceive+0x28c>
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80801458:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
8080145c:	e3a03801 	mov	r3, #65536	; 0x10000
80801460:	e2022003 	and	r2, r2, #3
80801464:	e1a03213 	lsl	r3, r3, r2
80801468:	e3833001 	orr	r3, r3, #1
8080146c:	e5813f00 	str	r3, [r1, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80801470:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80801474:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801478:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080147c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801480:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801484:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801488:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080148c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801490:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801494:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801498:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080149c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014a0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014a4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014a8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014ac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014b0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014b4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014b8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014bc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014c0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014c4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014c8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014cc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014d0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014d4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014d8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014dc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014e0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014e4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014e8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808014ec:	e320f000 	nop	{0}
808014f0:	eaffff36 	b	808011d0 <xQueueGenericReceive+0x28c>
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
808014f4:	e2850010 	add	r0, r5, #16
808014f8:	eb00096b 	bl	80803aac <xTaskRemoveFromEventList>
808014fc:	e3500000 	cmp	r0, #0
80801500:	1affffcf 	bne	80801444 <xQueueGenericReceive+0x500>
80801504:	eaffff31 	b	808011d0 <xQueueGenericReceive+0x28c>
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80801508:	e5953040 	ldr	r3, [r5, #64]	; 0x40
8080150c:	e3530000 	cmp	r3, #0
80801510:	0afffe94 	beq	80800f68 <xQueueGenericReceive+0x24>
80801514:	e3090980 	movw	r0, #39296	; 0x9980
80801518:	e30014dd 	movw	r1, #1245	; 0x4dd
8080151c:	e3480080 	movt	r0, #32896	; 0x8080
80801520:	eb0011ac 	bl	80805bd8 <vAssertCalled>
80801524:	eafffe8f 	b	80800f68 <xQueueGenericReceive+0x24>
BaseType_t xEntryTimeSet = pdFALSE;
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80801528:	e3090980 	movw	r0, #39296	; 0x9980
8080152c:	e30014dc 	movw	r1, #1244	; 0x4dc
80801530:	e3480080 	movt	r0, #32896	; 0x8080
80801534:	eb0011a7 	bl	80805bd8 <vAssertCalled>
80801538:	eafffe88 	b	80800f60 <xQueueGenericReceive+0x1c>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
8080153c:	eb000b3a 	bl	8080422c <pvTaskIncrementMutexHeldCount>
80801540:	e5850004 	str	r0, [r5, #4]
80801544:	eaffff1e 	b	808011c4 <xQueueGenericReceive+0x280>

80801548 <xQueueTakeMutexRecursive>:
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
80801548:	e92d4070 	push	{r4, r5, r6, lr}
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;

		configASSERT( pxMutex );
8080154c:	e2504000 	subs	r4, r0, #0
/*-----------------------------------------------------------*/

#if ( configUSE_RECURSIVE_MUTEXES == 1 )

	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
80801550:	e1a06001 	mov	r6, r1
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;

		configASSERT( pxMutex );
80801554:	0a000012 	beq	808015a4 <xQueueTakeMutexRecursive+0x5c>
		/* Comments regarding mutual exclusion as per those within
		xQueueGiveMutexRecursive(). */

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
80801558:	e5945004 	ldr	r5, [r4, #4]
8080155c:	eb000a7d 	bl	80803f58 <xTaskGetCurrentTaskHandle>
80801560:	e1550000 	cmp	r5, r0
80801564:	0a000009 	beq	80801590 <xQueueTakeMutexRecursive+0x48>
			( pxMutex->u.uxRecursiveCallCount )++;
			xReturn = pdPASS;
		}
		else
		{
			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
80801568:	e3a03000 	mov	r3, #0
8080156c:	e1a02006 	mov	r2, r6
80801570:	e1a01003 	mov	r1, r3
80801574:	e1a00004 	mov	r0, r4
80801578:	ebfffe71 	bl	80800f44 <xQueueGenericReceive>

			/* pdPASS will only be returned if the mutex was successfully
			obtained.  The calling task may have entered the Blocked state
			before reaching here. */
			if( xReturn != pdFAIL )
8080157c:	e3500000 	cmp	r0, #0
			{
				( pxMutex->u.uxRecursiveCallCount )++;
80801580:	1594300c 	ldrne	r3, [r4, #12]
80801584:	12833001 	addne	r3, r3, #1
80801588:	1584300c 	strne	r3, [r4, #12]
				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
			}
		}

		return xReturn;
	}
8080158c:	e8bd8070 	pop	{r4, r5, r6, pc}

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
		{
			( pxMutex->u.uxRecursiveCallCount )++;
80801590:	e594300c 	ldr	r3, [r4, #12]
			xReturn = pdPASS;
80801594:	e3a00001 	mov	r0, #1

		traceTAKE_MUTEX_RECURSIVE( pxMutex );

		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
		{
			( pxMutex->u.uxRecursiveCallCount )++;
80801598:	e0833000 	add	r3, r3, r0
8080159c:	e584300c 	str	r3, [r4, #12]
808015a0:	e8bd8070 	pop	{r4, r5, r6, pc}
	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
	{
	BaseType_t xReturn;
	Queue_t * const pxMutex = ( Queue_t * ) xMutex;

		configASSERT( pxMutex );
808015a4:	e3090980 	movw	r0, #39296	; 0x9980
808015a8:	e3a01f9e 	mov	r1, #632	; 0x278
808015ac:	e3480080 	movt	r0, #32896	; 0x8080
808015b0:	eb001188 	bl	80805bd8 <vAssertCalled>
808015b4:	eaffffe7 	b	80801558 <xQueueTakeMutexRecursive+0x10>

808015b8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
808015b8:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808015bc:	e2505000 	subs	r5, r0, #0
	}
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
808015c0:	e1a07001 	mov	r7, r1
808015c4:	e1a09002 	mov	r9, r2
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808015c8:	0a000033 	beq	8080169c <xQueueReceiveFromISR+0xe4>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
808015cc:	e3570000 	cmp	r7, #0
808015d0:	0a00001f 	beq	80801654 <xQueueReceiveFromISR+0x9c>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
808015d4:	eb000ea3 	bl	80805068 <xPortSetInterruptMask>
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
808015d8:	e5954038 	ldr	r4, [r5, #56]	; 0x38
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
808015dc:	e1a08000 	mov	r8, r0
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
808015e0:	e3540000 	cmp	r4, #0
808015e4:	1a000003 	bne	808015f8 <xQueueReceiveFromISR+0x40>
		{
			xReturn = pdFAIL;
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
808015e8:	e1a00008 	mov	r0, r8
808015ec:	eb000ea3 	bl	80805080 <vPortClearInterruptMask>

	return xReturn;
}
808015f0:	e1a00004 	mov	r0, r4
808015f4:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
808015f8:	e5952040 	ldr	r2, [r5, #64]	; 0x40
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			const int8_t cRxLock = pxQueue->cRxLock;
808015fc:	e5d56044 	ldrb	r6, [r5, #68]	; 0x44
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80801600:	e3520000 	cmp	r2, #0
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
		{
			const int8_t cRxLock = pxQueue->cRxLock;
80801604:	e6ef6076 	uxtb	r6, r6
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80801608:	0a000008 	beq	80801630 <xQueueReceiveFromISR+0x78>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
8080160c:	e595100c 	ldr	r1, [r5, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
80801610:	e1a00007 	mov	r0, r7
static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
80801614:	e5953004 	ldr	r3, [r5, #4]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
80801618:	e0811002 	add	r1, r1, r2
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
8080161c:	e1510003 	cmp	r1, r3

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
80801620:	e585100c 	str	r1, [r5, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
80801624:	25951000 	ldrcs	r1, [r5]
80801628:	2585100c 	strcs	r1, [r5, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
8080162c:	fa00206f 	blx	808097f0 <memcpy>

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
80801630:	e35600ff 	cmp	r6, #255	; 0xff
			const int8_t cRxLock = pxQueue->cRxLock;

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
80801634:	e2444001 	sub	r4, r4, #1
80801638:	e5854038 	str	r4, [r5, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
8080163c:	0a00000c 	beq	80801674 <xQueueReceiveFromISR+0xbc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
80801640:	e2866001 	add	r6, r6, #1
			}

			xReturn = pdPASS;
80801644:	e3a04001 	mov	r4, #1
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
80801648:	e6ef6076 	uxtb	r6, r6
8080164c:	e5c56044 	strb	r6, [r5, #68]	; 0x44
80801650:	eaffffe4 	b	808015e8 <xQueueReceiveFromISR+0x30>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
80801654:	e5953040 	ldr	r3, [r5, #64]	; 0x40
80801658:	e3530000 	cmp	r3, #0
8080165c:	0affffdc 	beq	808015d4 <xQueueReceiveFromISR+0x1c>
80801660:	e3090980 	movw	r0, #39296	; 0x9980
80801664:	e30015a1 	movw	r1, #1441	; 0x5a1
80801668:	e3480080 	movt	r0, #32896	; 0x8080
8080166c:	eb001159 	bl	80805bd8 <vAssertCalled>
80801670:	eaffffd7 	b	808015d4 <xQueueReceiveFromISR+0x1c>
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80801674:	e5953010 	ldr	r3, [r5, #16]
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
80801678:	e3a04001 	mov	r4, #1
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8080167c:	e3530000 	cmp	r3, #0
80801680:	0affffd8 	beq	808015e8 <xQueueReceiveFromISR+0x30>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80801684:	e2850010 	add	r0, r5, #16
80801688:	eb000907 	bl	80803aac <xTaskRemoveFromEventList>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
8080168c:	e3500000 	cmp	r0, #0
80801690:	13590000 	cmpne	r9, #0
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
80801694:	15894000 	strne	r4, [r9]
80801698:	eaffffd2 	b	808015e8 <xQueueReceiveFromISR+0x30>
{
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
8080169c:	e3090980 	movw	r0, #39296	; 0x9980
808016a0:	e3a01e5a 	mov	r1, #1440	; 0x5a0
808016a4:	e3480080 	movt	r0, #32896	; 0x8080
808016a8:	eb00114a 	bl	80805bd8 <vAssertCalled>
808016ac:	eaffffc6 	b	808015cc <xQueueReceiveFromISR+0x14>

808016b0 <xQueuePeekFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
808016b0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808016b4:	e2504000 	subs	r4, r0, #0
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
808016b8:	e1a05001 	mov	r5, r1
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
808016bc:	0a00002a 	beq	8080176c <xQueuePeekFromISR+0xbc>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
808016c0:	e3550000 	cmp	r5, #0
808016c4:	0a000020 	beq	8080174c <xQueuePeekFromISR+0x9c>
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
808016c8:	e5943040 	ldr	r3, [r4, #64]	; 0x40
808016cc:	e3530000 	cmp	r3, #0
808016d0:	0a000018 	beq	80801738 <xQueuePeekFromISR+0x88>
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
808016d4:	eb000e63 	bl	80805068 <xPortSetInterruptMask>
808016d8:	e1a06000 	mov	r6, r0
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
808016dc:	e5940038 	ldr	r0, [r4, #56]	; 0x38
808016e0:	e3500000 	cmp	r0, #0

			xReturn = pdPASS;
		}
		else
		{
			xReturn = pdFAIL;
808016e4:	01a04000 	moveq	r4, r0
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
808016e8:	1a000003 	bne	808016fc <xQueuePeekFromISR+0x4c>
		{
			xReturn = pdFAIL;
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
808016ec:	e1a00006 	mov	r0, r6
808016f0:	eb000e62 	bl	80805080 <vPortClearInterruptMask>

	return xReturn;
}
808016f4:	e1a00004 	mov	r0, r4
808016f8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
808016fc:	e5942040 	ldr	r2, [r4, #64]	; 0x40
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
80801700:	e594700c 	ldr	r7, [r4, #12]
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
80801704:	e3520000 	cmp	r2, #0
80801708:	0a000007 	beq	8080172c <xQueuePeekFromISR+0x7c>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
8080170c:	e5943004 	ldr	r3, [r4, #4]

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
80801710:	e0871002 	add	r1, r7, r2
80801714:	e584100c 	str	r1, [r4, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
80801718:	e1a00005 	mov	r0, r5
static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
8080171c:	e1510003 	cmp	r1, r3
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
80801720:	25941000 	ldrcs	r1, [r4]
80801724:	2584100c 	strcs	r1, [r4, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
80801728:	fa002030 	blx	808097f0 <memcpy>

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
			prvCopyDataFromQueue( pxQueue, pvBuffer );
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
8080172c:	e584700c 	str	r7, [r4, #12]

			xReturn = pdPASS;
80801730:	e3a04001 	mov	r4, #1
80801734:	eaffffec 	b	808016ec <xQueuePeekFromISR+0x3c>
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
80801738:	e3090980 	movw	r0, #39296	; 0x9980
8080173c:	e30015fe 	movw	r1, #1534	; 0x5fe
80801740:	e3480080 	movt	r0, #32896	; 0x8080
80801744:	eb001123 	bl	80805bd8 <vAssertCalled>
80801748:	eaffffe1 	b	808016d4 <xQueuePeekFromISR+0x24>
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
8080174c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
80801750:	e3530000 	cmp	r3, #0
80801754:	0afffff7 	beq	80801738 <xQueuePeekFromISR+0x88>
80801758:	e3090980 	movw	r0, #39296	; 0x9980
8080175c:	e30015fd 	movw	r1, #1533	; 0x5fd
80801760:	e3480080 	movt	r0, #32896	; 0x8080
80801764:	eb00111b 	bl	80805bd8 <vAssertCalled>
80801768:	eaffffd6 	b	808016c8 <xQueuePeekFromISR+0x18>
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
8080176c:	e3090980 	movw	r0, #39296	; 0x9980
80801770:	e30015fc 	movw	r1, #1532	; 0x5fc
80801774:	e3480080 	movt	r0, #32896	; 0x8080
80801778:	eb001116 	bl	80805bd8 <vAssertCalled>
8080177c:	eaffffcf 	b	808016c0 <xQueuePeekFromISR+0x10>

80801780 <uxQueueMessagesWaiting>:
	return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
80801780:	e92d4010 	push	{r4, lr}
UBaseType_t uxReturn;

	configASSERT( xQueue );
80801784:	e2504000 	subs	r4, r0, #0
80801788:	0a000004 	beq	808017a0 <uxQueueMessagesWaiting+0x20>

	taskENTER_CRITICAL();
8080178c:	eb000a5b 	bl	80804100 <vTaskEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
80801790:	e5944038 	ldr	r4, [r4, #56]	; 0x38
	}
	taskEXIT_CRITICAL();
80801794:	eb000a65 	bl	80804130 <vTaskExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
80801798:	e1a00004 	mov	r0, r4
8080179c:	e8bd8010 	pop	{r4, pc}

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;

	configASSERT( xQueue );
808017a0:	e3090980 	movw	r0, #39296	; 0x9980
808017a4:	e300162f 	movw	r1, #1583	; 0x62f
808017a8:	e3480080 	movt	r0, #32896	; 0x8080
808017ac:	eb001109 	bl	80805bd8 <vAssertCalled>
808017b0:	eafffff5 	b	8080178c <uxQueueMessagesWaiting+0xc>

808017b4 <uxQueueSpacesAvailable>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
808017b4:	e92d4070 	push	{r4, r5, r6, lr}
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
808017b8:	e2505000 	subs	r5, r0, #0
808017bc:	0a000006 	beq	808017dc <uxQueueSpacesAvailable+0x28>

	taskENTER_CRITICAL();
808017c0:	eb000a4e 	bl	80804100 <vTaskEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
808017c4:	e5954038 	ldr	r4, [r5, #56]	; 0x38
808017c8:	e595303c 	ldr	r3, [r5, #60]	; 0x3c
808017cc:	e0644003 	rsb	r4, r4, r3
	}
	taskEXIT_CRITICAL();
808017d0:	eb000a56 	bl	80804130 <vTaskExitCritical>

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
808017d4:	e1a00004 	mov	r0, r4
808017d8:	e8bd8070 	pop	{r4, r5, r6, pc}
{
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
	configASSERT( pxQueue );
808017dc:	e3090980 	movw	r0, #39296	; 0x9980
808017e0:	e3001641 	movw	r1, #1601	; 0x641
808017e4:	e3480080 	movt	r0, #32896	; 0x8080
808017e8:	eb0010fa 	bl	80805bd8 <vAssertCalled>
808017ec:	eafffff3 	b	808017c0 <uxQueueSpacesAvailable+0xc>

808017f0 <uxQueueMessagesWaitingFromISR>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
808017f0:	e92d4010 	push	{r4, lr}
UBaseType_t uxReturn;

	configASSERT( xQueue );
808017f4:	e2504000 	subs	r4, r0, #0
808017f8:	0a000001 	beq	80801804 <uxQueueMessagesWaitingFromISR+0x14>

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
808017fc:	e5940038 	ldr	r0, [r4, #56]	; 0x38

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
80801800:	e8bd8010 	pop	{r4, pc}

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
UBaseType_t uxReturn;

	configASSERT( xQueue );
80801804:	e3090980 	movw	r0, #39296	; 0x9980
80801808:	e3001651 	movw	r1, #1617	; 0x651
8080180c:	e3480080 	movt	r0, #32896	; 0x8080
80801810:	eb0010f0 	bl	80805bd8 <vAssertCalled>

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
80801814:	e5940038 	ldr	r0, [r4, #56]	; 0x38

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
80801818:	e8bd8010 	pop	{r4, pc}

8080181c <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
8080181c:	e92d4010 	push	{r4, lr}
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80801820:	e2504000 	subs	r4, r0, #0
80801824:	0a000002 	beq	80801834 <vQueueDelete+0x18>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
80801828:	e1a00004 	mov	r0, r4
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
8080182c:	e8bd4010 	pop	{r4, lr}

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
80801830:	ea001038 	b	80805918 <vPortFree>

void vQueueDelete( QueueHandle_t xQueue )
{
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );
80801834:	e3090980 	movw	r0, #39296	; 0x9980
80801838:	e300165d 	movw	r1, #1629	; 0x65d
8080183c:	e3480080 	movt	r0, #32896	; 0x8080
80801840:	eb0010e4 	bl	80805bd8 <vAssertCalled>

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
80801844:	e1a00004 	mov	r0, r4
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
80801848:	e8bd4010 	pop	{r4, lr}

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
8080184c:	ea001031 	b	80805918 <vPortFree>

80801850 <uxQueueGetQueueNumber>:
#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
	{
		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
	}
80801850:	e5900048 	ldr	r0, [r0, #72]	; 0x48
80801854:	e12fff1e 	bx	lr

80801858 <vQueueSetQueueNumber>:

#if ( configUSE_TRACE_FACILITY == 1 )

	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
	{
		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
80801858:	e5801048 	str	r1, [r0, #72]	; 0x48
8080185c:	e12fff1e 	bx	lr

80801860 <ucQueueGetQueueType>:
#if ( configUSE_TRACE_FACILITY == 1 )

	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
	{
		return ( ( Queue_t * ) xQueue )->ucQueueType;
	}
80801860:	e5d0004c 	ldrb	r0, [r0, #76]	; 0x4c
80801864:	e12fff1e 	bx	lr

80801868 <xQueueIsQueueEmptyFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
80801868:	e92d4010 	push	{r4, lr}
BaseType_t xReturn;

	configASSERT( xQueue );
8080186c:	e2504000 	subs	r4, r0, #0
80801870:	0a000003 	beq	80801884 <xQueueIsQueueEmptyFromISR+0x1c>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
80801874:	e5940038 	ldr	r0, [r4, #56]	; 0x38
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
80801878:	e16f0f10 	clz	r0, r0
8080187c:	e1a002a0 	lsr	r0, r0, #5
80801880:	e8bd8010 	pop	{r4, pc}

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
80801884:	e3090980 	movw	r0, #39296	; 0x9980
80801888:	e3001793 	movw	r1, #1939	; 0x793
8080188c:	e3480080 	movt	r0, #32896	; 0x8080
80801890:	eb0010d0 	bl	80805bd8 <vAssertCalled>
80801894:	eafffff6 	b	80801874 <xQueueIsQueueEmptyFromISR+0xc>

80801898 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
80801898:	e92d4010 	push	{r4, lr}
BaseType_t xReturn;

	configASSERT( xQueue );
8080189c:	e2504000 	subs	r4, r0, #0
808018a0:	0a000005 	beq	808018bc <xQueueIsQueueFullFromISR+0x24>
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
808018a4:	e5943038 	ldr	r3, [r4, #56]	; 0x38
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
808018a8:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
808018ac:	e0630000 	rsb	r0, r3, r0
808018b0:	e16f0f10 	clz	r0, r0
808018b4:	e1a002a0 	lsr	r0, r0, #5
808018b8:	e8bd8010 	pop	{r4, pc}

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
BaseType_t xReturn;

	configASSERT( xQueue );
808018bc:	e3090980 	movw	r0, #39296	; 0x9980
808018c0:	e30017ba 	movw	r1, #1978	; 0x7ba
808018c4:	e3480080 	movt	r0, #32896	; 0x8080
808018c8:	eb0010c2 	bl	80805bd8 <vAssertCalled>
808018cc:	eafffff4 	b	808018a4 <xQueueIsQueueFullFromISR+0xc>

808018d0 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
808018d0:	eafffffe 	b	808018d0 <prvIdleTask>

808018d4 <vTaskExitCritical.part.7>:
	{
		if( xSchedulerRunning != pdFALSE )
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
			{
				( pxCurrentTCB->uxCriticalNesting )--;
808018d4:	e30c3000 	movw	r3, #49152	; 0xc000
808018d8:	e3483080 	movt	r3, #32896	; 0x8080
808018dc:	e5932000 	ldr	r2, [r3]

				if( pxCurrentTCB->uxCriticalNesting == 0U )
808018e0:	e5931000 	ldr	r1, [r3]
	{
		if( xSchedulerRunning != pdFALSE )
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
			{
				( pxCurrentTCB->uxCriticalNesting )--;
808018e4:	e5923044 	ldr	r3, [r2, #68]	; 0x44
808018e8:	e2433001 	sub	r3, r3, #1
808018ec:	e5823044 	str	r3, [r2, #68]	; 0x44

				if( pxCurrentTCB->uxCriticalNesting == 0U )
808018f0:	e5913044 	ldr	r3, [r1, #68]	; 0x44
808018f4:	e3530000 	cmp	r3, #0
808018f8:	112fff1e 	bxne	lr
#endif /* portCRITICAL_NESTING_IN_TCB */
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
808018fc:	e92d4010 	push	{r4, lr}
#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	portCLEAR_INTERRUPT_MASK(x)
#define portDISABLE_INTERRUPTS()				((void)portSET_INTERRUPT_MASK())
/* #define portENABLE_INTERRUPTS()					portCLEAR_INTERRUPT_MASK(configLOWEST_INTERRUPT_PRIORITY) */
static inline void portENABLE_INTERRUPTS(void)
{
	portCLEAR_INTERRUPT_MASK(configLOWEST_INTERRUPT_PRIORITY);
80801900:	e3a000ff 	mov	r0, #255	; 0xff
80801904:	eb000ddd 	bl	80805080 <vPortClearInterruptMask>
	__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80801908:	e320f000 	nop	{0}
#if configPLATFORM==3
	__asm__ __volatile__ ( "nop" );
8080190c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801910:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801914:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801918:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080191c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801920:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801924:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801928:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080192c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801930:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801934:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801938:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080193c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801940:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801944:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801948:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080194c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801950:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801954:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801958:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080195c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801960:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801964:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801968:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080196c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801970:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801974:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801978:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080197c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801980:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80801984:	e320f000 	nop	{0}
80801988:	e8bd8010 	pop	{r4, pc}

8080198c <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
8080198c:	e92d4ff8 	push	{r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80801990:	e1a07102 	lsl	r7, r2, #2
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
80801994:	e1a09000 	mov	r9, r0
80801998:	e59d6028 	ldr	r6, [sp, #40]	; 0x28
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8080199c:	e1a00007 	mov	r0, r7
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
808019a0:	e1a05001 	mov	r5, r1
808019a4:	e1a0a003 	mov	sl, r3
808019a8:	e59d802c 	ldr	r8, [sp, #44]	; 0x2c
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
808019ac:	eb000f83 	bl	808057c0 <pvPortMalloc>

			if( pxStack != NULL )
808019b0:	e250b000 	subs	fp, r0, #0
808019b4:	0a0000b7 	beq	80801c98 <xTaskCreate+0x30c>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
808019b8:	e3a00060 	mov	r0, #96	; 0x60
808019bc:	eb000f7f 	bl	808057c0 <pvPortMalloc>

				if( pxNewTCB != NULL )
808019c0:	e2504000 	subs	r4, r0, #0
808019c4:	0a0000b1 	beq	80801c90 <xTaskCreate+0x304>

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
808019c8:	e1a02007 	mov	r2, r7
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */

				if( pxNewTCB != NULL )
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
808019cc:	e584b030 	str	fp, [r4, #48]	; 0x30

	/* Avoid dependency on memset() if it is not required. */
	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
808019d0:	e1a0000b 	mov	r0, fp
808019d4:	e3a010a5 	mov	r1, #165	; 0xa5
808019d8:	fa001fbf 	blx	808098dc <memset>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
808019dc:	e5d52000 	ldrb	r2, [r5]
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
808019e0:	e2477004 	sub	r7, r7, #4
808019e4:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
808019e8:	e5c42034 	strb	r2, [r4, #52]	; 0x34

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
808019ec:	e5d52000 	ldrb	r2, [r5]
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
808019f0:	e0837007 	add	r7, r3, r7
808019f4:	e3c77007 	bic	r7, r7, #7
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
808019f8:	e3520000 	cmp	r2, #0
808019fc:	0a000041 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a00:	e5d53001 	ldrb	r3, [r5, #1]
80801a04:	e5c43035 	strb	r3, [r4, #53]	; 0x35

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a08:	e5d53001 	ldrb	r3, [r5, #1]
80801a0c:	e3530000 	cmp	r3, #0
80801a10:	0a00003c 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a14:	e5d53002 	ldrb	r3, [r5, #2]
80801a18:	e5c43036 	strb	r3, [r4, #54]	; 0x36

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a1c:	e5d53002 	ldrb	r3, [r5, #2]
80801a20:	e3530000 	cmp	r3, #0
80801a24:	0a000037 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a28:	e5d53003 	ldrb	r3, [r5, #3]
80801a2c:	e5c43037 	strb	r3, [r4, #55]	; 0x37

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a30:	e5d53003 	ldrb	r3, [r5, #3]
80801a34:	e3530000 	cmp	r3, #0
80801a38:	0a000032 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a3c:	e5d53004 	ldrb	r3, [r5, #4]
80801a40:	e5c43038 	strb	r3, [r4, #56]	; 0x38

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a44:	e5d53004 	ldrb	r3, [r5, #4]
80801a48:	e3530000 	cmp	r3, #0
80801a4c:	0a00002d 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a50:	e5d53005 	ldrb	r3, [r5, #5]
80801a54:	e5c43039 	strb	r3, [r4, #57]	; 0x39

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a58:	e5d53005 	ldrb	r3, [r5, #5]
80801a5c:	e3530000 	cmp	r3, #0
80801a60:	0a000028 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a64:	e5d53006 	ldrb	r3, [r5, #6]
80801a68:	e5c4303a 	strb	r3, [r4, #58]	; 0x3a

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a6c:	e5d53006 	ldrb	r3, [r5, #6]
80801a70:	e3530000 	cmp	r3, #0
80801a74:	0a000023 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a78:	e5d53007 	ldrb	r3, [r5, #7]
80801a7c:	e5c4303b 	strb	r3, [r4, #59]	; 0x3b

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a80:	e5d53007 	ldrb	r3, [r5, #7]
80801a84:	e3530000 	cmp	r3, #0
80801a88:	0a00001e 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801a8c:	e5d53008 	ldrb	r3, [r5, #8]
80801a90:	e5c4303c 	strb	r3, [r4, #60]	; 0x3c

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801a94:	e5d53008 	ldrb	r3, [r5, #8]
80801a98:	e3530000 	cmp	r3, #0
80801a9c:	0a000019 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801aa0:	e5d53009 	ldrb	r3, [r5, #9]
80801aa4:	e5c4303d 	strb	r3, [r4, #61]	; 0x3d

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801aa8:	e5d53009 	ldrb	r3, [r5, #9]
80801aac:	e3530000 	cmp	r3, #0
80801ab0:	0a000014 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801ab4:	e5d5300a 	ldrb	r3, [r5, #10]
80801ab8:	e5c4303e 	strb	r3, [r4, #62]	; 0x3e

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801abc:	e5d5300a 	ldrb	r3, [r5, #10]
80801ac0:	e3530000 	cmp	r3, #0
80801ac4:	0a00000f 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801ac8:	e5d5300b 	ldrb	r3, [r5, #11]
80801acc:	e5c4303f 	strb	r3, [r4, #63]	; 0x3f

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801ad0:	e5d5300b 	ldrb	r3, [r5, #11]
80801ad4:	e3530000 	cmp	r3, #0
80801ad8:	0a00000a 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801adc:	e5d5300c 	ldrb	r3, [r5, #12]
80801ae0:	e5c43040 	strb	r3, [r4, #64]	; 0x40

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801ae4:	e5d5300c 	ldrb	r3, [r5, #12]
80801ae8:	e3530000 	cmp	r3, #0
80801aec:	0a000005 	beq	80801b08 <xTaskCreate+0x17c>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801af0:	e5d5300d 	ldrb	r3, [r5, #13]
80801af4:	e5c43041 	strb	r3, [r4, #65]	; 0x41

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80801af8:	e5d5300d 	ldrb	r3, [r5, #13]
80801afc:	e3530000 	cmp	r3, #0
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80801b00:	15d5300e 	ldrbne	r3, [r5, #14]
80801b04:	15c43042 	strbne	r3, [r4, #66]	; 0x42
80801b08:	e3560009 	cmp	r6, #9
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80801b0c:	e3a0b000 	mov	fp, #0
80801b10:	31a05006 	movcc	r5, r6
80801b14:	23a05009 	movcs	r5, #9
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80801b18:	e2846004 	add	r6, r4, #4
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
80801b1c:	e584502c 	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80801b20:	e1a00006 	mov	r0, r6
	}

	pxNewTCB->uxPriority = uxPriority;
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
80801b24:	e5845050 	str	r5, [r4, #80]	; 0x50
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80801b28:	e5c4b043 	strb	fp, [r4, #67]	; 0x43
	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80801b2c:	e265500a 	rsb	r5, r5, #10

	pxNewTCB->uxPriority = uxPriority;
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
80801b30:	e584b054 	str	fp, [r4, #84]	; 0x54
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80801b34:	ebfff96f 	bl	808000f8 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80801b38:	e2840018 	add	r0, r4, #24
80801b3c:	ebfff96d 	bl	808000f8 <vListInitialiseItem>
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80801b40:	e1a0200a 	mov	r2, sl
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
80801b44:	e584b058 	str	fp, [r4, #88]	; 0x58
	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80801b48:	e5845018 	str	r5, [r4, #24]
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80801b4c:	e1a01009 	mov	r1, r9
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );

	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
	{
		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
80801b50:	e584b044 	str	fp, [r4, #68]	; 0x44
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80801b54:	e1a00007 	mov	r0, r7
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
80801b58:	e5c4b05c 	strb	fp, [r4, #92]	; 0x5c

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80801b5c:	e30c5000 	movw	r5, #49152	; 0xc000
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80801b60:	e5844010 	str	r4, [r4, #16]

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80801b64:	e3485080 	movt	r5, #32896	; 0x8080
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80801b68:	e5844024 	str	r4, [r4, #36]	; 0x24
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80801b6c:	eb000c8b 	bl	80804da0 <pxPortInitialiseStack>
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
80801b70:	e158000b 	cmp	r8, fp
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80801b74:	e5840000 	str	r0, [r4]

	if( ( void * ) pxCreatedTask != NULL )
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80801b78:	15884000 	strne	r4, [r8]

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80801b7c:	eb000d39 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80801b80:	e5953004 	ldr	r3, [r5, #4]
80801b84:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801b88:	15952000 	ldrne	r2, [r5]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80801b8c:	15953000 	ldrne	r3, [r5]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801b90:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80801b94:	12833001 	addne	r3, r3, #1
80801b98:	15823044 	strne	r3, [r2, #68]	; 0x44
{
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
	{
		uxCurrentNumberOfTasks++;
80801b9c:	e30c3000 	movw	r3, #49152	; 0xc000
80801ba0:	e5952008 	ldr	r2, [r5, #8]
80801ba4:	e3483080 	movt	r3, #32896	; 0x8080
80801ba8:	e2822001 	add	r2, r2, #1
80801bac:	e5852008 	str	r2, [r5, #8]
		if( pxCurrentTCB == NULL )
80801bb0:	e5952000 	ldr	r2, [r5]
80801bb4:	e3520000 	cmp	r2, #0
80801bb8:	0a000038 	beq	80801ca0 <xTaskCreate+0x314>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
80801bbc:	e5932004 	ldr	r2, [r3, #4]
80801bc0:	e3520000 	cmp	r2, #0
80801bc4:	0a000029 	beq	80801c70 <xTaskCreate+0x2e4>
80801bc8:	e283800c 	add	r8, r3, #12
80801bcc:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
80801bd0:	e5950130 	ldr	r0, [r5, #304]	; 0x130
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
80801bd4:	e30c1000 	movw	r1, #49152	; 0xc000
80801bd8:	e595312c 	ldr	r3, [r5, #300]	; 0x12c
80801bdc:	e3481080 	movt	r1, #32896	; 0x8080
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
80801be0:	e1500002 	cmp	r0, r2
80801be4:	e1a00202 	lsl	r0, r2, #4
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
80801be8:	e2833001 	add	r3, r3, #1
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
80801bec:	35812130 	strcc	r2, [r1, #304]	; 0x130
80801bf0:	e0800102 	add	r0, r0, r2, lsl #2
		uxTaskNumber++;

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
80801bf4:	e5843048 	str	r3, [r4, #72]	; 0x48
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
80801bf8:	e1a01006 	mov	r1, r6
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
80801bfc:	e585312c 	str	r3, [r5, #300]	; 0x12c
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
80801c00:	e0880000 	add	r0, r8, r0
80801c04:	e30c6000 	movw	r6, #49152	; 0xc000
80801c08:	ebfff93d 	bl	80800104 <vListInsertEnd>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80801c0c:	e5953004 	ldr	r3, [r5, #4]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
80801c10:	e3486080 	movt	r6, #32896	; 0x8080

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80801c14:	e3530000 	cmp	r3, #0
80801c18:	0a000003 	beq	80801c2c <xTaskCreate+0x2a0>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80801c1c:	e5963000 	ldr	r3, [r6]
80801c20:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80801c24:	e3530000 	cmp	r3, #0
80801c28:	1a00005f 	bne	80801dac <xTaskCreate+0x420>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();

	if( xSchedulerRunning != pdFALSE )
80801c2c:	e5952004 	ldr	r2, [r5, #4]
80801c30:	e30c3000 	movw	r3, #49152	; 0xc000
80801c34:	e3483080 	movt	r3, #32896	; 0x8080
80801c38:	e3520000 	cmp	r2, #0
80801c3c:	0a000009 	beq	80801c68 <xTaskCreate+0x2dc>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80801c40:	e5932000 	ldr	r2, [r3]
80801c44:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
80801c48:	e592202c 	ldr	r2, [r2, #44]	; 0x2c
80801c4c:	e1520003 	cmp	r2, r3
80801c50:	2a000004 	bcs	80801c68 <xTaskCreate+0x2dc>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80801c54:	e3a03a01 	mov	r3, #4096	; 0x1000
80801c58:	e3443824 	movt	r3, #18468	; 0x4824
80801c5c:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80801c60:	e3120001 	tst	r2, #1
80801c64:	0a000028 	beq	80801d0c <xTaskCreate+0x380>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
80801c68:	e3a00001 	mov	r0, #1
80801c6c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80801c70:	e5931000 	ldr	r1, [r3]
80801c74:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
80801c78:	e591102c 	ldr	r1, [r1, #44]	; 0x2c
80801c7c:	e1510002 	cmp	r1, r2
				{
					pxCurrentTCB = pxNewTCB;
80801c80:	91a08003 	movls	r8, r3
80801c84:	8283800c 	addhi	r8, r3, #12
80801c88:	9488400c 	strls	r4, [r8], #12
80801c8c:	eaffffcf 	b	80801bd0 <xTaskCreate+0x244>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
80801c90:	e1a0000b 	mov	r0, fp
80801c94:	eb000f1f 	bl	80805918 <vPortFree>
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80801c98:	e3e00000 	mvn	r0, #0
		}

		return xReturn;
	}
80801c9c:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uxCurrentNumberOfTasks++;
		if( pxCurrentTCB == NULL )
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
80801ca0:	e5834000 	str	r4, [r3]
80801ca4:	e283800c 	add	r8, r3, #12

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
80801ca8:	e5932008 	ldr	r2, [r3, #8]
80801cac:	e3520001 	cmp	r2, #1
80801cb0:	1affffc5 	bne	80801bcc <xTaskCreate+0x240>
80801cb4:	e28370d4 	add	r7, r3, #212	; 0xd4
80801cb8:	e1a09008 	mov	r9, r8
80801cbc:	e1a0a007 	mov	sl, r7
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
80801cc0:	e1a00009 	mov	r0, r9
80801cc4:	e2899014 	add	r9, r9, #20
80801cc8:	ebfff902 	bl	808000d8 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80801ccc:	e159000a 	cmp	r9, sl
80801cd0:	1afffffa 	bne	80801cc0 <xTaskCreate+0x334>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
	vListInitialise( &xDelayedTaskList2 );
80801cd4:	e30c90e8 	movw	r9, #49384	; 0xc0e8
80801cd8:	e3489080 	movt	r9, #32896	; 0x8080
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
80801cdc:	e2490014 	sub	r0, r9, #20
80801ce0:	ebfff8fc 	bl	808000d8 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
80801ce4:	e1a00009 	mov	r0, r9
80801ce8:	ebfff8fa 	bl	808000d8 <vListInitialise>
	vListInitialise( &xPendingReadyList );
80801cec:	e2890014 	add	r0, r9, #20
80801cf0:	ebfff8f8 	bl	808000d8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
80801cf4:	e2890028 	add	r0, r9, #40	; 0x28
80801cf8:	ebfff8f6 	bl	808000d8 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80801cfc:	e5857124 	str	r7, [r5, #292]	; 0x124
80801d00:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80801d04:	e5859128 	str	r9, [r5, #296]	; 0x128
80801d08:	eaffffb0 	b	80801bd0 <xTaskCreate+0x244>
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80801d0c:	ee101fb0 	mrc	15, 0, r1, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80801d10:	e3a02801 	mov	r2, #65536	; 0x10000
80801d14:	e2011003 	and	r1, r1, #3
80801d18:	e1a02112 	lsl	r2, r2, r1
80801d1c:	e3822001 	orr	r2, r2, #1
80801d20:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80801d24:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80801d28:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d2c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d30:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d34:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d38:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d3c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d40:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d44:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d48:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d4c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d50:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d54:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d58:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d5c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d60:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d64:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d68:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d6c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d70:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d74:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d78:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d7c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d80:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d84:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d88:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d8c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d90:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d94:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d98:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801d9c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80801da0:	e320f000 	nop	{0}
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
			prvAddNewTaskToReadyList( pxNewTCB );
			xReturn = pdPASS;
80801da4:	e3a00001 	mov	r0, #1
80801da8:	e8bd8ff8 	pop	{r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
80801dac:	ebfffec8 	bl	808018d4 <vTaskExitCritical.part.7>
80801db0:	eaffff9d 	b	80801c2c <xTaskCreate+0x2a0>

80801db4 <eTaskGetState>:
/*-----------------------------------------------------------*/

#if( ( INCLUDE_eTaskGetState == 1 ) || ( configUSE_TRACE_FACILITY == 1 ) )

	eTaskState eTaskGetState( TaskHandle_t xTask )
	{
80801db4:	e92d4070 	push	{r4, r5, r6, lr}
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );
80801db8:	e2505000 	subs	r5, r0, #0
80801dbc:	0a00002e 	beq	80801e7c <eTaskGetState+0xc8>

		if( pxTCB == pxCurrentTCB )
80801dc0:	e30c4000 	movw	r4, #49152	; 0xc000
80801dc4:	e3484080 	movt	r4, #32896	; 0x8080
80801dc8:	e5943000 	ldr	r3, [r4]
80801dcc:	e1550003 	cmp	r5, r3
80801dd0:	0a000022 	beq	80801e60 <eTaskGetState+0xac>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80801dd4:	eb000ca3 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80801dd8:	e5943004 	ldr	r3, [r4, #4]
		}
		else
		{
			taskENTER_CRITICAL();
			{
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
80801ddc:	e5956014 	ldr	r6, [r5, #20]

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80801de0:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801de4:	15942000 	ldrne	r2, [r4]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80801de8:	15943000 	ldrne	r3, [r4]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801dec:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80801df0:	12833001 	addne	r3, r3, #1
80801df4:	15823044 	strne	r3, [r2, #68]	; 0x44

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80801df8:	e30c3000 	movw	r3, #49152	; 0xc000
80801dfc:	e5942004 	ldr	r2, [r4, #4]
80801e00:	e3483080 	movt	r3, #32896	; 0x8080
80801e04:	e3520000 	cmp	r2, #0
80801e08:	1a00000c 	bne	80801e40 <eTaskGetState+0x8c>
			{
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
			}
			taskEXIT_CRITICAL();

			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
80801e0c:	e5942124 	ldr	r2, [r4, #292]	; 0x124
80801e10:	e30c3000 	movw	r3, #49152	; 0xc000
80801e14:	e3483080 	movt	r3, #32896	; 0x8080
80801e18:	e1560002 	cmp	r6, r2
80801e1c:	0a00000d 	beq	80801e58 <eTaskGetState+0xa4>
80801e20:	e5932128 	ldr	r2, [r3, #296]	; 0x128
80801e24:	e1560002 	cmp	r6, r2
80801e28:	0a00000a 	beq	80801e58 <eTaskGetState+0xa4>
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
80801e2c:	e2833e11 	add	r3, r3, #272	; 0x110
80801e30:	e1560003 	cmp	r6, r3
80801e34:	0a00000b 	beq	80801e68 <eTaskGetState+0xb4>

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
80801e38:	e3a00001 	mov	r0, #1
			}
		}

		return eReturn;
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
80801e3c:	e8bd8070 	pop	{r4, r5, r6, pc}

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80801e40:	e5933000 	ldr	r3, [r3]
80801e44:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80801e48:	e3530000 	cmp	r3, #0
80801e4c:	0affffee 	beq	80801e0c <eTaskGetState+0x58>
80801e50:	ebfffe9f 	bl	808018d4 <vTaskExitCritical.part.7>
80801e54:	eaffffec 	b	80801e0c <eTaskGetState+0x58>
					{
						eReturn = eSuspended;
					}
					else
					{
						eReturn = eBlocked;
80801e58:	e3a00002 	mov	r0, #2
80801e5c:	e8bd8070 	pop	{r4, r5, r6, pc}
		configASSERT( pxTCB );

		if( pxTCB == pxCurrentTCB )
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
80801e60:	e3a00000 	mov	r0, #0
80801e64:	e8bd8070 	pop	{r4, r5, r6, pc}
				else if( pxStateList == &xSuspendedTaskList )
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it block
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
80801e68:	e5953028 	ldr	r3, [r5, #40]	; 0x28
					{
						eReturn = eSuspended;
80801e6c:	e3530000 	cmp	r3, #0
80801e70:	13a00002 	movne	r0, #2
80801e74:	03a00003 	moveq	r0, #3
80801e78:	e8bd8070 	pop	{r4, r5, r6, pc}
	{
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );
80801e7c:	e3090998 	movw	r0, #39320	; 0x9998
80801e80:	e30014fb 	movw	r1, #1275	; 0x4fb
80801e84:	e3480080 	movt	r0, #32896	; 0x8080
80801e88:	eb000f52 	bl	80805bd8 <vAssertCalled>
80801e8c:	eaffffcb 	b	80801dc0 <eTaskGetState+0xc>

80801e90 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
80801e90:	e92d4010 	push	{r4, lr}
80801e94:	e1a04000 	mov	r4, r0

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80801e98:	eb000c72 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80801e9c:	e30c3000 	movw	r3, #49152	; 0xc000
80801ea0:	e3483080 	movt	r3, #32896	; 0x8080
80801ea4:	e5932004 	ldr	r2, [r3, #4]
80801ea8:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801eac:	15931000 	ldrne	r1, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80801eb0:	15932000 	ldrne	r2, [r3]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801eb4:	15912044 	ldrne	r2, [r1, #68]	; 0x44
80801eb8:	12822001 	addne	r2, r2, #1
80801ebc:	15812044 	strne	r2, [r1, #68]	; 0x44

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
80801ec0:	e3540000 	cmp	r4, #0
80801ec4:	05934000 	ldreq	r4, [r3]

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80801ec8:	e5932004 	ldr	r2, [r3, #4]
80801ecc:	e30c3000 	movw	r3, #49152	; 0xc000
80801ed0:	e3483080 	movt	r3, #32896	; 0x8080
		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
			uxReturn = pxTCB->uxPriority;
80801ed4:	e594402c 	ldr	r4, [r4, #44]	; 0x2c

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80801ed8:	e3520000 	cmp	r2, #0
80801edc:	0a000003 	beq	80801ef0 <uxTaskPriorityGet+0x60>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80801ee0:	e5933000 	ldr	r3, [r3]
80801ee4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80801ee8:	e3530000 	cmp	r3, #0
80801eec:	1a000001 	bne	80801ef8 <uxTaskPriorityGet+0x68>
			uxReturn = pxTCB->uxPriority;
		}
		taskEXIT_CRITICAL();

		return uxReturn;
	}
80801ef0:	e1a00004 	mov	r0, r4
80801ef4:	e8bd8010 	pop	{r4, pc}
80801ef8:	ebfffe75 	bl	808018d4 <vTaskExitCritical.part.7>
80801efc:	e1a00004 	mov	r0, r4
80801f00:	e8bd8010 	pop	{r4, pc}

80801f04 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
80801f04:	e92d4010 	push	{r4, lr}
80801f08:	e1a04000 	mov	r4, r0
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
80801f0c:	eb000c55 	bl	80805068 <xPortSetInterruptMask>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
80801f10:	e3540000 	cmp	r4, #0
80801f14:	030c3000 	movweq	r3, #49152	; 0xc000
80801f18:	03483080 	movteq	r3, #32896	; 0x8080
80801f1c:	05934000 	ldreq	r4, [r3]
			uxReturn = pxTCB->uxPriority;
80801f20:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
80801f24:	eb000c55 	bl	80805080 <vPortClearInterruptMask>

		return uxReturn;
	}
80801f28:	e1a00004 	mov	r0, r4
80801f2c:	e8bd8010 	pop	{r4, pc}

80801f30 <vTaskPrioritySet>:
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
80801f30:	e3510009 	cmp	r1, #9
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
80801f34:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
80801f38:	e1a04000 	mov	r4, r0
80801f3c:	91a06001 	movls	r6, r1
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
80801f40:	8a000042 	bhi	80802050 <vTaskPrioritySet+0x120>

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80801f44:	e30c5000 	movw	r5, #49152	; 0xc000
80801f48:	e3485080 	movt	r5, #32896	; 0x8080

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80801f4c:	eb000c45 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80801f50:	e5953004 	ldr	r3, [r5, #4]
80801f54:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801f58:	15952000 	ldrne	r2, [r5]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80801f5c:	15953000 	ldrne	r3, [r5]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80801f60:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80801f64:	12833001 	addne	r3, r3, #1
80801f68:	15823044 	strne	r3, [r2, #68]	; 0x44

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
80801f6c:	e3540000 	cmp	r4, #0
80801f70:	05954000 	ldreq	r4, [r5]

			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );

			#if ( configUSE_MUTEXES == 1 )
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
80801f74:	e5943050 	ldr	r3, [r4, #80]	; 0x50
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
80801f78:	e1560003 	cmp	r6, r3
80801f7c:	0a00001c 	beq	80801ff4 <vTaskPrioritySet+0xc4>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
80801f80:	8a000026 	bhi	80802020 <vTaskPrioritySet+0xf0>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
80801f84:	e5957000 	ldr	r7, [r5]
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
						{
							xYieldRequired = pdTRUE;
80801f88:	e0677004 	rsb	r7, r7, r4
80801f8c:	e16f7f17 	clz	r7, r7
80801f90:	e1a072a7 	lsr	r7, r7, #5
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
80801f94:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
80801f98:	e5846050 	str	r6, [r4, #80]	; 0x50

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80801f9c:	e5941014 	ldr	r1, [r4, #20]

				#if ( configUSE_MUTEXES == 1 )
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
80801fa0:	e1530002 	cmp	r3, r2
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80801fa4:	e5943018 	ldr	r3, [r4, #24]
				{
					/* Only change the priority being used if the task is not
					currently using an inherited priority. */
					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
					{
						pxTCB->uxPriority = uxNewPriority;
80801fa8:	0584602c 	streq	r6, [r4, #44]	; 0x2c
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80801fac:	e3530000 	cmp	r3, #0

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80801fb0:	e1a03202 	lsl	r3, r2, #4

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80801fb4:	a266600a 	rsbge	r6, r6, #10
80801fb8:	a5846018 	strge	r6, [r4, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80801fbc:	e30c6000 	movw	r6, #49152	; 0xc000
80801fc0:	e3486080 	movt	r6, #32896	; 0x8080
80801fc4:	e0833102 	add	r3, r3, r2, lsl #2
80801fc8:	e286800c 	add	r8, r6, #12
80801fcc:	e0883003 	add	r3, r8, r3
80801fd0:	e1510003 	cmp	r1, r3
80801fd4:	0a000023 	beq	80802068 <vTaskPrioritySet+0x138>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
80801fd8:	e3570000 	cmp	r7, #0
80801fdc:	0a000004 	beq	80801ff4 <vTaskPrioritySet+0xc4>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80801fe0:	e3a03a01 	mov	r3, #4096	; 0x1000
80801fe4:	e3443824 	movt	r3, #18468	; 0x4824
80801fe8:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80801fec:	e3120001 	tst	r2, #1
80801ff0:	0a000029 	beq	8080209c <vTaskPrioritySet+0x16c>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80801ff4:	e5952004 	ldr	r2, [r5, #4]
80801ff8:	e30c3000 	movw	r3, #49152	; 0xc000
80801ffc:	e3483080 	movt	r3, #32896	; 0x8080
80802000:	e3520000 	cmp	r2, #0
80802004:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80802008:	e5933000 	ldr	r3, [r3]
8080200c:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80802010:	e3530000 	cmp	r3, #0
80802014:	08bd87f0 	popeq	{r4, r5, r6, r7, r8, r9, sl, pc}
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
	}
80802018:	e8bd47f0 	pop	{r4, r5, r6, r7, r8, r9, sl, lr}
8080201c:	eafffe2c 	b	808018d4 <vTaskExitCritical.part.7>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
				{
					if( pxTCB != pxCurrentTCB )
80802020:	e5951000 	ldr	r1, [r5]
80802024:	e30c2000 	movw	r2, #49152	; 0xc000
80802028:	e3482080 	movt	r2, #32896	; 0x8080
8080202c:	e1540001 	cmp	r4, r1

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
80802030:	03a07000 	moveq	r7, #0
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
				{
					if( pxTCB != pxCurrentTCB )
80802034:	0affffd6 	beq	80801f94 <vTaskPrioritySet+0x64>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
80802038:	e5922000 	ldr	r2, [r2]
						{
							xYieldRequired = pdTRUE;
8080203c:	e592702c 	ldr	r7, [r2, #44]	; 0x2c
80802040:	e1560007 	cmp	r6, r7
80802044:	33a07000 	movcc	r7, #0
80802048:	23a07001 	movcs	r7, #1
8080204c:	eaffffd0 	b	80801f94 <vTaskPrioritySet+0x64>
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
80802050:	e3090998 	movw	r0, #39320	; 0x9998
80802054:	e3a01d16 	mov	r1, #1408	; 0x580
80802058:	e3480080 	movt	r0, #32896	; 0x8080

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
8080205c:	e3a06009 	mov	r6, #9
	{
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
80802060:	eb000edc 	bl	80805bd8 <vAssertCalled>
80802064:	eaffffb6 	b	80801f44 <vTaskPrioritySet+0x14>
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80802068:	e2849004 	add	r9, r4, #4
8080206c:	e1a00009 	mov	r0, r9
80802070:	ebfff844 	bl	80800188 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
80802074:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
80802078:	e1a01009 	mov	r1, r9
8080207c:	e5962130 	ldr	r2, [r6, #304]	; 0x130
80802080:	e1a00203 	lsl	r0, r3, #4
80802084:	e1530002 	cmp	r3, r2
80802088:	85863130 	strhi	r3, [r6, #304]	; 0x130
8080208c:	e0800103 	add	r0, r0, r3, lsl #2
80802090:	e0880000 	add	r0, r8, r0
80802094:	ebfff81a 	bl	80800104 <vListInsertEnd>
80802098:	eaffffce 	b	80801fd8 <vTaskPrioritySet+0xa8>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
8080209c:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808020a0:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808020a4:	e2022003 	and	r2, r2, #3
808020a8:	e1a02211 	lsl	r2, r1, r2
808020ac:	e3822001 	orr	r2, r2, #1
808020b0:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
808020b4:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
808020b8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020bc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020c0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020c4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020c8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020cc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020d0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020d4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020d8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020dc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020e0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020e4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020e8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020ec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020f4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020f8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808020fc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802100:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802104:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802108:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080210c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802110:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802114:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802118:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080211c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802120:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802124:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802128:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080212c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802130:	e320f000 	nop	{0}
80802134:	eaffffae 	b	80801ff4 <vTaskPrioritySet+0xc4>

80802138 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
80802138:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
8080213c:	e30c4000 	movw	r4, #49152	; 0xc000
80802140:	e3484080 	movt	r4, #32896	; 0x8080
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
80802144:	e1a05000 	mov	r5, r0

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80802148:	eb000bc6 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
8080214c:	e5943004 	ldr	r3, [r4, #4]
80802150:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80802154:	15942000 	ldrne	r2, [r4]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80802158:	15943000 	ldrne	r3, [r4]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
8080215c:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80802160:	12833001 	addne	r3, r3, #1
80802164:	15823044 	strne	r3, [r2, #68]	; 0x44

		taskENTER_CRITICAL();
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
80802168:	e3550000 	cmp	r5, #0
8080216c:	05945000 	ldreq	r5, [r4]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80802170:	e2857004 	add	r7, r5, #4
80802174:	e1a00007 	mov	r0, r7
80802178:	ebfff802 	bl	80800188 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
8080217c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
80802180:	e3530000 	cmp	r3, #0
80802184:	0a000001 	beq	80802190 <vTaskSuspend+0x58>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80802188:	e2850018 	add	r0, r5, #24
8080218c:	ebfff7fd 	bl	80800188 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
80802190:	e30c6000 	movw	r6, #49152	; 0xc000
80802194:	e1a01007 	mov	r1, r7
80802198:	e3486080 	movt	r6, #32896	; 0x8080
8080219c:	e2860e11 	add	r0, r6, #272	; 0x110
808021a0:	ebfff7d7 	bl	80800104 <vListInsertEnd>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
808021a4:	e5943004 	ldr	r3, [r4, #4]
808021a8:	e3530000 	cmp	r3, #0
808021ac:	0a000003 	beq	808021c0 <vTaskSuspend+0x88>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
808021b0:	e5963000 	ldr	r3, [r6]
808021b4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
808021b8:	e3530000 	cmp	r3, #0
808021bc:	1a000037 	bne	808022a0 <vTaskSuspend+0x168>

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
		}
		taskEXIT_CRITICAL();

		if( xSchedulerRunning != pdFALSE )
808021c0:	e5943004 	ldr	r3, [r4, #4]
808021c4:	e30c6000 	movw	r6, #49152	; 0xc000
808021c8:	e3486080 	movt	r6, #32896	; 0x8080
808021cc:	e3530000 	cmp	r3, #0
808021d0:	1a000011 	bne	8080221c <vTaskSuspend+0xe4>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
808021d4:	e5942000 	ldr	r2, [r4]
808021d8:	e30c3000 	movw	r3, #49152	; 0xc000
808021dc:	e3483080 	movt	r3, #32896	; 0x8080
808021e0:	e1550002 	cmp	r5, r2
808021e4:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
		{
			if( xSchedulerRunning != pdFALSE )
808021e8:	e5932004 	ldr	r2, [r3, #4]
808021ec:	e3520000 	cmp	r2, #0
808021f0:	1a00002c 	bne	808022a8 <vTaskSuspend+0x170>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
808021f4:	e5931008 	ldr	r1, [r3, #8]
808021f8:	e5930110 	ldr	r0, [r3, #272]	; 0x110
808021fc:	e1500001 	cmp	r0, r1
80802200:	0a0000d5 	beq	8080255c <vTaskSuspend+0x424>
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
80802204:	e5932134 	ldr	r2, [r3, #308]	; 0x134
80802208:	e3520000 	cmp	r2, #0
8080220c:	0a000054 	beq	80802364 <vTaskSuspend+0x22c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
80802210:	e3a02001 	mov	r2, #1
80802214:	e5832138 	str	r2, [r3, #312]	; 0x138
80802218:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
8080221c:	eb000b91 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80802220:	e5963004 	ldr	r3, [r6, #4]
80802224:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80802228:	15962000 	ldrne	r2, [r6]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
8080222c:	15963000 	ldrne	r3, [r6]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80802230:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80802234:	12833001 	addne	r3, r3, #1
80802238:	15823044 	strne	r3, [r2, #68]	; 0x44

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
8080223c:	e30c3000 	movw	r3, #49152	; 0xc000
80802240:	e5942124 	ldr	r2, [r4, #292]	; 0x124
80802244:	e3483080 	movt	r3, #32896	; 0x8080
80802248:	e5922000 	ldr	r2, [r2]
8080224c:	e3520000 	cmp	r2, #0
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
80802250:	03e02000 	mvneq	r2, #0
80802254:	0583213c 	streq	r2, [r3, #316]	; 0x13c

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80802258:	1a00000a 	bne	80802288 <vTaskSuspend+0x150>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
8080225c:	e5942004 	ldr	r2, [r4, #4]
80802260:	e30c3000 	movw	r3, #49152	; 0xc000
80802264:	e3483080 	movt	r3, #32896	; 0x8080
80802268:	e3520000 	cmp	r2, #0
8080226c:	0affffd8 	beq	808021d4 <vTaskSuspend+0x9c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80802270:	e5933000 	ldr	r3, [r3]
80802274:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80802278:	e3530000 	cmp	r3, #0
8080227c:	0affffd4 	beq	808021d4 <vTaskSuspend+0x9c>
80802280:	ebfffd93 	bl	808018d4 <vTaskExitCritical.part.7>
80802284:	eaffffd2 	b	808021d4 <vTaskSuspend+0x9c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80802288:	e5932124 	ldr	r2, [r3, #292]	; 0x124
8080228c:	e592200c 	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
80802290:	e592200c 	ldr	r2, [r2, #12]
80802294:	e5922004 	ldr	r2, [r2, #4]
80802298:	e583213c 	str	r2, [r3, #316]	; 0x13c
8080229c:	eaffffee 	b	8080225c <vTaskSuspend+0x124>
808022a0:	ebfffd8b 	bl	808018d4 <vTaskExitCritical.part.7>
808022a4:	eaffffc5 	b	808021c0 <vTaskSuspend+0x88>
		if( pxTCB == pxCurrentTCB )
		{
			if( xSchedulerRunning != pdFALSE )
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
808022a8:	e5933134 	ldr	r3, [r3, #308]	; 0x134
808022ac:	e3530000 	cmp	r3, #0
808022b0:	1a0000a2 	bne	80802540 <vTaskSuspend+0x408>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808022b4:	e3a03a01 	mov	r3, #4096	; 0x1000
808022b8:	e3443824 	movt	r3, #18468	; 0x4824
808022bc:	e5932200 	ldr	r2, [r3, #512]	; 0x200
808022c0:	e3120001 	tst	r2, #1
808022c4:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808022c8:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808022cc:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808022d0:	e2022003 	and	r2, r2, #3
808022d4:	e1a02211 	lsl	r2, r1, r2
808022d8:	e3822001 	orr	r2, r2, #1
808022dc:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
808022e0:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
808022e4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808022e8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808022ec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808022f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808022f4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808022f8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808022fc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802300:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802304:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802308:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080230c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802310:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802314:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802318:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080231c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802320:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802324:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802328:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080232c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802330:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802334:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802338:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080233c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802340:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802344:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802348:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080234c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802350:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802354:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802358:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080235c:	e320f000 	nop	{0}
80802360:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
80802364:	e5832138 	str	r2, [r3, #312]	; 0x138
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
80802368:	e5935130 	ldr	r5, [r3, #304]	; 0x130
8080236c:	e1a02105 	lsl	r2, r5, #2
80802370:	e1a01205 	lsl	r1, r5, #4
80802374:	e0820001 	add	r0, r2, r1
80802378:	e0833000 	add	r3, r3, r0
8080237c:	e593300c 	ldr	r3, [r3, #12]
80802380:	e3530000 	cmp	r3, #0
80802384:	1a00005e 	bne	80802504 <vTaskSuspend+0x3cc>
80802388:	e3550000 	cmp	r5, #0
8080238c:	0a00007e 	beq	8080258c <vTaskSuspend+0x454>
80802390:	e2453001 	sub	r3, r5, #1
80802394:	e1a02103 	lsl	r2, r3, #2
80802398:	e1a01203 	lsl	r1, r3, #4
8080239c:	e0820001 	add	r0, r2, r1
808023a0:	e0840000 	add	r0, r4, r0
808023a4:	e590000c 	ldr	r0, [r0, #12]
808023a8:	e3500000 	cmp	r0, #0
808023ac:	1a000068 	bne	80802554 <vTaskSuspend+0x41c>
808023b0:	e3530000 	cmp	r3, #0
808023b4:	0a00006f 	beq	80802578 <vTaskSuspend+0x440>
808023b8:	e2453002 	sub	r3, r5, #2
808023bc:	e1a02103 	lsl	r2, r3, #2
808023c0:	e1a01203 	lsl	r1, r3, #4
808023c4:	e0820001 	add	r0, r2, r1
808023c8:	e0840000 	add	r0, r4, r0
808023cc:	e590000c 	ldr	r0, [r0, #12]
808023d0:	e3500000 	cmp	r0, #0
808023d4:	1a00005e 	bne	80802554 <vTaskSuspend+0x41c>
808023d8:	e3530000 	cmp	r3, #0
808023dc:	0a000060 	beq	80802564 <vTaskSuspend+0x42c>
808023e0:	e2453003 	sub	r3, r5, #3
808023e4:	e1a02103 	lsl	r2, r3, #2
808023e8:	e1a01203 	lsl	r1, r3, #4
808023ec:	e0820001 	add	r0, r2, r1
808023f0:	e0840000 	add	r0, r4, r0
808023f4:	e590000c 	ldr	r0, [r0, #12]
808023f8:	e3500000 	cmp	r0, #0
808023fc:	1a000054 	bne	80802554 <vTaskSuspend+0x41c>
80802400:	e3530000 	cmp	r3, #0
80802404:	0a000083 	beq	80802618 <vTaskSuspend+0x4e0>
80802408:	e2453004 	sub	r3, r5, #4
8080240c:	e1a02103 	lsl	r2, r3, #2
80802410:	e1a01203 	lsl	r1, r3, #4
80802414:	e0820001 	add	r0, r2, r1
80802418:	e0840000 	add	r0, r4, r0
8080241c:	e590000c 	ldr	r0, [r0, #12]
80802420:	e3500000 	cmp	r0, #0
80802424:	1a00004a 	bne	80802554 <vTaskSuspend+0x41c>
80802428:	e3530000 	cmp	r3, #0
8080242c:	0a000074 	beq	80802604 <vTaskSuspend+0x4cc>
80802430:	e2453005 	sub	r3, r5, #5
80802434:	e1a02103 	lsl	r2, r3, #2
80802438:	e1a01203 	lsl	r1, r3, #4
8080243c:	e0820001 	add	r0, r2, r1
80802440:	e0840000 	add	r0, r4, r0
80802444:	e590000c 	ldr	r0, [r0, #12]
80802448:	e3500000 	cmp	r0, #0
8080244c:	1a000040 	bne	80802554 <vTaskSuspend+0x41c>
80802450:	e3530000 	cmp	r3, #0
80802454:	0a000065 	beq	808025f0 <vTaskSuspend+0x4b8>
80802458:	e2453006 	sub	r3, r5, #6
8080245c:	e1a02103 	lsl	r2, r3, #2
80802460:	e1a01203 	lsl	r1, r3, #4
80802464:	e0820001 	add	r0, r2, r1
80802468:	e0840000 	add	r0, r4, r0
8080246c:	e590000c 	ldr	r0, [r0, #12]
80802470:	e3500000 	cmp	r0, #0
80802474:	1a000036 	bne	80802554 <vTaskSuspend+0x41c>
80802478:	e3530000 	cmp	r3, #0
8080247c:	0a000056 	beq	808025dc <vTaskSuspend+0x4a4>
80802480:	e2453007 	sub	r3, r5, #7
80802484:	e1a02103 	lsl	r2, r3, #2
80802488:	e1a01203 	lsl	r1, r3, #4
8080248c:	e0820001 	add	r0, r2, r1
80802490:	e0840000 	add	r0, r4, r0
80802494:	e590000c 	ldr	r0, [r0, #12]
80802498:	e3500000 	cmp	r0, #0
8080249c:	1a00002c 	bne	80802554 <vTaskSuspend+0x41c>
808024a0:	e3530000 	cmp	r3, #0
808024a4:	0a000047 	beq	808025c8 <vTaskSuspend+0x490>
808024a8:	e2453008 	sub	r3, r5, #8
808024ac:	e1a02103 	lsl	r2, r3, #2
808024b0:	e1a01203 	lsl	r1, r3, #4
808024b4:	e0820001 	add	r0, r2, r1
808024b8:	e0840000 	add	r0, r4, r0
808024bc:	e590000c 	ldr	r0, [r0, #12]
808024c0:	e3500000 	cmp	r0, #0
808024c4:	1a000022 	bne	80802554 <vTaskSuspend+0x41c>
808024c8:	e3530000 	cmp	r3, #0
808024cc:	0a000038 	beq	808025b4 <vTaskSuspend+0x47c>
808024d0:	e2453009 	sub	r3, r5, #9
808024d4:	e1a02103 	lsl	r2, r3, #2
808024d8:	e1a01203 	lsl	r1, r3, #4
808024dc:	e0820001 	add	r0, r2, r1
808024e0:	e0840000 	add	r0, r4, r0
808024e4:	e590000c 	ldr	r0, [r0, #12]
808024e8:	e3500000 	cmp	r0, #0
808024ec:	1a000018 	bne	80802554 <vTaskSuspend+0x41c>
808024f0:	e3530000 	cmp	r3, #0
808024f4:	0a000029 	beq	808025a0 <vTaskSuspend+0x468>
808024f8:	e245500a 	sub	r5, r5, #10
808024fc:	e1a02105 	lsl	r2, r5, #2
80802500:	e1a01205 	lsl	r1, r5, #4
80802504:	e0822001 	add	r2, r2, r1
80802508:	e30c1014 	movw	r1, #49172	; 0xc014
8080250c:	e0840002 	add	r0, r4, r2
80802510:	e3481080 	movt	r1, #32896	; 0x8080
80802514:	e5903010 	ldr	r3, [r0, #16]
80802518:	e0822001 	add	r2, r2, r1
8080251c:	e5933004 	ldr	r3, [r3, #4]
80802520:	e1530002 	cmp	r3, r2
80802524:	e5803010 	str	r3, [r0, #16]
80802528:	05933004 	ldreq	r3, [r3, #4]
8080252c:	05803010 	streq	r3, [r0, #16]
80802530:	e593300c 	ldr	r3, [r3, #12]
80802534:	e5843000 	str	r3, [r4]
80802538:	e5845130 	str	r5, [r4, #304]	; 0x130
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
8080253c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		if( pxTCB == pxCurrentTCB )
		{
			if( xSchedulerRunning != pdFALSE )
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
80802540:	e3090998 	movw	r0, #39320	; 0x9998
80802544:	e3001657 	movw	r1, #1623	; 0x657
80802548:	e3480080 	movt	r0, #32896	; 0x8080
8080254c:	eb000da1 	bl	80805bd8 <vAssertCalled>
80802550:	eaffff57 	b	808022b4 <vTaskSuspend+0x17c>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
80802554:	e1a05003 	mov	r5, r3
80802558:	eaffffe9 	b	80802504 <vTaskSuspend+0x3cc>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
8080255c:	e5832000 	str	r2, [r3]
80802560:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
80802564:	e3090998 	movw	r0, #39320	; 0x9998
80802568:	e3001af6 	movw	r1, #2806	; 0xaf6
8080256c:	e3480080 	movt	r0, #32896	; 0x8080
80802570:	eb000d98 	bl	80805bd8 <vAssertCalled>
80802574:	eaffff99 	b	808023e0 <vTaskSuspend+0x2a8>
80802578:	e3090998 	movw	r0, #39320	; 0x9998
8080257c:	e3001af6 	movw	r1, #2806	; 0xaf6
80802580:	e3480080 	movt	r0, #32896	; 0x8080
80802584:	eb000d93 	bl	80805bd8 <vAssertCalled>
80802588:	eaffff8a 	b	808023b8 <vTaskSuspend+0x280>
8080258c:	e3090998 	movw	r0, #39320	; 0x9998
80802590:	e3001af6 	movw	r1, #2806	; 0xaf6
80802594:	e3480080 	movt	r0, #32896	; 0x8080
80802598:	eb000d8e 	bl	80805bd8 <vAssertCalled>
8080259c:	eaffff7b 	b	80802390 <vTaskSuspend+0x258>
808025a0:	e3090998 	movw	r0, #39320	; 0x9998
808025a4:	e3001af6 	movw	r1, #2806	; 0xaf6
808025a8:	e3480080 	movt	r0, #32896	; 0x8080
808025ac:	eb000d89 	bl	80805bd8 <vAssertCalled>
808025b0:	eaffffd0 	b	808024f8 <vTaskSuspend+0x3c0>
808025b4:	e3090998 	movw	r0, #39320	; 0x9998
808025b8:	e3001af6 	movw	r1, #2806	; 0xaf6
808025bc:	e3480080 	movt	r0, #32896	; 0x8080
808025c0:	eb000d84 	bl	80805bd8 <vAssertCalled>
808025c4:	eaffffc1 	b	808024d0 <vTaskSuspend+0x398>
808025c8:	e3090998 	movw	r0, #39320	; 0x9998
808025cc:	e3001af6 	movw	r1, #2806	; 0xaf6
808025d0:	e3480080 	movt	r0, #32896	; 0x8080
808025d4:	eb000d7f 	bl	80805bd8 <vAssertCalled>
808025d8:	eaffffb2 	b	808024a8 <vTaskSuspend+0x370>
808025dc:	e3090998 	movw	r0, #39320	; 0x9998
808025e0:	e3001af6 	movw	r1, #2806	; 0xaf6
808025e4:	e3480080 	movt	r0, #32896	; 0x8080
808025e8:	eb000d7a 	bl	80805bd8 <vAssertCalled>
808025ec:	eaffffa3 	b	80802480 <vTaskSuspend+0x348>
808025f0:	e3090998 	movw	r0, #39320	; 0x9998
808025f4:	e3001af6 	movw	r1, #2806	; 0xaf6
808025f8:	e3480080 	movt	r0, #32896	; 0x8080
808025fc:	eb000d75 	bl	80805bd8 <vAssertCalled>
80802600:	eaffff94 	b	80802458 <vTaskSuspend+0x320>
80802604:	e3090998 	movw	r0, #39320	; 0x9998
80802608:	e3001af6 	movw	r1, #2806	; 0xaf6
8080260c:	e3480080 	movt	r0, #32896	; 0x8080
80802610:	eb000d70 	bl	80805bd8 <vAssertCalled>
80802614:	eaffff85 	b	80802430 <vTaskSuspend+0x2f8>
80802618:	e3090998 	movw	r0, #39320	; 0x9998
8080261c:	e3001af6 	movw	r1, #2806	; 0xaf6
80802620:	e3480080 	movt	r0, #32896	; 0x8080
80802624:	eb000d6b 	bl	80805bd8 <vAssertCalled>
80802628:	eaffff76 	b	80802408 <vTaskSuspend+0x2d0>

8080262c <vTaskResume>:
	void vTaskResume( TaskHandle_t xTaskToResume )
	{
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
8080262c:	e3500000 	cmp	r0, #0
80802630:	0a000065 	beq	808027cc <vTaskResume+0x1a0>
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
80802634:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
80802638:	e30c4000 	movw	r4, #49152	; 0xc000
8080263c:	e3484080 	movt	r4, #32896	; 0x8080
80802640:	e5943000 	ldr	r3, [r4]
80802644:	e1500003 	cmp	r0, r3
80802648:	0a00005e 	beq	808027c8 <vTaskResume+0x19c>
8080264c:	e1a06000 	mov	r6, r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
80802650:	e30c5000 	movw	r5, #49152	; 0xc000

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80802654:	eb000a83 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80802658:	e5943004 	ldr	r3, [r4, #4]

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
8080265c:	e3485080 	movt	r5, #32896	; 0x8080

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80802660:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80802664:	15942000 	ldrne	r2, [r4]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80802668:	15943000 	ldrne	r3, [r4]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
8080266c:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80802670:	12833001 	addne	r3, r3, #1
80802674:	15823044 	strne	r3, [r2, #68]	; 0x44

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
80802678:	e2853e11 	add	r3, r5, #272	; 0x110
8080267c:	e5962014 	ldr	r2, [r6, #20]
80802680:	e1520003 	cmp	r2, r3
80802684:	0a00000a 	beq	808026b4 <vTaskResume+0x88>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80802688:	e5942004 	ldr	r2, [r4, #4]
8080268c:	e30c3000 	movw	r3, #49152	; 0xc000
80802690:	e3483080 	movt	r3, #32896	; 0x8080
80802694:	e3520000 	cmp	r2, #0
80802698:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
8080269c:	e5933000 	ldr	r3, [r3]
808026a0:	e5933044 	ldr	r3, [r3, #68]	; 0x44
808026a4:	e3530000 	cmp	r3, #0
808026a8:	08bd81f0 	popeq	{r4, r5, r6, r7, r8, pc}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
808026ac:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
808026b0:	eafffc87 	b	808018d4 <vTaskExitCritical.part.7>

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
808026b4:	e5963028 	ldr	r3, [r6, #40]	; 0x28
808026b8:	e28520fc 	add	r2, r5, #252	; 0xfc
808026bc:	e1530002 	cmp	r3, r2
808026c0:	0afffff0 	beq	80802688 <vTaskResume+0x5c>
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
		{
			taskENTER_CRITICAL();
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
808026c4:	e3530000 	cmp	r3, #0
808026c8:	1affffee 	bne	80802688 <vTaskResume+0x5c>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
808026cc:	e2867004 	add	r7, r6, #4
808026d0:	e1a00007 	mov	r0, r7
808026d4:	ebfff6ab 	bl	80800188 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
808026d8:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
808026dc:	e30c000c 	movw	r0, #49164	; 0xc00c
808026e0:	e5952130 	ldr	r2, [r5, #304]	; 0x130
808026e4:	e3480080 	movt	r0, #32896	; 0x8080
808026e8:	e1a01007 	mov	r1, r7
808026ec:	e1530002 	cmp	r3, r2
808026f0:	e1a02203 	lsl	r2, r3, #4
808026f4:	85853130 	strhi	r3, [r5, #304]	; 0x130
808026f8:	e0823103 	add	r3, r2, r3, lsl #2
808026fc:	e0800003 	add	r0, r0, r3
80802700:	ebfff67f 	bl	80800104 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80802704:	e5943000 	ldr	r3, [r4]
80802708:	e596202c 	ldr	r2, [r6, #44]	; 0x2c
8080270c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
80802710:	e1520003 	cmp	r2, r3
80802714:	3affffdb 	bcc	80802688 <vTaskResume+0x5c>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80802718:	e3a03a01 	mov	r3, #4096	; 0x1000
8080271c:	e3443824 	movt	r3, #18468	; 0x4824
80802720:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80802724:	e3120001 	tst	r2, #1
80802728:	1affffd6 	bne	80802688 <vTaskResume+0x5c>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
8080272c:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80802730:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80802734:	e2022003 	and	r2, r2, #3
80802738:	e1a02211 	lsl	r2, r1, r2
8080273c:	e3822001 	orr	r2, r2, #1
80802740:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80802744:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80802748:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080274c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802750:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802754:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802758:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080275c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802760:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802764:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802768:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080276c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802770:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802774:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802778:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080277c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802780:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802784:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802788:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080278c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802790:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802794:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802798:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080279c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027a0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027a4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027a8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027ac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027b0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027b4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027b8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027bc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808027c0:	e320f000 	nop	{0}
808027c4:	eaffffaf 	b	80802688 <vTaskResume+0x5c>
808027c8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	void vTaskResume( TaskHandle_t xTaskToResume )
	{
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;

		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );
808027cc:	e3090998 	movw	r0, #39320	; 0x9998
808027d0:	e30016ab 	movw	r1, #1707	; 0x6ab
808027d4:	e3480080 	movt	r0, #32896	; 0x8080
808027d8:	ea000cfe 	b	80805bd8 <vAssertCalled>

808027dc <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
808027dc:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	BaseType_t xYieldRequired = pdFALSE;
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
808027e0:	e2506000 	subs	r6, r0, #0
808027e4:	0a00002d 	beq	808028a0 <xTaskResumeFromISR+0xc4>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
808027e8:	eb000a1e 	bl	80805068 <xPortSetInterruptMask>
808027ec:	e1a07000 	mov	r7, r0

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
808027f0:	e30c4000 	movw	r4, #49152	; 0xc000
808027f4:	e5962014 	ldr	r2, [r6, #20]
808027f8:	e3484080 	movt	r4, #32896	; 0x8080
808027fc:	e2843e11 	add	r3, r4, #272	; 0x110
80802800:	e1520003 	cmp	r2, r3
80802804:	0a000004 	beq	8080281c <xTaskResumeFromISR+0x40>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
80802808:	e3a05000 	mov	r5, #0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
8080280c:	e1a00007 	mov	r0, r7
80802810:	eb000a1a 	bl	80805080 <vPortClearInterruptMask>

		return xYieldRequired;
	}
80802814:	e1a00005 	mov	r0, r5
80802818:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
8080281c:	e5965028 	ldr	r5, [r6, #40]	; 0x28
80802820:	e28400fc 	add	r0, r4, #252	; 0xfc
80802824:	e1550000 	cmp	r5, r0
80802828:	0afffff6 	beq	80802808 <xTaskResumeFromISR+0x2c>
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
8080282c:	e3550000 	cmp	r5, #0
80802830:	1afffff4 	bne	80802808 <xTaskResumeFromISR+0x2c>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80802834:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80802838:	e3530000 	cmp	r3, #0
8080283c:	1a000014 	bne	80802894 <xTaskResumeFromISR+0xb8>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80802840:	e5943000 	ldr	r3, [r4]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80802844:	e2868004 	add	r8, r6, #4

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
80802848:	e596502c 	ldr	r5, [r6, #44]	; 0x2c
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
8080284c:	e1a00008 	mov	r0, r8

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
	BaseType_t xYieldRequired = pdFALSE;
80802850:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
80802854:	e1550003 	cmp	r5, r3
80802858:	33a05000 	movcc	r5, #0
8080285c:	23a05001 	movcs	r5, #1
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80802860:	ebfff648 	bl	80800188 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80802864:	e596302c 	ldr	r3, [r6, #44]	; 0x2c
80802868:	e30c000c 	movw	r0, #49164	; 0xc00c
8080286c:	e5942130 	ldr	r2, [r4, #304]	; 0x130
80802870:	e3480080 	movt	r0, #32896	; 0x8080
80802874:	e1a01008 	mov	r1, r8
80802878:	e1530002 	cmp	r3, r2
8080287c:	e1a02203 	lsl	r2, r3, #4
80802880:	85843130 	strhi	r3, [r4, #304]	; 0x130
80802884:	e0823103 	add	r3, r2, r3, lsl #2
80802888:	e0800003 	add	r0, r0, r3
8080288c:	ebfff61c 	bl	80800104 <vListInsertEnd>
80802890:	eaffffdd 	b	8080280c <xTaskResumeFromISR+0x30>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80802894:	e2861018 	add	r1, r6, #24
80802898:	ebfff619 	bl	80800104 <vListInsertEnd>
8080289c:	eaffffda 	b	8080280c <xTaskResumeFromISR+0x30>
	{
	BaseType_t xYieldRequired = pdFALSE;
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToResume );
808028a0:	e3090998 	movw	r0, #39320	; 0x9998
808028a4:	e30016e2 	movw	r1, #1762	; 0x6e2
808028a8:	e3480080 	movt	r0, #32896	; 0x8080
808028ac:	eb000cc9 	bl	80805bd8 <vAssertCalled>
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
808028b0:	eb0009ec 	bl	80805068 <xPortSetInterruptMask>
808028b4:	e1a07000 	mov	r7, r0

		/* Accesses xPendingReadyList so must be called from a critical
		section. */

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );
808028b8:	e3090998 	movw	r0, #39320	; 0x9998
808028bc:	e3480080 	movt	r0, #32896	; 0x8080
808028c0:	e3001681 	movw	r1, #1665	; 0x681
808028c4:	eb000cc3 	bl	80805bd8 <vAssertCalled>
808028c8:	eaffffc8 	b	808027f0 <xTaskResumeFromISR+0x14>

808028cc <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
808028cc:	e92d4070 	push	{r4, r5, r6, lr}
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
808028d0:	e30c4000 	movw	r4, #49152	; 0xc000
808028d4:	e3484080 	movt	r4, #32896	; 0x8080

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
808028d8:	e24dd008 	sub	sp, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
808028dc:	e3a05000 	mov	r5, #0
808028e0:	e2843d05 	add	r3, r4, #320	; 0x140
808028e4:	e30919b0 	movw	r1, #39344	; 0x99b0
808028e8:	e30108d0 	movw	r0, #6352	; 0x18d0
808028ec:	e58d3004 	str	r3, [sp, #4]
808028f0:	e3481080 	movt	r1, #32896	; 0x8080
808028f4:	e1a03005 	mov	r3, r5
808028f8:	e58d5000 	str	r5, [sp]
808028fc:	e3480080 	movt	r0, #32896	; 0x8080
80802900:	e3a02b01 	mov	r2, #1024	; 0x400
80802904:	ebfffc20 	bl	8080198c <xTaskCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
80802908:	e3500001 	cmp	r0, #1
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
8080290c:	e1a06000 	mov	r6, r0
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
80802910:	0a000009 	beq	8080293c <vTaskStartScheduler+0x70>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
80802914:	e3700001 	cmn	r0, #1
80802918:	0a000001 	beq	80802924 <vTaskStartScheduler+0x58>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
8080291c:	e28dd008 	add	sp, sp, #8
80802920:	e8bd8070 	pop	{r4, r5, r6, pc}
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
80802924:	e3090998 	movw	r0, #39320	; 0x9998
80802928:	e3001784 	movw	r1, #1924	; 0x784
8080292c:	e3480080 	movt	r0, #32896	; 0x8080
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
80802930:	e28dd008 	add	sp, sp, #8
80802934:	e8bd4070 	pop	{r4, r5, r6, lr}
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
80802938:	ea000ca6 	b	80805bd8 <vAssertCalled>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
8080293c:	eb0009c9 	bl	80805068 <xPortSetInterruptMask>
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
80802940:	e3e03000 	mvn	r3, #0
80802944:	e584313c 	str	r3, [r4, #316]	; 0x13c
		xSchedulerRunning = pdTRUE;
80802948:	e5846004 	str	r6, [r4, #4]
		xTickCount = ( TickType_t ) 0U;
8080294c:	e5845144 	str	r5, [r4, #324]	; 0x144
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
80802950:	e28dd008 	add	sp, sp, #8
80802954:	e8bd4070 	pop	{r4, r5, r6, lr}
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
80802958:	ea00093f 	b	80804e5c <vPortSMCHandler>

8080295c <vTaskEndScheduler>:
	( void ) xIdleTaskHandle;
}
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
8080295c:	e92d4010 	push	{r4, lr}
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
80802960:	eb0009c0 	bl	80805068 <xPortSetInterruptMask>
	xSchedulerRunning = pdFALSE;
80802964:	e30c3000 	movw	r3, #49152	; 0xc000
80802968:	e3a02000 	mov	r2, #0
8080296c:	e3483080 	movt	r3, #32896	; 0x8080
	vPortEndScheduler();
}
80802970:	e8bd4010 	pop	{r4, lr}
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
	xSchedulerRunning = pdFALSE;
80802974:	e5832004 	str	r2, [r3, #4]
	vPortEndScheduler();
80802978:	ea00096d 	b	80804f34 <vPortEndScheduler>

8080297c <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
8080297c:	e30c3000 	movw	r3, #49152	; 0xc000
80802980:	e3483080 	movt	r3, #32896	; 0x8080
80802984:	e5932134 	ldr	r2, [r3, #308]	; 0x134
80802988:	e2822001 	add	r2, r2, #1
8080298c:	e5832134 	str	r2, [r3, #308]	; 0x134
80802990:	e12fff1e 	bx	lr

80802994 <xTaskGetTickCount>:
	return xAlreadyYielded;
}
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
80802994:	e92d4010 	push	{r4, lr}

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80802998:	eb0009b2 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
8080299c:	e30c3000 	movw	r3, #49152	; 0xc000
808029a0:	e3483080 	movt	r3, #32896	; 0x8080
808029a4:	e5932004 	ldr	r2, [r3, #4]
808029a8:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808029ac:	15931000 	ldrne	r1, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
808029b0:	15932000 	ldrne	r2, [r3]
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
808029b4:	e5934144 	ldr	r4, [r3, #324]	; 0x144
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808029b8:	15912044 	ldrne	r2, [r1, #68]	; 0x44

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
808029bc:	e5933004 	ldr	r3, [r3, #4]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808029c0:	12822001 	addne	r2, r2, #1
808029c4:	15812044 	strne	r2, [r1, #68]	; 0x44

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
808029c8:	e3530000 	cmp	r3, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
808029cc:	e30c2000 	movw	r2, #49152	; 0xc000
808029d0:	e3482080 	movt	r2, #32896	; 0x8080

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
808029d4:	0a000003 	beq	808029e8 <xTaskGetTickCount+0x54>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
808029d8:	e5923000 	ldr	r3, [r2]
808029dc:	e5933044 	ldr	r3, [r3, #68]	; 0x44
808029e0:	e3530000 	cmp	r3, #0
808029e4:	1a000001 	bne	808029f0 <xTaskGetTickCount+0x5c>
		xTicks = xTickCount;
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
}
808029e8:	e1a00004 	mov	r0, r4
808029ec:	e8bd8010 	pop	{r4, pc}
808029f0:	ebfffbb7 	bl	808018d4 <vTaskExitCritical.part.7>
808029f4:	e1a00004 	mov	r0, r4
808029f8:	e8bd8010 	pop	{r4, pc}

808029fc <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
808029fc:	e92d4010 	push	{r4, lr}
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
80802a00:	eb000998 	bl	80805068 <xPortSetInterruptMask>
	{
		xReturn = xTickCount;
80802a04:	e30c3000 	movw	r3, #49152	; 0xc000
80802a08:	e3483080 	movt	r3, #32896	; 0x8080
80802a0c:	e5934144 	ldr	r4, [r3, #324]	; 0x144
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
80802a10:	eb00099a 	bl	80805080 <vPortClearInterruptMask>

	return xReturn;
}
80802a14:	e1a00004 	mov	r0, r4
80802a18:	e8bd8010 	pop	{r4, pc}

80802a1c <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
80802a1c:	e30c3000 	movw	r3, #49152	; 0xc000
80802a20:	e3483080 	movt	r3, #32896	; 0x8080
80802a24:	e5930008 	ldr	r0, [r3, #8]
}
80802a28:	e12fff1e 	bx	lr

80802a2c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
80802a2c:	e92d4010 	push	{r4, lr}
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
80802a30:	e2504000 	subs	r4, r0, #0
80802a34:	0a000001 	beq	80802a40 <pcTaskGetName+0x14>
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
80802a38:	e2840034 	add	r0, r4, #52	; 0x34
80802a3c:	e8bd8010 	pop	{r4, pc}
{
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
80802a40:	e30c3000 	movw	r3, #49152	; 0xc000
80802a44:	e3483080 	movt	r3, #32896	; 0x8080
80802a48:	e5934000 	ldr	r4, [r3]
	configASSERT( pxTCB );
80802a4c:	e3540000 	cmp	r4, #0
80802a50:	1afffff8 	bne	80802a38 <pcTaskGetName+0xc>
80802a54:	e3090998 	movw	r0, #39320	; 0x9998
80802a58:	e300188c 	movw	r1, #2188	; 0x88c
80802a5c:	e3480080 	movt	r0, #32896	; 0x8080
80802a60:	eb000c5c 	bl	80805bd8 <vAssertCalled>
	return &( pxTCB->pcTaskName[ 0 ] );
}
80802a64:	e2840034 	add	r0, r4, #52	; 0x34
80802a68:	e8bd8010 	pop	{r4, pc}

80802a6c <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
80802a6c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80802a70:	e30c4000 	movw	r4, #49152	; 0xc000
80802a74:	e3484080 	movt	r4, #32896	; 0x8080
80802a78:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80802a7c:	e3530000 	cmp	r3, #0
80802a80:	1a000051 	bne	80802bcc <xTaskIncrementTick+0x160>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
80802a84:	e5947144 	ldr	r7, [r4, #324]	; 0x144
80802a88:	e2877001 	add	r7, r7, #1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;

		if( xConstTickCount == ( TickType_t ) 0U )
80802a8c:	e3570000 	cmp	r7, #0
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
80802a90:	e5847144 	str	r7, [r4, #324]	; 0x144

		if( xConstTickCount == ( TickType_t ) 0U )
80802a94:	1a000012 	bne	80802ae4 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
80802a98:	e5943124 	ldr	r3, [r4, #292]	; 0x124
80802a9c:	e5933000 	ldr	r3, [r3]
80802aa0:	e3530000 	cmp	r3, #0
80802aa4:	1a000057 	bne	80802c08 <xTaskIncrementTick+0x19c>
80802aa8:	e5942124 	ldr	r2, [r4, #292]	; 0x124
80802aac:	e30c3000 	movw	r3, #49152	; 0xc000
80802ab0:	e5941128 	ldr	r1, [r4, #296]	; 0x128
80802ab4:	e3483080 	movt	r3, #32896	; 0x8080
80802ab8:	e5841124 	str	r1, [r4, #292]	; 0x124
80802abc:	e5842128 	str	r2, [r4, #296]	; 0x128
80802ac0:	e5942148 	ldr	r2, [r4, #328]	; 0x148
80802ac4:	e2822001 	add	r2, r2, #1
80802ac8:	e5842148 	str	r2, [r4, #328]	; 0x148

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80802acc:	e5942124 	ldr	r2, [r4, #292]	; 0x124
80802ad0:	e5922000 	ldr	r2, [r2]
80802ad4:	e3520000 	cmp	r2, #0
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
80802ad8:	03e02000 	mvneq	r2, #0
80802adc:	0583213c 	streq	r2, [r3, #316]	; 0x13c

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80802ae0:	1a00003e 	bne	80802be0 <xTaskIncrementTick+0x174>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
80802ae4:	e594313c 	ldr	r3, [r4, #316]	; 0x13c
80802ae8:	e1570003 	cmp	r7, r3

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
80802aec:	33a06000 	movcc	r6, #0

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
80802af0:	3a000028 	bcc	80802b98 <xTaskIncrementTick+0x12c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80802af4:	e30c8000 	movw	r8, #49152	; 0xc000
80802af8:	e3a06000 	mov	r6, #0
80802afc:	e3488080 	movt	r8, #32896	; 0x8080
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
80802b00:	e288900c 	add	r9, r8, #12
80802b04:	ea00001b 	b	80802b78 <xTaskIncrementTick+0x10c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80802b08:	e5982124 	ldr	r2, [r8, #292]	; 0x124
80802b0c:	e592200c 	ldr	r2, [r2, #12]
80802b10:	e592500c 	ldr	r5, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
80802b14:	e5952004 	ldr	r2, [r5, #4]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80802b18:	e285a004 	add	sl, r5, #4
80802b1c:	e1a0000a 	mov	r0, sl
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );

					if( xConstTickCount < xItemValue )
80802b20:	e1570002 	cmp	r7, r2
80802b24:	3a00001a 	bcc	80802b94 <xTaskIncrementTick+0x128>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80802b28:	ebfff596 	bl	80800188 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80802b2c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80802b30:	e2850018 	add	r0, r5, #24
					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80802b34:	e3530000 	cmp	r3, #0
80802b38:	0a000000 	beq	80802b40 <xTaskIncrementTick+0xd4>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80802b3c:	ebfff591 	bl	80800188 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
80802b40:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
80802b44:	e1a0100a 	mov	r1, sl
80802b48:	e5942130 	ldr	r2, [r4, #304]	; 0x130
80802b4c:	e1a00203 	lsl	r0, r3, #4
80802b50:	e1530002 	cmp	r3, r2
80802b54:	85883130 	strhi	r3, [r8, #304]	; 0x130
80802b58:	e0800103 	add	r0, r0, r3, lsl #2
80802b5c:	e0890000 	add	r0, r9, r0
80802b60:	ebfff567 	bl	80800104 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80802b64:	e5943000 	ldr	r3, [r4]
80802b68:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
80802b6c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
						{
							xSwitchRequired = pdTRUE;
80802b70:	e1520003 	cmp	r2, r3
80802b74:	23a06001 	movcs	r6, #1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80802b78:	e5942124 	ldr	r2, [r4, #292]	; 0x124
80802b7c:	e30c3000 	movw	r3, #49152	; 0xc000
80802b80:	e3483080 	movt	r3, #32896	; 0x8080
80802b84:	e5922000 	ldr	r2, [r2]
80802b88:	e3520000 	cmp	r2, #0
80802b8c:	1affffdd 	bne	80802b08 <xTaskIncrementTick+0x9c>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80802b90:	e3e02000 	mvn	r2, #0
80802b94:	e583213c 	str	r2, [r3, #316]	; 0x13c
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
80802b98:	e5943000 	ldr	r3, [r4]
80802b9c:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
80802ba0:	e1a03202 	lsl	r3, r2, #4
80802ba4:	e0833102 	add	r3, r3, r2, lsl #2
80802ba8:	e0843003 	add	r3, r4, r3
80802bac:	e593300c 	ldr	r3, [r3, #12]
			{
				xSwitchRequired = pdTRUE;
80802bb0:	e3530002 	cmp	r3, #2
80802bb4:	23a06001 	movcs	r6, #1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
80802bb8:	e5943138 	ldr	r3, [r4, #312]	; 0x138
		{
			xSwitchRequired = pdTRUE;
80802bbc:	e3530000 	cmp	r3, #0
80802bc0:	13a06001 	movne	r6, #1
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
80802bc4:	e1a00006 	mov	r0, r6
80802bc8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
80802bcc:	e594314c 	ldr	r3, [r4, #332]	; 0x14c

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
80802bd0:	e3a06000 	mov	r6, #0
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
80802bd4:	e2833001 	add	r3, r3, #1
80802bd8:	e584314c 	str	r3, [r4, #332]	; 0x14c
80802bdc:	eafffff5 	b	80802bb8 <xTaskIncrementTick+0x14c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80802be0:	e5932124 	ldr	r2, [r3, #292]	; 0x124
80802be4:	e592200c 	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
80802be8:	e592200c 	ldr	r2, [r2, #12]
80802bec:	e5922004 	ldr	r2, [r2, #4]
80802bf0:	e583213c 	str	r2, [r3, #316]	; 0x13c

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
80802bf4:	e594313c 	ldr	r3, [r4, #316]	; 0x13c
80802bf8:	e1570003 	cmp	r7, r3

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
80802bfc:	33a06000 	movcc	r6, #0

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
80802c00:	3affffe4 	bcc	80802b98 <xTaskIncrementTick+0x12c>
80802c04:	eaffffba 	b	80802af4 <xTaskIncrementTick+0x88>
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;

		if( xConstTickCount == ( TickType_t ) 0U )
		{
			taskSWITCH_DELAYED_LISTS();
80802c08:	e3090998 	movw	r0, #39320	; 0x9998
80802c0c:	e30019d9 	movw	r1, #2521	; 0x9d9
80802c10:	e3480080 	movt	r0, #32896	; 0x8080
80802c14:	eb000bef 	bl	80805bd8 <vAssertCalled>
80802c18:	eaffffa2 	b	80802aa8 <xTaskIncrementTick+0x3c>

80802c1c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
80802c1c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
80802c20:	e30c4000 	movw	r4, #49152	; 0xc000
80802c24:	e3484080 	movt	r4, #32896	; 0x8080
80802c28:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80802c2c:	e3530000 	cmp	r3, #0
80802c30:	0a000082 	beq	80802e40 <xTaskResumeAll+0x224>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80802c34:	eb00090b 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80802c38:	e5942004 	ldr	r2, [r4, #4]
80802c3c:	e30c3000 	movw	r3, #49152	; 0xc000
80802c40:	e3483080 	movt	r3, #32896	; 0x8080
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
	{
		--uxSchedulerSuspended;
80802c44:	e30c6000 	movw	r6, #49152	; 0xc000
80802c48:	e3486080 	movt	r6, #32896	; 0x8080

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80802c4c:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80802c50:	15932000 	ldrne	r2, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80802c54:	15933000 	ldrne	r3, [r3]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80802c58:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80802c5c:	12833001 	addne	r3, r3, #1
80802c60:	15823044 	strne	r3, [r2, #68]	; 0x44
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
	{
		--uxSchedulerSuspended;
80802c64:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80802c68:	e2433001 	sub	r3, r3, #1
80802c6c:	e5843134 	str	r3, [r4, #308]	; 0x134

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80802c70:	e5945134 	ldr	r5, [r4, #308]	; 0x134
80802c74:	e3550000 	cmp	r5, #0
80802c78:	1a000004 	bne	80802c90 <xTaskResumeAll+0x74>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80802c7c:	e5963008 	ldr	r3, [r6, #8]
80802c80:	e3530000 	cmp	r3, #0
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
					prvAddTaskToReadyList( pxTCB );
80802c84:	1286700c 	addne	r7, r6, #12

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
80802c88:	13a08001 	movne	r8, #1
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
80802c8c:	1a000020 	bne	80802d14 <xTaskResumeAll+0xf8>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
80802c90:	e3a05000 	mov	r5, #0

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80802c94:	e5942004 	ldr	r2, [r4, #4]
80802c98:	e30c3000 	movw	r3, #49152	; 0xc000
80802c9c:	e3483080 	movt	r3, #32896	; 0x8080
80802ca0:	e3520000 	cmp	r2, #0
80802ca4:	0a000003 	beq	80802cb8 <xTaskResumeAll+0x9c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80802ca8:	e5933000 	ldr	r3, [r3]
80802cac:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80802cb0:	e3530000 	cmp	r3, #0
80802cb4:	1a00005e 	bne	80802e34 <xTaskResumeAll+0x218>
		}
	}
	taskEXIT_CRITICAL();

	return xAlreadyYielded;
}
80802cb8:	e1a00005 	mov	r0, r5
80802cbc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
80802cc0:	e5963108 	ldr	r3, [r6, #264]	; 0x108
80802cc4:	e593500c 	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80802cc8:	e2859004 	add	r9, r5, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80802ccc:	e2850018 	add	r0, r5, #24
80802cd0:	ebfff52c 	bl	80800188 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80802cd4:	e1a00009 	mov	r0, r9
80802cd8:	ebfff52a 	bl	80800188 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80802cdc:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
80802ce0:	e1a01009 	mov	r1, r9
80802ce4:	e5962130 	ldr	r2, [r6, #304]	; 0x130
80802ce8:	e1a00203 	lsl	r0, r3, #4
80802cec:	e1530002 	cmp	r3, r2
80802cf0:	85863130 	strhi	r3, [r6, #304]	; 0x130
80802cf4:	e0800103 	add	r0, r0, r3, lsl #2
80802cf8:	e0870000 	add	r0, r7, r0
80802cfc:	ebfff500 	bl	80800104 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80802d00:	e5943000 	ldr	r3, [r4]
80802d04:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
80802d08:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
80802d0c:	e1520003 	cmp	r2, r3
					{
						xYieldPending = pdTRUE;
80802d10:	25868138 	strcs	r8, [r6, #312]	; 0x138
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
80802d14:	e59420fc 	ldr	r2, [r4, #252]	; 0xfc
80802d18:	e30c3000 	movw	r3, #49152	; 0xc000
80802d1c:	e3483080 	movt	r3, #32896	; 0x8080
80802d20:	e3520000 	cmp	r2, #0
80802d24:	1affffe5 	bne	80802cc0 <xTaskResumeAll+0xa4>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
80802d28:	e3550000 	cmp	r5, #0
80802d2c:	0a000005 	beq	80802d48 <xTaskResumeAll+0x12c>

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80802d30:	e5932124 	ldr	r2, [r3, #292]	; 0x124
80802d34:	e5922000 	ldr	r2, [r2]
80802d38:	e3520000 	cmp	r2, #0
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
80802d3c:	03e02000 	mvneq	r2, #0
80802d40:	0583213c 	streq	r2, [r3, #316]	; 0x13c

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80802d44:	1a000042 	bne	80802e54 <xTaskResumeAll+0x238>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
80802d48:	e594514c 	ldr	r5, [r4, #332]	; 0x14c

					if( uxPendedCounts > ( UBaseType_t ) 0U )
80802d4c:	e3550000 	cmp	r5, #0
80802d50:	0a000006 	beq	80802d70 <xTaskResumeAll+0x154>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
80802d54:	e3a06001 	mov	r6, #1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
80802d58:	ebffff43 	bl	80802a6c <xTaskIncrementTick>
80802d5c:	e3500000 	cmp	r0, #0
							{
								xYieldPending = pdTRUE;
80802d60:	15846138 	strne	r6, [r4, #312]	; 0x138
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
80802d64:	e2555001 	subs	r5, r5, #1
80802d68:	1afffffa 	bne	80802d58 <xTaskResumeAll+0x13c>

						uxPendedTicks = 0;
80802d6c:	e584514c 	str	r5, [r4, #332]	; 0x14c
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
80802d70:	e5943138 	ldr	r3, [r4, #312]	; 0x138
80802d74:	e3530000 	cmp	r3, #0
80802d78:	0affffc4 	beq	80802c90 <xTaskResumeAll+0x74>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80802d7c:	e3a03a01 	mov	r3, #4096	; 0x1000
80802d80:	e3443824 	movt	r3, #18468	; 0x4824
80802d84:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80802d88:	e3120001 	tst	r2, #1
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
80802d8c:	13a05001 	movne	r5, #1
80802d90:	1affffbf 	bne	80802c94 <xTaskResumeAll+0x78>
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80802d94:	ee101fb0 	mrc	15, 0, r1, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80802d98:	e3a02801 	mov	r2, #65536	; 0x10000
80802d9c:	e2011003 	and	r1, r1, #3
80802da0:	e1a02112 	lsl	r2, r2, r1
80802da4:	e3822001 	orr	r2, r2, #1
80802da8:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80802dac:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80802db0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802db4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802db8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dbc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dc0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dc4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dc8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dcc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dd0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dd4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dd8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802ddc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802de0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802de4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802de8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802df0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802df4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802df8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802dfc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e00:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e04:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e08:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e0c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e10:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e14:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e18:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e1c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e20:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e24:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802e28:	e320f000 	nop	{0}
80802e2c:	e3a05001 	mov	r5, #1
80802e30:	eaffff97 	b	80802c94 <xTaskResumeAll+0x78>
80802e34:	ebfffaa6 	bl	808018d4 <vTaskExitCritical.part.7>
		}
	}
	taskEXIT_CRITICAL();

	return xAlreadyYielded;
}
80802e38:	e1a00005 	mov	r0, r5
80802e3c:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
80802e40:	e3090998 	movw	r0, #39320	; 0x9998
80802e44:	e30017e8 	movw	r1, #2024	; 0x7e8
80802e48:	e3480080 	movt	r0, #32896	; 0x8080
80802e4c:	eb000b61 	bl	80805bd8 <vAssertCalled>
80802e50:	eaffff77 	b	80802c34 <xTaskResumeAll+0x18>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80802e54:	e5932124 	ldr	r2, [r3, #292]	; 0x124
80802e58:	e592200c 	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
80802e5c:	e592200c 	ldr	r2, [r2, #12]
80802e60:	e5922004 	ldr	r2, [r2, #4]
80802e64:	e583213c 	str	r2, [r3, #316]	; 0x13c
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
80802e68:	e594514c 	ldr	r5, [r4, #332]	; 0x14c

					if( uxPendedCounts > ( UBaseType_t ) 0U )
80802e6c:	e3550000 	cmp	r5, #0
80802e70:	0affffbe 	beq	80802d70 <xTaskResumeAll+0x154>
80802e74:	eaffffb6 	b	80802d54 <xTaskResumeAll+0x138>

80802e78 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
80802e78:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
80802e7c:	e2506000 	subs	r6, r0, #0
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
80802e80:	e1a05001 	mov	r5, r1
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
80802e84:	0a00006e 	beq	80803044 <vTaskDelayUntil+0x1cc>
		configASSERT( ( xTimeIncrement > 0U ) );
80802e88:	e3550000 	cmp	r5, #0
80802e8c:	0a000062 	beq	8080301c <vTaskDelayUntil+0x1a4>
		configASSERT( uxSchedulerSuspended == 0 );
80802e90:	e30c4000 	movw	r4, #49152	; 0xc000
80802e94:	e3484080 	movt	r4, #32896	; 0x8080
80802e98:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80802e9c:	e3530000 	cmp	r3, #0
80802ea0:	1a000058 	bne	80803008 <vTaskDelayUntil+0x190>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80802ea4:	e5943134 	ldr	r3, [r4, #308]	; 0x134
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80802ea8:	e5962000 	ldr	r2, [r6]
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80802eac:	e2833001 	add	r3, r3, #1
80802eb0:	e5843134 	str	r3, [r4, #308]	; 0x134
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80802eb4:	e0851002 	add	r1, r5, r2

		vTaskSuspendAll();
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
80802eb8:	e5945144 	ldr	r5, [r4, #324]	; 0x144
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
80802ebc:	e1550001 	cmp	r5, r1
80802ec0:	23a03000 	movcs	r3, #0
80802ec4:	33a03001 	movcc	r3, #1
			const TickType_t xConstTickCount = xTickCount;

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;

			if( xConstTickCount < *pxPreviousWakeTime )
80802ec8:	e1550002 	cmp	r5, r2
80802ecc:	2a000033 	bcs	80802fa0 <vTaskDelayUntil+0x128>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
80802ed0:	e1520001 	cmp	r2, r1
80802ed4:	93a03000 	movls	r3, #0
80802ed8:	e3530000 	cmp	r3, #0
80802edc:	1a000034 	bne	80802fb4 <vTaskDelayUntil+0x13c>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80802ee0:	e5861000 	str	r1, [r6]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80802ee4:	ebffff4c 	bl	80802c1c <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
80802ee8:	e3500000 	cmp	r0, #0
80802eec:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80802ef0:	e3a03a01 	mov	r3, #4096	; 0x1000
80802ef4:	e3443824 	movt	r3, #18468	; 0x4824
80802ef8:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80802efc:	e3120001 	tst	r2, #1
80802f00:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80802f04:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80802f08:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80802f0c:	e2022003 	and	r2, r2, #3
80802f10:	e1a02211 	lsl	r2, r1, r2
80802f14:	e3822001 	orr	r2, r2, #1
80802f18:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80802f1c:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80802f20:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f24:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f28:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f2c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f30:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f34:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f38:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f3c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f40:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f44:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f48:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f4c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f50:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f54:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f58:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f5c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f60:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f64:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f68:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f6c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f70:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f74:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f78:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f7c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f80:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f84:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f88:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f8c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f90:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f94:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80802f98:	e320f000 	nop	{0}
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
80802f9c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
80802fa0:	e1520001 	cmp	r2, r1
80802fa4:	91a02003 	movls	r2, r3
80802fa8:	83832001 	orrhi	r2, r3, #1
80802fac:	e3520000 	cmp	r2, #0
80802fb0:	0affffca 	beq	80802ee0 <vTaskDelayUntil+0x68>


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
80802fb4:	e5948144 	ldr	r8, [r4, #324]	; 0x144
80802fb8:	e30c7000 	movw	r7, #49152	; 0xc000
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80802fbc:	e5940000 	ldr	r0, [r4]


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
80802fc0:	e3487080 	movt	r7, #32896	; 0x8080
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80802fc4:	e5861000 	str	r1, [r6]
80802fc8:	e0655008 	rsb	r5, r5, r8
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80802fcc:	e2800004 	add	r0, r0, #4
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
80802fd0:	e0815005 	add	r5, r1, r5
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80802fd4:	ebfff46b 	bl	80800188 <uxListRemove>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80802fd8:	e5943000 	ldr	r3, [r4]

			if( xTimeToWake < xConstTickCount )
80802fdc:	e1580005 	cmp	r8, r5
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80802fe0:	e5835004 	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
80802fe4:	8a000011 	bhi	80803030 <vTaskDelayUntil+0x1b8>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80802fe8:	e5970124 	ldr	r0, [r7, #292]	; 0x124
80802fec:	e5971000 	ldr	r1, [r7]
80802ff0:	e2811004 	add	r1, r1, #4
80802ff4:	ebfff44c 	bl	8080012c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
80802ff8:	e597313c 	ldr	r3, [r7, #316]	; 0x13c
80802ffc:	e1550003 	cmp	r5, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
80803000:	3587513c 	strcc	r5, [r7, #316]	; 0x13c
80803004:	eaffffb6 	b	80802ee4 <vTaskDelayUntil+0x6c>
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );
80803008:	e3090998 	movw	r0, #39320	; 0x9998
8080300c:	e300147b 	movw	r1, #1147	; 0x47b
80803010:	e3480080 	movt	r0, #32896	; 0x8080
80803014:	eb000aef 	bl	80805bd8 <vAssertCalled>
80803018:	eaffffa1 	b	80802ea4 <vTaskDelayUntil+0x2c>
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
8080301c:	e3090998 	movw	r0, #39320	; 0x9998
80803020:	e300147a 	movw	r1, #1146	; 0x47a
80803024:	e3480080 	movt	r0, #32896	; 0x8080
80803028:	eb000aea 	bl	80805bd8 <vAssertCalled>
8080302c:	eaffff97 	b	80802e90 <vTaskDelayUntil+0x18>

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80803030:	e5970128 	ldr	r0, [r7, #296]	; 0x128
80803034:	e5971000 	ldr	r1, [r7]
80803038:	e2811004 	add	r1, r1, #4
8080303c:	ebfff43a 	bl	8080012c <vListInsert>
80803040:	eaffffa7 	b	80802ee4 <vTaskDelayUntil+0x6c>
	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
80803044:	e3090998 	movw	r0, #39320	; 0x9998
80803048:	e3001479 	movw	r1, #1145	; 0x479
8080304c:	e3480080 	movt	r0, #32896	; 0x8080
80803050:	eb000ae0 	bl	80805bd8 <vAssertCalled>
80803054:	eaffff8b 	b	80802e88 <vTaskDelayUntil+0x10>

80803058 <vTaskDelay>:
	void vTaskDelay( const TickType_t xTicksToDelay )
	{
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
80803058:	e3500000 	cmp	r0, #0
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
8080305c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
80803060:	0a00001d 	beq	808030dc <vTaskDelay+0x84>
		{
			configASSERT( uxSchedulerSuspended == 0 );
80803064:	e30c4000 	movw	r4, #49152	; 0xc000
80803068:	e1a05000 	mov	r5, r0
8080306c:	e3484080 	movt	r4, #32896	; 0x8080
80803070:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80803074:	e3530000 	cmp	r3, #0
80803078:	1a000048 	bne	808031a0 <vTaskDelay+0x148>
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
8080307c:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80803080:	e30c6000 	movw	r6, #49152	; 0xc000
80803084:	e3486080 	movt	r6, #32896	; 0x8080
80803088:	e2833001 	add	r3, r3, #1
8080308c:	e5843134 	str	r3, [r4, #308]	; 0x134


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
80803090:	e5947144 	ldr	r7, [r4, #324]	; 0x144
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80803094:	e5940000 	ldr	r0, [r4]
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
80803098:	e0855007 	add	r5, r5, r7
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
8080309c:	e2800004 	add	r0, r0, #4
808030a0:	ebfff438 	bl	80800188 <uxListRemove>
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
808030a4:	e5943000 	ldr	r3, [r4]

			if( xTimeToWake < xConstTickCount )
808030a8:	e1570005 	cmp	r7, r5
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
808030ac:	e5835004 	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
808030b0:	8a000035 	bhi	8080318c <vTaskDelay+0x134>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
808030b4:	e5960124 	ldr	r0, [r6, #292]	; 0x124
808030b8:	e5961000 	ldr	r1, [r6]
808030bc:	e2811004 	add	r1, r1, #4
808030c0:	ebfff419 	bl	8080012c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
808030c4:	e596313c 	ldr	r3, [r6, #316]	; 0x13c
808030c8:	e1550003 	cmp	r5, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
808030cc:	3586513c 	strcc	r5, [r6, #316]	; 0x13c

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
			}
			xAlreadyYielded = xTaskResumeAll();
808030d0:	ebfffed1 	bl	80802c1c <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
808030d4:	e3500000 	cmp	r0, #0
808030d8:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808030dc:	e3a03a01 	mov	r3, #4096	; 0x1000
808030e0:	e3443824 	movt	r3, #18468	; 0x4824
808030e4:	e5932200 	ldr	r2, [r3, #512]	; 0x200
808030e8:	e3120001 	tst	r2, #1
808030ec:	18bd81f0 	popne	{r4, r5, r6, r7, r8, pc}
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808030f0:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808030f4:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808030f8:	e2022003 	and	r2, r2, #3
808030fc:	e1a02211 	lsl	r2, r1, r2
80803100:	e3822001 	orr	r2, r2, #1
80803104:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80803108:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
8080310c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803110:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803114:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803118:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080311c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803120:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803124:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803128:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080312c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803130:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803134:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803138:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080313c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803140:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803144:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803148:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080314c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803150:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803154:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803158:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080315c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803160:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803164:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803168:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080316c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803170:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803174:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803178:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080317c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803180:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80803184:	e320f000 	nop	{0}
80803188:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
8080318c:	e5960128 	ldr	r0, [r6, #296]	; 0x128
80803190:	e5961000 	ldr	r1, [r6]
80803194:	e2811004 	add	r1, r1, #4
80803198:	ebfff3e3 	bl	8080012c <vListInsert>
8080319c:	eaffffcb 	b	808030d0 <vTaskDelay+0x78>
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
		{
			configASSERT( uxSchedulerSuspended == 0 );
808031a0:	e3090998 	movw	r0, #39320	; 0x9998
808031a4:	e30014cf 	movw	r1, #1231	; 0x4cf
808031a8:	e3480080 	movt	r0, #32896	; 0x8080
808031ac:	eb000a89 	bl	80805bd8 <vAssertCalled>
808031b0:	eaffffb1 	b	8080307c <vTaskDelay+0x24>

808031b4 <prvListTasksWithinSingleList.part.8>:
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
808031b4:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
808031b8:	e1a07001 	mov	r7, r1
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
808031bc:	e5911004 	ldr	r1, [r1, #4]
808031c0:	e2873008 	add	r3, r7, #8
	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
808031c4:	e30ca000 	movw	sl, #49152	; 0xc000
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
808031c8:	e24dd00c 	sub	sp, sp, #12
808031cc:	e1a09002 	mov	r9, r2
	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
808031d0:	e348a080 	movt	sl, #32896	; 0x8080
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
808031d4:	e5911004 	ldr	r1, [r1, #4]
808031d8:	e2804048 	add	r4, r0, #72	; 0x48
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
808031dc:	e3a08000 	mov	r8, #0
808031e0:	e1a06003 	mov	r6, r3

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
808031e4:	e1510003 	cmp	r1, r3
808031e8:	e5871004 	str	r1, [r7, #4]
808031ec:	05911004 	ldreq	r1, [r1, #4]
808031f0:	e591b00c 	ldr	fp, [r1, #12]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
808031f4:	e5913004 	ldr	r3, [r1, #4]
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
808031f8:	e554203c 	ldrb	r2, [r4, #-60]	; 0xffffffc4
808031fc:	f5d4f000 	pld	[r4]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
80803200:	e1560003 	cmp	r6, r3
80803204:	e5873004 	str	r3, [r7, #4]
80803208:	0597300c 	ldreq	r3, [r7, #12]
8080320c:	f5d4f004 	pld	[r4, #4]
80803210:	e593500c 	ldr	r5, [r3, #12]
80803214:	05873004 	streq	r3, [r7, #4]
	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
80803218:	e3550000 	cmp	r5, #0
8080321c:	059a3000 	ldreq	r3, [sl]
80803220:	11a03005 	movne	r3, r5
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
80803224:	e3520003 	cmp	r2, #3
		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
80803228:	e593002c 	ldr	r0, [r3, #44]	; 0x2c

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
8080322c:	e2831034 	add	r1, r3, #52	; 0x34
80803230:	e5041044 	str	r1, [r4, #-68]	; 0xffffffbc
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
80803234:	e5043048 	str	r3, [r4, #-72]	; 0xffffffb8
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
80803238:	e5040038 	str	r0, [r4, #-56]	; 0xffffffc8
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
8080323c:	e5932030 	ldr	r2, [r3, #48]	; 0x30
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
80803240:	e5931048 	ldr	r1, [r3, #72]	; 0x48
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
80803244:	e504202c 	str	r2, [r4, #-44]	; 0xffffffd4
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
80803248:	e5041040 	str	r1, [r4, #-64]	; 0xffffffc0
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
8080324c:	0a000017 	beq	808032b0 <prvListTasksWithinSingleList.part.8+0xfc>
		}
		#endif /* INCLUDE_vTaskSuspend */

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
80803250:	e5932050 	ldr	r2, [r3, #80]	; 0x50
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
80803254:	e3590005 	cmp	r9, #5
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
80803258:	e3a01000 	mov	r1, #0
		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
		{
			pxTaskStatus->eCurrentState = eState;
8080325c:	1544903c 	strbne	r9, [r4, #-60]	; 0xffffffc4
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
80803260:	e5041030 	str	r1, [r4, #-48]	; 0xffffffd0
		}
		#endif /* INCLUDE_vTaskSuspend */

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
80803264:	e5042034 	str	r2, [r4, #-52]	; 0xffffffcc
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
80803268:	0a00001b 	beq	808032dc <prvListTasksWithinSingleList.part.8+0x128>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
8080326c:	e5933030 	ldr	r3, [r3, #48]	; 0x30

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
80803270:	e5d32000 	ldrb	r2, [r3]
80803274:	e35200a5 	cmp	r2, #165	; 0xa5
80803278:	1a00003d 	bne	80803374 <prvListTasksWithinSingleList.part.8+0x1c0>
8080327c:	e2832001 	add	r2, r3, #1
80803280:	e0630002 	rsb	r0, r3, r2
80803284:	e4d21001 	ldrb	r1, [r2], #1
80803288:	e35100a5 	cmp	r1, #165	; 0xa5
8080328c:	0afffffb 	beq	80803280 <prvListTasksWithinSingleList.part.8+0xcc>
80803290:	e7ef0150 	ubfx	r0, r0, #2, #16
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
				uxTask++;
			} while( pxNextTCB != pxFirstTCB );
80803294:	e15b0005 	cmp	fp, r5
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
80803298:	e14402b8 	strh	r0, [r4, #-40]	; 0xffffffd8
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
				uxTask++;
8080329c:	e2888001 	add	r8, r8, #1
808032a0:	e2844024 	add	r4, r4, #36	; 0x24
			} while( pxNextTCB != pxFirstTCB );
808032a4:	0a000034 	beq	8080337c <prvListTasksWithinSingleList.part.8+0x1c8>
808032a8:	e5971004 	ldr	r1, [r7, #4]
808032ac:	eaffffd0 	b	808031f4 <prvListTasksWithinSingleList.part.8+0x40>
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
808032b0:	e5931028 	ldr	r1, [r3, #40]	; 0x28
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
808032b4:	e59a2134 	ldr	r2, [sl, #308]	; 0x134
808032b8:	e58d3000 	str	r3, [sp]
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
808032bc:	e3510000 	cmp	r1, #0
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
808032c0:	e2822001 	add	r2, r2, #1
808032c4:	e58a2134 	str	r2, [sl, #308]	; 0x134
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
					{
						pxTaskStatus->eCurrentState = eBlocked;
808032c8:	13a02002 	movne	r2, #2
808032cc:	1544203c 	strbne	r2, [r4, #-60]	; 0xffffffc4
					}
				}
				xTaskResumeAll();
808032d0:	ebfffe51 	bl	80802c1c <xTaskResumeAll>
808032d4:	e59d3000 	ldr	r3, [sp]
808032d8:	eaffffdc 	b	80803250 <prvListTasksWithinSingleList.part.8+0x9c>
	{
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );
808032dc:	e3550000 	cmp	r5, #0
808032e0:	0a00003d 	beq	808033dc <prvListTasksWithinSingleList.part.8+0x228>

		if( pxTCB == pxCurrentTCB )
808032e4:	e59a2000 	ldr	r2, [sl]
808032e8:	e1550002 	cmp	r5, r2
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
808032ec:	03a02000 	moveq	r2, #0
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );

		if( pxTCB == pxCurrentTCB )
808032f0:	0a00001a 	beq	80803360 <prvListTasksWithinSingleList.part.8+0x1ac>
808032f4:	e58d3000 	str	r3, [sp]

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
808032f8:	eb00075a 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
808032fc:	e30c3000 	movw	r3, #49152	; 0xc000
80803300:	e3483080 	movt	r3, #32896	; 0x8080
80803304:	e5932004 	ldr	r2, [r3, #4]
80803308:	e59d3000 	ldr	r3, [sp]
8080330c:	e3520000 	cmp	r2, #0
80803310:	1a00001e 	bne	80803390 <prvListTasksWithinSingleList.part.8+0x1dc>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80803314:	e59a1004 	ldr	r1, [sl, #4]
		}
		else
		{
			taskENTER_CRITICAL();
			{
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
80803318:	e5952014 	ldr	r2, [r5, #20]

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
8080331c:	e3510000 	cmp	r1, #0
80803320:	0a000003 	beq	80803334 <prvListTasksWithinSingleList.part.8+0x180>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80803324:	e59a1000 	ldr	r1, [sl]
80803328:	e5911044 	ldr	r1, [r1, #68]	; 0x44
8080332c:	e3510000 	cmp	r1, #0
80803330:	1a00001e 	bne	808033b0 <prvListTasksWithinSingleList.part.8+0x1fc>
			{
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
			}
			taskEXIT_CRITICAL();

			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
80803334:	e59a1124 	ldr	r1, [sl, #292]	; 0x124
80803338:	e1520001 	cmp	r2, r1
8080333c:	0a000011 	beq	80803388 <prvListTasksWithinSingleList.part.8+0x1d4>
80803340:	e59a1128 	ldr	r1, [sl, #296]	; 0x128
80803344:	e1520001 	cmp	r2, r1
80803348:	0a00000e 	beq	80803388 <prvListTasksWithinSingleList.part.8+0x1d4>
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
8080334c:	e30c1110 	movw	r1, #49424	; 0xc110
80803350:	e3481080 	movt	r1, #32896	; 0x8080
80803354:	e1520001 	cmp	r2, r1

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
80803358:	13a02001 	movne	r2, #1
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
8080335c:	0a000019 	beq	808033c8 <prvListTasksWithinSingleList.part.8+0x214>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
80803360:	e5933030 	ldr	r3, [r3, #48]	; 0x30
		{
			pxTaskStatus->eCurrentState = eState;
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
80803364:	e544203c 	strb	r2, [r4, #-60]	; 0xffffffc4

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
80803368:	e5d32000 	ldrb	r2, [r3]
8080336c:	e35200a5 	cmp	r2, #165	; 0xa5
80803370:	0affffc1 	beq	8080327c <prvListTasksWithinSingleList.part.8+0xc8>
80803374:	e3a00000 	mov	r0, #0
80803378:	eaffffc5 	b	80803294 <prvListTasksWithinSingleList.part.8+0xe0>
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return uxTask;
	}
8080337c:	e1a00008 	mov	r0, r8
80803380:	e28dd00c 	add	sp, sp, #12
80803384:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
					{
						eReturn = eSuspended;
					}
					else
					{
						eReturn = eBlocked;
80803388:	e3a02002 	mov	r2, #2
8080338c:	eafffff3 	b	80803360 <prvListTasksWithinSingleList.part.8+0x1ac>
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80803390:	e30c2000 	movw	r2, #49152	; 0xc000
80803394:	e3482080 	movt	r2, #32896	; 0x8080
80803398:	e5921000 	ldr	r1, [r2]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
8080339c:	e5922000 	ldr	r2, [r2]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808033a0:	e5912044 	ldr	r2, [r1, #68]	; 0x44
808033a4:	e2822001 	add	r2, r2, #1
808033a8:	e5812044 	str	r2, [r1, #68]	; 0x44
808033ac:	eaffffd8 	b	80803314 <prvListTasksWithinSingleList.part.8+0x160>
808033b0:	e58d2004 	str	r2, [sp, #4]
808033b4:	e58d3000 	str	r3, [sp]
808033b8:	ebfff945 	bl	808018d4 <vTaskExitCritical.part.7>
808033bc:	e59d2004 	ldr	r2, [sp, #4]
808033c0:	e59d3000 	ldr	r3, [sp]
808033c4:	eaffffda 	b	80803334 <prvListTasksWithinSingleList.part.8+0x180>
				else if( pxStateList == &xSuspendedTaskList )
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it block
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
808033c8:	e5952028 	ldr	r2, [r5, #40]	; 0x28
					{
						eReturn = eSuspended;
808033cc:	e3520000 	cmp	r2, #0
808033d0:	13a02002 	movne	r2, #2
808033d4:	03a02003 	moveq	r2, #3
808033d8:	eaffffe0 	b	80803360 <prvListTasksWithinSingleList.part.8+0x1ac>
	{
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );
808033dc:	e3090998 	movw	r0, #39320	; 0x9998
808033e0:	e30014fb 	movw	r1, #1275	; 0x4fb
808033e4:	e3480080 	movt	r0, #32896	; 0x8080
808033e8:	e58d3000 	str	r3, [sp]
808033ec:	eb0009f9 	bl	80805bd8 <vAssertCalled>
808033f0:	e59d3000 	ldr	r3, [sp]
808033f4:	eaffffba 	b	808032e4 <prvListTasksWithinSingleList.part.8+0x130>

808033f8 <uxTaskGetSystemState>:
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
808033f8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
808033fc:	e30c9000 	movw	r9, #49152	; 0xc000
80803400:	e3489080 	movt	r9, #32896	; 0x8080
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
80803404:	e24dd014 	sub	sp, sp, #20
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80803408:	e5993134 	ldr	r3, [r9, #308]	; 0x134
/*-----------------------------------------------------------*/

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
8080340c:	e58d0008 	str	r0, [sp, #8]
80803410:	e58d200c 	str	r2, [sp, #12]
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80803414:	e2833001 	add	r3, r3, #1
80803418:	e5893134 	str	r3, [r9, #308]	; 0x134
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;

		vTaskSuspendAll();
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
8080341c:	e5993008 	ldr	r3, [r9, #8]
80803420:	e1530001 	cmp	r3, r1

#if ( configUSE_TRACE_FACILITY == 1 )

	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
	{
	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
80803424:	83a04000 	movhi	r4, #0

		vTaskSuspendAll();
		{
			/* Is there a space in the array for each task in the system? */
			if( uxArraySize >= uxCurrentNumberOfTasks )
80803428:	8a000082 	bhi	80803638 <uxTaskGetSystemState+0x240>
8080342c:	e3a0b000 	mov	fp, #0
80803430:	e28950c8 	add	r5, r9, #200	; 0xc8
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
					{
						pxTaskStatus->eCurrentState = eBlocked;
80803434:	e1a01009 	mov	r1, r9
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
80803438:	e1a0a00b 	mov	sl, fp
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
					{
						pxTaskStatus->eCurrentState = eBlocked;
8080343c:	e1a0900b 	mov	r9, fp
80803440:	ea000005 	b	8080345c <uxTaskGetSystemState+0x64>
				do
				{
					uxQueue--;
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80803444:	e30c3000 	movw	r3, #49152	; 0xc000
80803448:	e2455014 	sub	r5, r5, #20
8080344c:	e3483080 	movt	r3, #32896	; 0x8080
				/* Fill in an TaskStatus_t structure with information on each
				task in the Ready state. */
				do
				{
					uxQueue--;
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
80803450:	e0899007 	add	r9, r9, r7

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80803454:	e1550003 	cmp	r5, r3
80803458:	0a00004c 	beq	80803590 <uxTaskGetSystemState+0x198>
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
8080345c:	e5157008 	ldr	r7, [r5, #-8]
80803460:	e3570000 	cmp	r7, #0
80803464:	0afffff6 	beq	80803444 <uxTaskGetSystemState+0x4c>
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
80803468:	e5153004 	ldr	r3, [r5, #-4]
8080346c:	e1a04289 	lsl	r4, r9, #5
80803470:	e59d2008 	ldr	r2, [sp, #8]
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
80803474:	e3a07000 	mov	r7, #0
80803478:	e0844109 	add	r4, r4, r9, lsl #2
8080347c:	e58d9004 	str	r9, [sp, #4]

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
80803480:	e5933004 	ldr	r3, [r3, #4]
		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
		{
			pxTaskStatus->eCurrentState = eState;
80803484:	e3a08001 	mov	r8, #1
80803488:	e0824004 	add	r4, r2, r4
8080348c:	e1a09001 	mov	r9, r1
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
		{
			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
80803490:	e1530005 	cmp	r3, r5
80803494:	e5053004 	str	r3, [r5, #-4]
80803498:	05950004 	ldreq	r0, [r5, #4]
8080349c:	01a03000 	moveq	r3, r0
808034a0:	05050004 	streq	r0, [r5, #-4]
808034a4:	e593b00c 	ldr	fp, [r3, #12]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
808034a8:	e5933004 	ldr	r3, [r3, #4]
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
808034ac:	e5d4200c 	ldrb	r2, [r4, #12]
			pxTaskStatusArray array for each task that is referenced from
			pxList.  See the definition of TaskStatus_t in task.h for the
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
808034b0:	e1530005 	cmp	r3, r5
808034b4:	e5053004 	str	r3, [r5, #-4]
808034b8:	05953004 	ldreq	r3, [r5, #4]
808034bc:	e593600c 	ldr	r6, [r3, #12]
808034c0:	05053004 	streq	r3, [r5, #-4]
	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
808034c4:	e3560000 	cmp	r6, #0
808034c8:	05993000 	ldreq	r3, [r9]
808034cc:	11a03006 	movne	r3, r6
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
808034d0:	e3520003 	cmp	r2, #3
		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
808034d4:	e593c02c 	ldr	ip, [r3, #44]	; 0x2c

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
808034d8:	e2830034 	add	r0, r3, #52	; 0x34
808034dc:	e5840004 	str	r0, [r4, #4]
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
808034e0:	e5843000 	str	r3, [r4]
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
808034e4:	e584c010 	str	ip, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
808034e8:	e5932030 	ldr	r2, [r3, #48]	; 0x30
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
808034ec:	e5930048 	ldr	r0, [r3, #72]	; 0x48
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
808034f0:	e584201c 	str	r2, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
808034f4:	e5840008 	str	r0, [r4, #8]
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
808034f8:	0a000014 	beq	80803550 <uxTaskGetSystemState+0x158>
		}
		#endif /* INCLUDE_vTaskSuspend */

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
808034fc:	e5932050 	ldr	r2, [r3, #80]	; 0x50
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
80803500:	e5930030 	ldr	r0, [r3, #48]	; 0x30
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
80803504:	e584a018 	str	sl, [r4, #24]
		}
		#endif /* INCLUDE_vTaskSuspend */

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
80803508:	e5842014 	str	r2, [r4, #20]
		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
		{
			pxTaskStatus->eCurrentState = eState;
8080350c:	e5c4800c 	strb	r8, [r4, #12]

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
80803510:	e5d03000 	ldrb	r3, [r0]
80803514:	e35300a5 	cmp	r3, #165	; 0xa5
80803518:	1a000017 	bne	8080357c <uxTaskGetSystemState+0x184>
8080351c:	e2803001 	add	r3, r0, #1
80803520:	e060c003 	rsb	ip, r0, r3
80803524:	e4d32001 	ldrb	r2, [r3], #1
80803528:	e35200a5 	cmp	r2, #165	; 0xa5
8080352c:	0afffffb 	beq	80803520 <uxTaskGetSystemState+0x128>
80803530:	e7efc15c 	ubfx	ip, ip, #2, #16
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
				uxTask++;
			} while( pxNextTCB != pxFirstTCB );
80803534:	e15b0006 	cmp	fp, r6
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
80803538:	e1c4c2b0 	strh	ip, [r4, #32]
			meaning of each TaskStatus_t structure member. */
			do
			{
				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
				vTaskGetInfo( ( TaskHandle_t ) pxNextTCB, &( pxTaskStatusArray[ uxTask ] ), pdTRUE, eState );
				uxTask++;
8080353c:	e2877001 	add	r7, r7, #1
80803540:	e2844024 	add	r4, r4, #36	; 0x24
			} while( pxNextTCB != pxFirstTCB );
80803544:	0a00000e 	beq	80803584 <uxTaskGetSystemState+0x18c>
80803548:	e5153004 	ldr	r3, [r5, #-4]
8080354c:	eaffffd5 	b	808034a8 <uxTaskGetSystemState+0xb0>
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80803550:	e5930028 	ldr	r0, [r3, #40]	; 0x28
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80803554:	e5992134 	ldr	r2, [r9, #308]	; 0x134
80803558:	e58d3000 	str	r3, [sp]
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
8080355c:	e3500000 	cmp	r0, #0
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80803560:	e2822001 	add	r2, r2, #1
80803564:	e5892134 	str	r2, [r9, #308]	; 0x134
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
					{
						pxTaskStatus->eCurrentState = eBlocked;
80803568:	13a02002 	movne	r2, #2
8080356c:	15c4200c 	strbne	r2, [r4, #12]
					}
				}
				xTaskResumeAll();
80803570:	ebfffda9 	bl	80802c1c <xTaskResumeAll>
80803574:	e59d3000 	ldr	r3, [sp]
80803578:	eaffffdf 	b	808034fc <uxTaskGetSystemState+0x104>

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
8080357c:	e3a0c000 	mov	ip, #0
80803580:	eaffffeb 	b	80803534 <uxTaskGetSystemState+0x13c>
80803584:	e1a01009 	mov	r1, r9
80803588:	e59d9004 	ldr	r9, [sp, #4]
8080358c:	eaffffac 	b	80803444 <uxTaskGetSystemState+0x4c>
80803590:	e1a0b009 	mov	fp, r9
80803594:	e1a09001 	mov	r9, r1

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
80803598:	e5911124 	ldr	r1, [r1, #292]	; 0x124
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
8080359c:	e5910000 	ldr	r0, [r1]
808035a0:	e3500000 	cmp	r0, #0
808035a4:	0a000005 	beq	808035c0 <uxTaskGetSystemState+0x1c8>
808035a8:	e1a0028b 	lsl	r0, fp, #5
808035ac:	e59d3008 	ldr	r3, [sp, #8]
808035b0:	e3a02002 	mov	r2, #2
808035b4:	e080010b 	add	r0, r0, fp, lsl #2
808035b8:	e0830000 	add	r0, r3, r0
808035bc:	ebfffefc 	bl	808031b4 <prvListTasksWithinSingleList.part.8>
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
808035c0:	e5991128 	ldr	r1, [r9, #296]	; 0x128

				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
808035c4:	e08bb000 	add	fp, fp, r0
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
808035c8:	e5910000 	ldr	r0, [r1]
808035cc:	e3500000 	cmp	r0, #0
808035d0:	0a000005 	beq	808035ec <uxTaskGetSystemState+0x1f4>
808035d4:	e1a0028b 	lsl	r0, fp, #5
808035d8:	e59d3008 	ldr	r3, [sp, #8]
808035dc:	e3a02002 	mov	r2, #2
808035e0:	e080010b 	add	r0, r0, fp, lsl #2
808035e4:	e0830000 	add	r0, r3, r0
808035e8:	ebfffef1 	bl	808031b4 <prvListTasksWithinSingleList.part.8>
808035ec:	e5993110 	ldr	r3, [r9, #272]	; 0x110
				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

				/* Fill in an TaskStatus_t structure with information on each
				task in the Blocked state. */
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
				uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
808035f0:	e08b5000 	add	r5, fp, r0
	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
808035f4:	e3530000 	cmp	r3, #0
#if ( configUSE_TRACE_FACILITY == 1 )

	static UBaseType_t prvListTasksWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
	{
	volatile TCB_t *pxNextTCB, *pxFirstTCB;
	UBaseType_t uxTask = 0;
808035f8:	01a00003 	moveq	r0, r3

		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
808035fc:	0a000007 	beq	80803620 <uxTaskGetSystemState+0x228>
80803600:	e1a00285 	lsl	r0, r5, #5
80803604:	e59d3008 	ldr	r3, [sp, #8]
80803608:	e30c1110 	movw	r1, #49424	; 0xc110
8080360c:	e0800105 	add	r0, r0, r5, lsl #2
80803610:	e3a02003 	mov	r2, #3
80803614:	e3481080 	movt	r1, #32896	; 0x8080
80803618:	e0830000 	add	r0, r3, r0
8080361c:	ebfffee4 	bl	808031b4 <prvListTasksWithinSingleList.part.8>
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
80803620:	e59d200c 	ldr	r2, [sp, #12]

				#if ( INCLUDE_vTaskSuspend == 1 )
				{
					/* Fill in an TaskStatus_t structure with information on
					each task in the Suspended state. */
					uxTask += prvListTasksWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
80803624:	e0854000 	add	r4, r5, r0
						#endif
					}
				}
				#else
				{
					if( pulTotalRunTime != NULL )
80803628:	e3520000 	cmp	r2, #0
8080362c:	e1a03002 	mov	r3, r2
					{
						*pulTotalRunTime = 0;
80803630:	13a03000 	movne	r3, #0
80803634:	15823000 	strne	r3, [r2]
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		( void ) xTaskResumeAll();
80803638:	ebfffd77 	bl	80802c1c <xTaskResumeAll>

		return uxTask;
	}
8080363c:	e1a00004 	mov	r0, r4
80803640:	e28dd014 	add	sp, sp, #20
80803644:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

80803648 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80803648:	e92d4070 	push	{r4, r5, r6, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
8080364c:	e30c4000 	movw	r4, #49152	; 0xc000
80803650:	e3484080 	movt	r4, #32896	; 0x8080
80803654:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80803658:	e3530000 	cmp	r3, #0
8080365c:	1a000078 	bne	80803844 <vTaskSwitchContext+0x1fc>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
80803660:	e5843138 	str	r3, [r4, #312]	; 0x138
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
80803664:	e5945130 	ldr	r5, [r4, #304]	; 0x130
80803668:	e1a03105 	lsl	r3, r5, #2
8080366c:	e1a02205 	lsl	r2, r5, #4
80803670:	e0831002 	add	r1, r3, r2
80803674:	e0841001 	add	r1, r4, r1
80803678:	e591100c 	ldr	r1, [r1, #12]
8080367c:	e3510000 	cmp	r1, #0
80803680:	1a00005e 	bne	80803800 <vTaskSwitchContext+0x1b8>
80803684:	e3550000 	cmp	r5, #0
80803688:	0a000075 	beq	80803864 <vTaskSwitchContext+0x21c>
8080368c:	e2451001 	sub	r1, r5, #1
80803690:	e1a03101 	lsl	r3, r1, #2
80803694:	e1a02201 	lsl	r2, r1, #4
80803698:	e0830002 	add	r0, r3, r2
8080369c:	e0840000 	add	r0, r4, r0
808036a0:	e590000c 	ldr	r0, [r0, #12]
808036a4:	e3500000 	cmp	r0, #0
808036a8:	1a000063 	bne	8080383c <vTaskSwitchContext+0x1f4>
808036ac:	e3510000 	cmp	r1, #0
808036b0:	0a000070 	beq	80803878 <vTaskSwitchContext+0x230>
808036b4:	e2451002 	sub	r1, r5, #2
808036b8:	e1a03101 	lsl	r3, r1, #2
808036bc:	e1a02201 	lsl	r2, r1, #4
808036c0:	e0830002 	add	r0, r3, r2
808036c4:	e0840000 	add	r0, r4, r0
808036c8:	e590000c 	ldr	r0, [r0, #12]
808036cc:	e3500000 	cmp	r0, #0
808036d0:	1a000059 	bne	8080383c <vTaskSwitchContext+0x1f4>
808036d4:	e3510000 	cmp	r1, #0
808036d8:	0a00006b 	beq	8080388c <vTaskSwitchContext+0x244>
808036dc:	e2451003 	sub	r1, r5, #3
808036e0:	e1a03101 	lsl	r3, r1, #2
808036e4:	e1a02201 	lsl	r2, r1, #4
808036e8:	e0830002 	add	r0, r3, r2
808036ec:	e0840000 	add	r0, r4, r0
808036f0:	e590000c 	ldr	r0, [r0, #12]
808036f4:	e3500000 	cmp	r0, #0
808036f8:	1a00004f 	bne	8080383c <vTaskSwitchContext+0x1f4>
808036fc:	e3510000 	cmp	r1, #0
80803700:	0a000066 	beq	808038a0 <vTaskSwitchContext+0x258>
80803704:	e2451004 	sub	r1, r5, #4
80803708:	e1a03101 	lsl	r3, r1, #2
8080370c:	e1a02201 	lsl	r2, r1, #4
80803710:	e0830002 	add	r0, r3, r2
80803714:	e0840000 	add	r0, r4, r0
80803718:	e590000c 	ldr	r0, [r0, #12]
8080371c:	e3500000 	cmp	r0, #0
80803720:	1a000045 	bne	8080383c <vTaskSwitchContext+0x1f4>
80803724:	e3510000 	cmp	r1, #0
80803728:	0a000061 	beq	808038b4 <vTaskSwitchContext+0x26c>
8080372c:	e2451005 	sub	r1, r5, #5
80803730:	e1a03101 	lsl	r3, r1, #2
80803734:	e1a02201 	lsl	r2, r1, #4
80803738:	e0830002 	add	r0, r3, r2
8080373c:	e0840000 	add	r0, r4, r0
80803740:	e590000c 	ldr	r0, [r0, #12]
80803744:	e3500000 	cmp	r0, #0
80803748:	1a00003b 	bne	8080383c <vTaskSwitchContext+0x1f4>
8080374c:	e3510000 	cmp	r1, #0
80803750:	0a00005c 	beq	808038c8 <vTaskSwitchContext+0x280>
80803754:	e2451006 	sub	r1, r5, #6
80803758:	e1a03101 	lsl	r3, r1, #2
8080375c:	e1a02201 	lsl	r2, r1, #4
80803760:	e0830002 	add	r0, r3, r2
80803764:	e0840000 	add	r0, r4, r0
80803768:	e590000c 	ldr	r0, [r0, #12]
8080376c:	e3500000 	cmp	r0, #0
80803770:	1a000031 	bne	8080383c <vTaskSwitchContext+0x1f4>
80803774:	e3510000 	cmp	r1, #0
80803778:	0a000057 	beq	808038dc <vTaskSwitchContext+0x294>
8080377c:	e2451007 	sub	r1, r5, #7
80803780:	e1a03101 	lsl	r3, r1, #2
80803784:	e1a02201 	lsl	r2, r1, #4
80803788:	e0830002 	add	r0, r3, r2
8080378c:	e0840000 	add	r0, r4, r0
80803790:	e590000c 	ldr	r0, [r0, #12]
80803794:	e3500000 	cmp	r0, #0
80803798:	1a000027 	bne	8080383c <vTaskSwitchContext+0x1f4>
8080379c:	e3510000 	cmp	r1, #0
808037a0:	0a000052 	beq	808038f0 <vTaskSwitchContext+0x2a8>
808037a4:	e2451008 	sub	r1, r5, #8
808037a8:	e1a03101 	lsl	r3, r1, #2
808037ac:	e1a02201 	lsl	r2, r1, #4
808037b0:	e0830002 	add	r0, r3, r2
808037b4:	e0840000 	add	r0, r4, r0
808037b8:	e590000c 	ldr	r0, [r0, #12]
808037bc:	e3500000 	cmp	r0, #0
808037c0:	1a00001d 	bne	8080383c <vTaskSwitchContext+0x1f4>
808037c4:	e3510000 	cmp	r1, #0
808037c8:	0a00004d 	beq	80803904 <vTaskSwitchContext+0x2bc>
808037cc:	e2451009 	sub	r1, r5, #9
808037d0:	e1a03101 	lsl	r3, r1, #2
808037d4:	e1a02201 	lsl	r2, r1, #4
808037d8:	e0830002 	add	r0, r3, r2
808037dc:	e0840000 	add	r0, r4, r0
808037e0:	e590000c 	ldr	r0, [r0, #12]
808037e4:	e3500000 	cmp	r0, #0
808037e8:	1a000013 	bne	8080383c <vTaskSwitchContext+0x1f4>
808037ec:	e3510000 	cmp	r1, #0
808037f0:	0a000016 	beq	80803850 <vTaskSwitchContext+0x208>
808037f4:	e245500a 	sub	r5, r5, #10
808037f8:	e1a03105 	lsl	r3, r5, #2
808037fc:	e1a02205 	lsl	r2, r5, #4
80803800:	e0833002 	add	r3, r3, r2
80803804:	e30c2014 	movw	r2, #49172	; 0xc014
80803808:	e0841003 	add	r1, r4, r3
8080380c:	e3482080 	movt	r2, #32896	; 0x8080
80803810:	e5910010 	ldr	r0, [r1, #16]
80803814:	e0833002 	add	r3, r3, r2
80803818:	e5902004 	ldr	r2, [r0, #4]
8080381c:	e1520003 	cmp	r2, r3
80803820:	e5812010 	str	r2, [r1, #16]
80803824:	05922004 	ldreq	r2, [r2, #4]
80803828:	e592300c 	ldr	r3, [r2, #12]
8080382c:	05812010 	streq	r2, [r1, #16]
80803830:	e5843000 	str	r3, [r4]
80803834:	e5845130 	str	r5, [r4, #304]	; 0x130
80803838:	e8bd8070 	pop	{r4, r5, r6, pc}
8080383c:	e1a05001 	mov	r5, r1
80803840:	eaffffee 	b	80803800 <vTaskSwitchContext+0x1b8>
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
80803844:	e3a03001 	mov	r3, #1
80803848:	e5843138 	str	r3, [r4, #312]	; 0x138
8080384c:	e8bd8070 	pop	{r4, r5, r6, pc}
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
80803850:	e3090998 	movw	r0, #39320	; 0x9998
80803854:	e3001af6 	movw	r1, #2806	; 0xaf6
80803858:	e3480080 	movt	r0, #32896	; 0x8080
8080385c:	eb0008dd 	bl	80805bd8 <vAssertCalled>
80803860:	eaffffe3 	b	808037f4 <vTaskSwitchContext+0x1ac>
80803864:	e3090998 	movw	r0, #39320	; 0x9998
80803868:	e3001af6 	movw	r1, #2806	; 0xaf6
8080386c:	e3480080 	movt	r0, #32896	; 0x8080
80803870:	eb0008d8 	bl	80805bd8 <vAssertCalled>
80803874:	eaffff84 	b	8080368c <vTaskSwitchContext+0x44>
80803878:	e3090998 	movw	r0, #39320	; 0x9998
8080387c:	e3001af6 	movw	r1, #2806	; 0xaf6
80803880:	e3480080 	movt	r0, #32896	; 0x8080
80803884:	eb0008d3 	bl	80805bd8 <vAssertCalled>
80803888:	eaffff89 	b	808036b4 <vTaskSwitchContext+0x6c>
8080388c:	e3090998 	movw	r0, #39320	; 0x9998
80803890:	e3001af6 	movw	r1, #2806	; 0xaf6
80803894:	e3480080 	movt	r0, #32896	; 0x8080
80803898:	eb0008ce 	bl	80805bd8 <vAssertCalled>
8080389c:	eaffff8e 	b	808036dc <vTaskSwitchContext+0x94>
808038a0:	e3090998 	movw	r0, #39320	; 0x9998
808038a4:	e3001af6 	movw	r1, #2806	; 0xaf6
808038a8:	e3480080 	movt	r0, #32896	; 0x8080
808038ac:	eb0008c9 	bl	80805bd8 <vAssertCalled>
808038b0:	eaffff93 	b	80803704 <vTaskSwitchContext+0xbc>
808038b4:	e3090998 	movw	r0, #39320	; 0x9998
808038b8:	e3001af6 	movw	r1, #2806	; 0xaf6
808038bc:	e3480080 	movt	r0, #32896	; 0x8080
808038c0:	eb0008c4 	bl	80805bd8 <vAssertCalled>
808038c4:	eaffff98 	b	8080372c <vTaskSwitchContext+0xe4>
808038c8:	e3090998 	movw	r0, #39320	; 0x9998
808038cc:	e3001af6 	movw	r1, #2806	; 0xaf6
808038d0:	e3480080 	movt	r0, #32896	; 0x8080
808038d4:	eb0008bf 	bl	80805bd8 <vAssertCalled>
808038d8:	eaffff9d 	b	80803754 <vTaskSwitchContext+0x10c>
808038dc:	e3090998 	movw	r0, #39320	; 0x9998
808038e0:	e3001af6 	movw	r1, #2806	; 0xaf6
808038e4:	e3480080 	movt	r0, #32896	; 0x8080
808038e8:	eb0008ba 	bl	80805bd8 <vAssertCalled>
808038ec:	eaffffa2 	b	8080377c <vTaskSwitchContext+0x134>
808038f0:	e3090998 	movw	r0, #39320	; 0x9998
808038f4:	e3001af6 	movw	r1, #2806	; 0xaf6
808038f8:	e3480080 	movt	r0, #32896	; 0x8080
808038fc:	eb0008b5 	bl	80805bd8 <vAssertCalled>
80803900:	eaffffa7 	b	808037a4 <vTaskSwitchContext+0x15c>
80803904:	e3090998 	movw	r0, #39320	; 0x9998
80803908:	e3001af6 	movw	r1, #2806	; 0xaf6
8080390c:	e3480080 	movt	r0, #32896	; 0x8080
80803910:	eb0008b0 	bl	80805bd8 <vAssertCalled>
80803914:	eaffffac 	b	808037cc <vTaskSwitchContext+0x184>

80803918 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
80803918:	e92d4070 	push	{r4, r5, r6, lr}
	configASSERT( pxEventList );
8080391c:	e2506000 	subs	r6, r0, #0
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
80803920:	e1a05001 	mov	r5, r1
	configASSERT( pxEventList );
80803924:	0a000022 	beq	808039b4 <vTaskPlaceOnEventList+0x9c>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80803928:	e30c4000 	movw	r4, #49152	; 0xc000
8080392c:	e1a00006 	mov	r0, r6
80803930:	e3484080 	movt	r4, #32896	; 0x8080
80803934:	e5941000 	ldr	r1, [r4]
80803938:	e2811018 	add	r1, r1, #24
8080393c:	ebfff1fa 	bl	8080012c <vListInsert>


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
80803940:	e5946144 	ldr	r6, [r4, #324]	; 0x144
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80803944:	e5940000 	ldr	r0, [r4]
80803948:	e2800004 	add	r0, r0, #4
8080394c:	ebfff20d 	bl	80800188 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80803950:	e3750001 	cmn	r5, #1
80803954:	0a000011 	beq	808039a0 <vTaskPlaceOnEventList+0x88>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
80803958:	e0855006 	add	r5, r5, r6

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
8080395c:	e5943000 	ldr	r3, [r4]

			if( xTimeToWake < xConstTickCount )
80803960:	e1560005 	cmp	r6, r5
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80803964:	e5835004 	str	r5, [r3, #4]

			if( xTimeToWake < xConstTickCount )
80803968:	8a000007 	bhi	8080398c <vTaskPlaceOnEventList+0x74>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
8080396c:	e5940124 	ldr	r0, [r4, #292]	; 0x124
80803970:	e5941000 	ldr	r1, [r4]
80803974:	e2811004 	add	r1, r1, #4
80803978:	ebfff1eb 	bl	8080012c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
8080397c:	e594313c 	ldr	r3, [r4, #316]	; 0x13c
80803980:	e1550003 	cmp	r5, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
80803984:	3584513c 	strcc	r5, [r4, #316]	; 0x13c
80803988:	e8bd8070 	pop	{r4, r5, r6, pc}

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
8080398c:	e5940128 	ldr	r0, [r4, #296]	; 0x128
80803990:	e5941000 	ldr	r1, [r4]
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
80803994:	e8bd4070 	pop	{r4, r5, r6, lr}

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80803998:	e2811004 	add	r1, r1, #4
8080399c:	eafff1e2 	b	8080012c <vListInsert>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
808039a0:	e1a00004 	mov	r0, r4
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
808039a4:	e8bd4070 	pop	{r4, r5, r6, lr}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
808039a8:	e4901110 	ldr	r1, [r0], #272	; 0x110
808039ac:	e2811004 	add	r1, r1, #4
808039b0:	eafff1d3 	b	80800104 <vListInsertEnd>
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
	configASSERT( pxEventList );
808039b4:	e3090998 	movw	r0, #39320	; 0x9998
808039b8:	e3001b06 	movw	r1, #2822	; 0xb06
808039bc:	e3480080 	movt	r0, #32896	; 0x8080
808039c0:	eb000884 	bl	80805bd8 <vAssertCalled>
808039c4:	eaffffd7 	b	80803928 <vTaskPlaceOnEventList+0x10>

808039c8 <vTaskPlaceOnUnorderedEventList>:
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
808039c8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	configASSERT( pxEventList );
808039cc:	e2507000 	subs	r7, r0, #0
	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
808039d0:	e1a05001 	mov	r5, r1
808039d4:	e1a06002 	mov	r6, r2
	configASSERT( pxEventList );
808039d8:	0a00002e 	beq	80803a98 <vTaskPlaceOnUnorderedEventList+0xd0>

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event groups implementation. */
	configASSERT( uxSchedulerSuspended != 0 );
808039dc:	e30c4000 	movw	r4, #49152	; 0xc000
808039e0:	e3484080 	movt	r4, #32896	; 0x8080
808039e4:	e5943134 	ldr	r3, [r4, #308]	; 0x134
808039e8:	e3530000 	cmp	r3, #0
808039ec:	1a000003 	bne	80803a00 <vTaskPlaceOnUnorderedEventList+0x38>
808039f0:	e3090998 	movw	r0, #39320	; 0x9998
808039f4:	e3001b1b 	movw	r1, #2843	; 0xb1b
808039f8:	e3480080 	movt	r0, #32896	; 0x8080
808039fc:	eb000875 	bl	80805bd8 <vAssertCalled>

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
80803a00:	e5942000 	ldr	r2, [r4]
80803a04:	e3853102 	orr	r3, r5, #-2147483648	; 0x80000000
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80803a08:	e5941000 	ldr	r1, [r4]
80803a0c:	e1a00007 	mov	r0, r7
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
80803a10:	e30c5000 	movw	r5, #49152	; 0xc000
80803a14:	e5823018 	str	r3, [r2, #24]
80803a18:	e3485080 	movt	r5, #32896	; 0x8080
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80803a1c:	e2811018 	add	r1, r1, #24
80803a20:	ebfff1b7 	bl	80800104 <vListInsertEnd>


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
80803a24:	e5947144 	ldr	r7, [r4, #324]	; 0x144
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80803a28:	e5940000 	ldr	r0, [r4]
80803a2c:	e2800004 	add	r0, r0, #4
80803a30:	ebfff1d4 	bl	80800188 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80803a34:	e3760001 	cmn	r6, #1
80803a38:	0a000011 	beq	80803a84 <vTaskPlaceOnUnorderedEventList+0xbc>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
80803a3c:	e0864007 	add	r4, r6, r7

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80803a40:	e5953000 	ldr	r3, [r5]

			if( xTimeToWake < xConstTickCount )
80803a44:	e1570004 	cmp	r7, r4
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80803a48:	e5834004 	str	r4, [r3, #4]

			if( xTimeToWake < xConstTickCount )
80803a4c:	8a000007 	bhi	80803a70 <vTaskPlaceOnUnorderedEventList+0xa8>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80803a50:	e5950124 	ldr	r0, [r5, #292]	; 0x124
80803a54:	e5951000 	ldr	r1, [r5]
80803a58:	e2811004 	add	r1, r1, #4
80803a5c:	ebfff1b2 	bl	8080012c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
80803a60:	e595313c 	ldr	r3, [r5, #316]	; 0x13c
80803a64:	e1540003 	cmp	r4, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
80803a68:	3585413c 	strcc	r4, [r5, #316]	; 0x13c
80803a6c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80803a70:	e5950128 	ldr	r0, [r5, #296]	; 0x128
80803a74:	e5951000 	ldr	r1, [r5]
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
80803a78:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80803a7c:	e2811004 	add	r1, r1, #4
80803a80:	eafff1a9 	b	8080012c <vListInsert>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80803a84:	e1a00005 	mov	r0, r5
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
}
80803a88:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80803a8c:	e4901110 	ldr	r1, [r0], #272	; 0x110
80803a90:	e2811004 	add	r1, r1, #4
80803a94:	eafff19a 	b	80800104 <vListInsertEnd>
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
	configASSERT( pxEventList );
80803a98:	e3090998 	movw	r0, #39320	; 0x9998
80803a9c:	e3001b17 	movw	r1, #2839	; 0xb17
80803aa0:	e3480080 	movt	r0, #32896	; 0x8080
80803aa4:	eb00084b 	bl	80805bd8 <vAssertCalled>
80803aa8:	eaffffcb 	b	808039dc <vTaskPlaceOnUnorderedEventList+0x14>

80803aac <xTaskRemoveFromEventList>:
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80803aac:	e590300c 	ldr	r3, [r0, #12]

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
80803ab0:	e92d4070 	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80803ab4:	e593500c 	ldr	r5, [r3, #12]
	configASSERT( pxUnblockedTCB );
80803ab8:	e3550000 	cmp	r5, #0
80803abc:	0a000023 	beq	80803b50 <xTaskRemoveFromEventList+0xa4>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
80803ac0:	e2856018 	add	r6, r5, #24

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80803ac4:	e30c4000 	movw	r4, #49152	; 0xc000

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
80803ac8:	e1a00006 	mov	r0, r6

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80803acc:	e3484080 	movt	r4, #32896	; 0x8080

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
80803ad0:	ebfff1ac 	bl	80800188 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80803ad4:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80803ad8:	e3530000 	cmp	r3, #0
80803adc:	1a000017 	bne	80803b40 <xTaskRemoveFromEventList+0x94>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80803ae0:	e2856004 	add	r6, r5, #4
80803ae4:	e1a00006 	mov	r0, r6
80803ae8:	ebfff1a6 	bl	80800188 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
80803aec:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
80803af0:	e30c000c 	movw	r0, #49164	; 0xc00c
80803af4:	e5942130 	ldr	r2, [r4, #304]	; 0x130
80803af8:	e3480080 	movt	r0, #32896	; 0x8080
80803afc:	e1a01006 	mov	r1, r6
80803b00:	e1530002 	cmp	r3, r2
80803b04:	e1a02203 	lsl	r2, r3, #4
80803b08:	85843130 	strhi	r3, [r4, #304]	; 0x130
80803b0c:	e0823103 	add	r3, r2, r3, lsl #2
80803b10:	e0800003 	add	r0, r0, r3
80803b14:	ebfff17a 	bl	80800104 <vListInsertEnd>
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80803b18:	e5942000 	ldr	r2, [r4]
80803b1c:	e30c3000 	movw	r3, #49152	; 0xc000
80803b20:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
80803b24:	e3483080 	movt	r3, #32896	; 0x8080
80803b28:	e592202c 	ldr	r2, [r2, #44]	; 0x2c
80803b2c:	e1510002 	cmp	r1, r2
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
80803b30:	83a00001 	movhi	r0, #1
	}
	else
	{
		xReturn = pdFALSE;
80803b34:	93a00000 	movls	r0, #0
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
80803b38:	85830138 	strhi	r0, [r3, #312]	; 0x138
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
80803b3c:	e8bd8070 	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
80803b40:	e1a01006 	mov	r1, r6
80803b44:	e28400fc 	add	r0, r4, #252	; 0xfc
80803b48:	ebfff16d 	bl	80800104 <vListInsertEnd>
80803b4c:	eafffff1 	b	80803b18 <xTaskRemoveFromEventList+0x6c>
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
	configASSERT( pxUnblockedTCB );
80803b50:	e3090998 	movw	r0, #39320	; 0x9998
80803b54:	e3001b61 	movw	r1, #2913	; 0xb61
80803b58:	e3480080 	movt	r0, #32896	; 0x8080
80803b5c:	eb00081d 	bl	80805bd8 <vAssertCalled>
80803b60:	eaffffd6 	b	80803ac0 <xTaskRemoveFromEventList+0x14>

80803b64 <xTaskRemoveFromUnorderedEventList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
80803b64:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
80803b68:	e30c4000 	movw	r4, #49152	; 0xc000
80803b6c:	e3484080 	movt	r4, #32896	; 0x8080
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
80803b70:	e1a06000 	mov	r6, r0
80803b74:	e1a07001 	mov	r7, r1
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
80803b78:	e5943134 	ldr	r3, [r4, #308]	; 0x134
80803b7c:	e3530000 	cmp	r3, #0
80803b80:	0a00001f 	beq	80803c04 <xTaskRemoveFromUnorderedEventList+0xa0>
	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
80803b84:	e596500c 	ldr	r5, [r6, #12]
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
80803b88:	e3877102 	orr	r7, r7, #-2147483648	; 0x80000000
80803b8c:	e5867000 	str	r7, [r6]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
	configASSERT( pxUnblockedTCB );
80803b90:	e3550000 	cmp	r5, #0
80803b94:	0a00001f 	beq	80803c18 <xTaskRemoveFromUnorderedEventList+0xb4>
	( void ) uxListRemove( pxEventListItem );

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80803b98:	e2857004 	add	r7, r5, #4

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
80803b9c:	e1a00006 	mov	r0, r6
80803ba0:	ebfff178 	bl	80800188 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80803ba4:	e1a00007 	mov	r0, r7
	prvAddTaskToReadyList( pxUnblockedTCB );
80803ba8:	e30c6000 	movw	r6, #49152	; 0xc000
	( void ) uxListRemove( pxEventListItem );

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80803bac:	ebfff175 	bl	80800188 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
80803bb0:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
80803bb4:	e30c2000 	movw	r2, #49152	; 0xc000
80803bb8:	e5941130 	ldr	r1, [r4, #304]	; 0x130
80803bbc:	e3482080 	movt	r2, #32896	; 0x8080
80803bc0:	e3486080 	movt	r6, #32896	; 0x8080
80803bc4:	e1a00203 	lsl	r0, r3, #4
80803bc8:	e1530001 	cmp	r3, r1
80803bcc:	85823130 	strhi	r3, [r2, #304]	; 0x130
80803bd0:	e1a01007 	mov	r1, r7
80803bd4:	e0803103 	add	r3, r0, r3, lsl #2
80803bd8:	e286000c 	add	r0, r6, #12
80803bdc:	e0800003 	add	r0, r0, r3
80803be0:	ebfff147 	bl	80800104 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80803be4:	e5943000 	ldr	r3, [r4]
80803be8:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
80803bec:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
80803bf0:	e1520003 	cmp	r2, r3
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
80803bf4:	83a00001 	movhi	r0, #1
	}
	else
	{
		xReturn = pdFALSE;
80803bf8:	93a00000 	movls	r0, #0
		switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
80803bfc:	85860138 	strhi	r0, [r6, #312]	; 0x138
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
80803c00:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
TCB_t *pxUnblockedTCB;
BaseType_t xReturn;

	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );
80803c04:	e3090998 	movw	r0, #39320	; 0x9998
80803c08:	e3001b99 	movw	r1, #2969	; 0xb99
80803c0c:	e3480080 	movt	r0, #32896	; 0x8080
80803c10:	eb0007f0 	bl	80805bd8 <vAssertCalled>
80803c14:	eaffffda 	b	80803b84 <xTaskRemoveFromUnorderedEventList+0x20>
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
	configASSERT( pxUnblockedTCB );
80803c18:	e3090998 	movw	r0, #39320	; 0x9998
80803c1c:	e3001ba1 	movw	r1, #2977	; 0xba1
80803c20:	e3480080 	movt	r0, #32896	; 0x8080
80803c24:	eb0007eb 	bl	80805bd8 <vAssertCalled>
80803c28:	eaffffda 	b	80803b98 <xTaskRemoveFromUnorderedEventList+0x34>

80803c2c <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
80803c2c:	e92d4010 	push	{r4, lr}
	configASSERT( pxTimeOut );
80803c30:	e2504000 	subs	r4, r0, #0
80803c34:	0a000005 	beq	80803c50 <vTaskSetTimeOutState+0x24>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80803c38:	e30c3000 	movw	r3, #49152	; 0xc000
80803c3c:	e3483080 	movt	r3, #32896	; 0x8080
80803c40:	e5932148 	ldr	r2, [r3, #328]	; 0x148
	pxTimeOut->xTimeOnEntering = xTickCount;
80803c44:	e5933144 	ldr	r3, [r3, #324]	; 0x144
80803c48:	e884000c 	stm	r4, {r2, r3}
80803c4c:	e8bd8010 	pop	{r4, pc}
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
80803c50:	e3090998 	movw	r0, #39320	; 0x9998
80803c54:	e3001bc1 	movw	r1, #3009	; 0xbc1
80803c58:	e3480080 	movt	r0, #32896	; 0x8080
80803c5c:	eb0007dd 	bl	80805bd8 <vAssertCalled>
80803c60:	eafffff4 	b	80803c38 <vTaskSetTimeOutState+0xc>

80803c64 <xTaskCheckForTimeOut>:
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
80803c64:	e92d4070 	push	{r4, r5, r6, lr}
BaseType_t xReturn;

	configASSERT( pxTimeOut );
80803c68:	e2505000 	subs	r5, r0, #0
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
80803c6c:	e1a04001 	mov	r4, r1
BaseType_t xReturn;

	configASSERT( pxTimeOut );
80803c70:	0a000039 	beq	80803d5c <xTaskCheckForTimeOut+0xf8>
	configASSERT( pxTicksToWait );
80803c74:	e3540000 	cmp	r4, #0
80803c78:	0a000032 	beq	80803d48 <xTaskCheckForTimeOut+0xe4>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80803c7c:	eb0004f9 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80803c80:	e30c3000 	movw	r3, #49152	; 0xc000
80803c84:	e3483080 	movt	r3, #32896	; 0x8080
80803c88:	e5932004 	ldr	r2, [r3, #4]
80803c8c:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80803c90:	15931000 	ldrne	r1, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80803c94:	15932000 	ldrne	r2, [r3]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
80803c98:	e5930144 	ldr	r0, [r3, #324]	; 0x144
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80803c9c:	15912044 	ldrne	r2, [r1, #68]	; 0x44
80803ca0:	12822001 	addne	r2, r2, #1
80803ca4:	15812044 	strne	r2, [r1, #68]	; 0x44
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
80803ca8:	e30c2000 	movw	r2, #49152	; 0xc000
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
80803cac:	e5941000 	ldr	r1, [r4]
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
80803cb0:	e3482080 	movt	r2, #32896	; 0x8080
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
80803cb4:	e3710001 	cmn	r1, #1
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
80803cb8:	03a04000 	moveq	r4, #0
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
80803cbc:	0a000007 	beq	80803ce0 <xTaskCheckForTimeOut+0x7c>
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80803cc0:	e5922148 	ldr	r2, [r2, #328]	; 0x148
80803cc4:	e595c000 	ldr	ip, [r5]
80803cc8:	e15c0002 	cmp	ip, r2
80803ccc:	e5952004 	ldr	r2, [r5, #4]
80803cd0:	0a00000d 	beq	80803d0c <xTaskCheckForTimeOut+0xa8>
80803cd4:	e1500002 	cmp	r0, r2
80803cd8:	3a00000b 	bcc	80803d0c <xTaskCheckForTimeOut+0xa8>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
80803cdc:	e3a04001 	mov	r4, #1

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80803ce0:	e5932004 	ldr	r2, [r3, #4]
80803ce4:	e30c3000 	movw	r3, #49152	; 0xc000
80803ce8:	e3483080 	movt	r3, #32896	; 0x8080
80803cec:	e3520000 	cmp	r2, #0
80803cf0:	0a000003 	beq	80803d04 <xTaskCheckForTimeOut+0xa0>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80803cf4:	e5933000 	ldr	r3, [r3]
80803cf8:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80803cfc:	e3530000 	cmp	r3, #0
80803d00:	1a00000d 	bne	80803d3c <xTaskCheckForTimeOut+0xd8>
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
80803d04:	e1a00004 	mov	r0, r4
80803d08:	e8bd8070 	pop	{r4, r5, r6, pc}
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
80803d0c:	e062c000 	rsb	ip, r2, r0
80803d10:	e151000c 	cmp	r1, ip
80803d14:	9afffff0 	bls	80803cdc <xTaskCheckForTimeOut+0x78>
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80803d18:	e593c148 	ldr	ip, [r3, #328]	; 0x148
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
80803d1c:	e0601001 	rsb	r1, r0, r1

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	pxTimeOut->xTimeOnEntering = xTickCount;
80803d20:	e5930144 	ldr	r0, [r3, #324]	; 0x144
			xReturn = pdTRUE;
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
80803d24:	e0811002 	add	r1, r1, r2
80803d28:	e5841000 	str	r1, [r4]
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
80803d2c:	e3a04000 	mov	r4, #0
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
80803d30:	e585c000 	str	ip, [r5]
	pxTimeOut->xTimeOnEntering = xTickCount;
80803d34:	e5850004 	str	r0, [r5, #4]
80803d38:	eaffffe8 	b	80803ce0 <xTaskCheckForTimeOut+0x7c>
80803d3c:	ebfff6e4 	bl	808018d4 <vTaskExitCritical.part.7>
		}
	}
	taskEXIT_CRITICAL();

	return xReturn;
}
80803d40:	e1a00004 	mov	r0, r4
80803d44:	e8bd8070 	pop	{r4, r5, r6, pc}
BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );
80803d48:	e3090998 	movw	r0, #39320	; 0x9998
80803d4c:	e3001bcc 	movw	r1, #3020	; 0xbcc
80803d50:	e3480080 	movt	r0, #32896	; 0x8080
80803d54:	eb00079f 	bl	80805bd8 <vAssertCalled>
80803d58:	eaffffc7 	b	80803c7c <xTaskCheckForTimeOut+0x18>

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
BaseType_t xReturn;

	configASSERT( pxTimeOut );
80803d5c:	e3090998 	movw	r0, #39320	; 0x9998
80803d60:	e3001bcb 	movw	r1, #3019	; 0xbcb
80803d64:	e3480080 	movt	r0, #32896	; 0x8080
80803d68:	eb00079a 	bl	80805bd8 <vAssertCalled>
80803d6c:	eaffffc0 	b	80803c74 <xTaskCheckForTimeOut+0x10>

80803d70 <vTaskMissedYield>:
}
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
80803d70:	e30c3000 	movw	r3, #49152	; 0xc000
80803d74:	e3a02001 	mov	r2, #1
80803d78:	e3483080 	movt	r3, #32896	; 0x8080
80803d7c:	e5832138 	str	r2, [r3, #312]	; 0x138
80803d80:	e12fff1e 	bx	lr

80803d84 <uxTaskGetTaskNumber>:
	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
	{
	UBaseType_t uxReturn;
	TCB_t *pxTCB;

		if( xTask != NULL )
80803d84:	e3500000 	cmp	r0, #0
		{
			pxTCB = ( TCB_t * ) xTask;
			uxReturn = pxTCB->uxTaskNumber;
80803d88:	1590004c 	ldrne	r0, [r0, #76]	; 0x4c
		{
			uxReturn = 0U;
		}

		return uxReturn;
	}
80803d8c:	e12fff1e 	bx	lr

80803d90 <vTaskSetTaskNumber>:

	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
	{
	TCB_t *pxTCB;

		if( xTask != NULL )
80803d90:	e3500000 	cmp	r0, #0
		{
			pxTCB = ( TCB_t * ) xTask;
			pxTCB->uxTaskNumber = uxHandle;
80803d94:	1580104c 	strne	r1, [r0, #76]	; 0x4c
80803d98:	e12fff1e 	bx	lr

80803d9c <vTaskGetInfo>:
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
80803d9c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
80803da0:	e2508000 	subs	r8, r0, #0
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
80803da4:	e1a06003 	mov	r6, r3
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
80803da8:	030c3000 	movweq	r3, #49152	; 0xc000
80803dac:	03483080 	movteq	r3, #32896	; 0x8080
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
80803db0:	e1a07002 	mov	r7, r2
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );
80803db4:	05935000 	ldreq	r5, [r3]
80803db8:	11a05008 	movne	r5, r8
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
80803dbc:	e5d1200c 	ldrb	r2, [r1, #12]
/*-----------------------------------------------------------*/

#if( configUSE_TRACE_FACILITY == 1 )

	void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState )
	{
80803dc0:	e1a04001 	mov	r4, r1
		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
80803dc4:	e595002c 	ldr	r0, [r5, #44]	; 0x2c

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
80803dc8:	e2853034 	add	r3, r5, #52	; 0x34
	TCB_t *pxTCB;

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
80803dcc:	e5815000 	str	r5, [r1]
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
80803dd0:	e3520003 	cmp	r2, #3
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
80803dd4:	e5951030 	ldr	r1, [r5, #48]	; 0x30
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
80803dd8:	e5952048 	ldr	r2, [r5, #72]	; 0x48
		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
		pxTaskStatus->uxCurrentPriority = pxTCB->uxPriority;
80803ddc:	e5840010 	str	r0, [r4, #16]
		pxTaskStatus->pxStackBase = pxTCB->pxStack;
80803de0:	e584101c 	str	r1, [r4, #28]
		pxTaskStatus->xTaskNumber = pxTCB->uxTCBNumber;
80803de4:	e5842008 	str	r2, [r4, #8]

		/* xTask is NULL then get the state of the calling task. */
		pxTCB = prvGetTCBFromHandle( xTask );

		pxTaskStatus->xHandle = ( TaskHandle_t ) pxTCB;
		pxTaskStatus->pcTaskName = ( const char * ) &( pxTCB->pcTaskName [ 0 ] );
80803de8:	e5843004 	str	r3, [r4, #4]
		#if ( INCLUDE_vTaskSuspend == 1 )
		{
			/* If the task is in the suspended list then there is a chance it is
			actually just blocked indefinitely - so really it should be reported as
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
80803dec:	0a000016 	beq	80803e4c <vTaskGetInfo+0xb0>
		}
		#endif /* INCLUDE_vTaskSuspend */

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
80803df0:	e5953050 	ldr	r3, [r5, #80]	; 0x50
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
80803df4:	e3560005 	cmp	r6, #5
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
80803df8:	e3a02000 	mov	r2, #0
		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
		{
			pxTaskStatus->eCurrentState = eState;
80803dfc:	15c4600c 	strbne	r6, [r4, #12]
		{
			pxTaskStatus->ulRunTimeCounter = pxTCB->ulRunTimeCounter;
		}
		#else
		{
			pxTaskStatus->ulRunTimeCounter = 0;
80803e00:	e5842018 	str	r2, [r4, #24]
		}
		#endif /* INCLUDE_vTaskSuspend */

		#if ( configUSE_MUTEXES == 1 )
		{
			pxTaskStatus->uxBasePriority = pxTCB->uxBasePriority;
80803e04:	e5843014 	str	r3, [r4, #20]
		#endif

		/* Obtaining the task state is a little fiddly, so is only done if the value
		of eState passed into this function is eInvalid - otherwise the state is
		just set to whatever is passed in. */
		if( eState != eInvalid )
80803e08:	0a00001a 	beq	80803e78 <vTaskGetInfo+0xdc>
			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
		}

		/* Obtaining the stack space takes some time, so the xGetFreeStackSpace
		parameter is provided to allow it to be skipped. */
		if( xGetFreeStackSpace != pdFALSE )
80803e0c:	e3570000 	cmp	r7, #0
80803e10:	0a00000b 	beq	80803e44 <vTaskGetInfo+0xa8>
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
80803e14:	e5951030 	ldr	r1, [r5, #48]	; 0x30

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
80803e18:	e5d13000 	ldrb	r3, [r1]
80803e1c:	e35300a5 	cmp	r3, #165	; 0xa5
80803e20:	1a00003c 	bne	80803f18 <vTaskGetInfo+0x17c>
80803e24:	e2813001 	add	r3, r1, #1
80803e28:	e0610003 	rsb	r0, r1, r3
80803e2c:	e4d32001 	ldrb	r2, [r3], #1
80803e30:	e35200a5 	cmp	r2, #165	; 0xa5
80803e34:	0afffffb 	beq	80803e28 <vTaskGetInfo+0x8c>
80803e38:	e7ef0150 	ubfx	r0, r0, #2, #16
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxEndOfStack );
			}
			#else
			{
				pxTaskStatus->usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxTCB->pxStack );
80803e3c:	e1c402b0 	strh	r0, [r4, #32]
80803e40:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
			}
			#endif
		}
		else
		{
			pxTaskStatus->usStackHighWaterMark = 0;
80803e44:	e1c472b0 	strh	r7, [r4, #32]
80803e48:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80803e4c:	e30c3000 	movw	r3, #49152	; 0xc000
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80803e50:	e5951028 	ldr	r1, [r5, #40]	; 0x28
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80803e54:	e3483080 	movt	r3, #32896	; 0x8080
80803e58:	e5932134 	ldr	r2, [r3, #308]	; 0x134
			being in the Blocked state. */
			if( pxTaskStatus->eCurrentState == eSuspended )
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80803e5c:	e3510000 	cmp	r1, #0
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
80803e60:	e2822001 	add	r2, r2, #1
80803e64:	e5832134 	str	r2, [r3, #308]	; 0x134
			{
				vTaskSuspendAll();
				{
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
					{
						pxTaskStatus->eCurrentState = eBlocked;
80803e68:	13a03002 	movne	r3, #2
80803e6c:	15c4300c 	strbne	r3, [r4, #12]
					}
				}
				xTaskResumeAll();
80803e70:	ebfffb69 	bl	80802c1c <xTaskResumeAll>
80803e74:	eaffffdd 	b	80803df0 <vTaskGetInfo+0x54>
	{
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );
80803e78:	e3580000 	cmp	r8, #0
80803e7c:	0a000030 	beq	80803f44 <vTaskGetInfo+0x1a8>

		if( pxTCB == pxCurrentTCB )
80803e80:	e30c6000 	movw	r6, #49152	; 0xc000
80803e84:	e3486080 	movt	r6, #32896	; 0x8080
80803e88:	e5963000 	ldr	r3, [r6]
80803e8c:	e1580003 	cmp	r8, r3
		{
			/* The task calling this function is querying its own state. */
			eReturn = eRunning;
80803e90:	03a03000 	moveq	r3, #0
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );

		if( pxTCB == pxCurrentTCB )
80803e94:	0a00001d 	beq	80803f10 <vTaskGetInfo+0x174>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80803e98:	eb000472 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80803e9c:	e5963004 	ldr	r3, [r6, #4]
		}
		else
		{
			taskENTER_CRITICAL();
			{
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
80803ea0:	e5989014 	ldr	r9, [r8, #20]

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80803ea4:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80803ea8:	15962000 	ldrne	r2, [r6]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80803eac:	15963000 	ldrne	r3, [r6]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80803eb0:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80803eb4:	12833001 	addne	r3, r3, #1
80803eb8:	15823044 	strne	r3, [r2, #68]	; 0x44

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80803ebc:	e30c3000 	movw	r3, #49152	; 0xc000
80803ec0:	e5962004 	ldr	r2, [r6, #4]
80803ec4:	e3483080 	movt	r3, #32896	; 0x8080
80803ec8:	e3520000 	cmp	r2, #0
80803ecc:	0a000003 	beq	80803ee0 <vTaskGetInfo+0x144>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80803ed0:	e5933000 	ldr	r3, [r3]
80803ed4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80803ed8:	e3530000 	cmp	r3, #0
80803edc:	1a00000f 	bne	80803f20 <vTaskGetInfo+0x184>
			{
				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
			}
			taskEXIT_CRITICAL();

			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
80803ee0:	e5962124 	ldr	r2, [r6, #292]	; 0x124
80803ee4:	e30c3000 	movw	r3, #49152	; 0xc000
80803ee8:	e3483080 	movt	r3, #32896	; 0x8080
80803eec:	e1590002 	cmp	r9, r2
80803ef0:	0a000011 	beq	80803f3c <vTaskGetInfo+0x1a0>
80803ef4:	e5932128 	ldr	r2, [r3, #296]	; 0x128
80803ef8:	e1590002 	cmp	r9, r2
80803efc:	0a00000e 	beq	80803f3c <vTaskGetInfo+0x1a0>
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
80803f00:	e2833e11 	add	r3, r3, #272	; 0x110
80803f04:	e1590003 	cmp	r9, r3

			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
			{
				/* If the task is not in any other state, it must be in the
				Ready (including pending ready) state. */
				eReturn = eReady;
80803f08:	13a03001 	movne	r3, #1
				lists. */
				eReturn = eBlocked;
			}

			#if ( INCLUDE_vTaskSuspend == 1 )
				else if( pxStateList == &xSuspendedTaskList )
80803f0c:	0a000005 	beq	80803f28 <vTaskGetInfo+0x18c>
		{
			pxTaskStatus->eCurrentState = eState;
		}
		else
		{
			pxTaskStatus->eCurrentState = eTaskGetState( xTask );
80803f10:	e5c4300c 	strb	r3, [r4, #12]
80803f14:	eaffffbc 	b	80803e0c <vTaskGetInfo+0x70>

	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
	{
	uint32_t ulCount = 0U;

		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
80803f18:	e3a00000 	mov	r0, #0
80803f1c:	eaffffc6 	b	80803e3c <vTaskGetInfo+0xa0>
80803f20:	ebfff66b 	bl	808018d4 <vTaskExitCritical.part.7>
80803f24:	eaffffed 	b	80803ee0 <vTaskGetInfo+0x144>
				else if( pxStateList == &xSuspendedTaskList )
				{
					/* The task being queried is referenced from the suspended
					list.  Is it genuinely suspended or is it block
					indefinitely? */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
80803f28:	e5983028 	ldr	r3, [r8, #40]	; 0x28
					{
						eReturn = eSuspended;
80803f2c:	e3530000 	cmp	r3, #0
80803f30:	13a03002 	movne	r3, #2
80803f34:	03a03003 	moveq	r3, #3
80803f38:	eafffff4 	b	80803f10 <vTaskGetInfo+0x174>
					}
					else
					{
						eReturn = eBlocked;
80803f3c:	e3a03002 	mov	r3, #2
80803f40:	eafffff2 	b	80803f10 <vTaskGetInfo+0x174>
	{
	eTaskState eReturn;
	List_t *pxStateList;
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;

		configASSERT( pxTCB );
80803f44:	e3090998 	movw	r0, #39320	; 0x9998
80803f48:	e30014fb 	movw	r1, #1275	; 0x4fb
80803f4c:	e3480080 	movt	r0, #32896	; 0x8080
80803f50:	eb000720 	bl	80805bd8 <vAssertCalled>
80803f54:	eaffffc9 	b	80803e80 <vTaskGetInfo+0xe4>

80803f58 <xTaskGetCurrentTaskHandle>:
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
80803f58:	e30c3000 	movw	r3, #49152	; 0xc000
80803f5c:	e3483080 	movt	r3, #32896	; 0x8080
80803f60:	e5930000 	ldr	r0, [r3]

		return xReturn;
	}
80803f64:	e12fff1e 	bx	lr

80803f68 <vTaskPriorityInherit>:
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
80803f68:	e3500000 	cmp	r0, #0
80803f6c:	012fff1e 	bxeq	lr
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
80803f70:	e30c3000 	movw	r3, #49152	; 0xc000
80803f74:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
80803f78:	e3483080 	movt	r3, #32896	; 0x8080
80803f7c:	e5931000 	ldr	r1, [r3]
80803f80:	e591102c 	ldr	r1, [r1, #44]	; 0x2c
80803f84:	e1520001 	cmp	r2, r1
80803f88:	212fff1e 	bxcs	lr
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80803f8c:	e5901018 	ldr	r1, [r0, #24]
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
80803f90:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80803f94:	e30c4000 	movw	r4, #49152	; 0xc000
80803f98:	e3484080 	movt	r4, #32896	; 0x8080
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80803f9c:	e3510000 	cmp	r1, #0
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80803fa0:	e284500c 	add	r5, r4, #12
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80803fa4:	a5933000 	ldrge	r3, [r3]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80803fa8:	e5901014 	ldr	r1, [r0, #20]
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80803fac:	a593302c 	ldrge	r3, [r3, #44]	; 0x2c
80803fb0:	a263300a 	rsbge	r3, r3, #10
80803fb4:	a5803018 	strge	r3, [r0, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80803fb8:	e1a03202 	lsl	r3, r2, #4
80803fbc:	e0833102 	add	r3, r3, r2, lsl #2
80803fc0:	e0853003 	add	r3, r5, r3
80803fc4:	e1510003 	cmp	r1, r3
80803fc8:	0a000003 	beq	80803fdc <vTaskPriorityInherit+0x74>
					prvAddTaskToReadyList( pxTCB );
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80803fcc:	e5943000 	ldr	r3, [r4]
80803fd0:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
80803fd4:	e580302c 	str	r3, [r0, #44]	; 0x2c
80803fd8:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
				{
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80803fdc:	e2806004 	add	r6, r0, #4
80803fe0:	e1a07000 	mov	r7, r0
80803fe4:	e1a00006 	mov	r0, r6
80803fe8:	ebfff066 	bl	80800188 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80803fec:	e5943000 	ldr	r3, [r4]
					prvAddTaskToReadyList( pxTCB );
80803ff0:	e1a01006 	mov	r1, r6
80803ff4:	e5942130 	ldr	r2, [r4, #304]	; 0x130
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80803ff8:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
80803ffc:	e1530002 	cmp	r3, r2
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
80804000:	e587302c 	str	r3, [r7, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
80804004:	e1a00203 	lsl	r0, r3, #4
80804008:	85843130 	strhi	r3, [r4, #304]	; 0x130
8080400c:	e0800103 	add	r0, r0, r3, lsl #2
80804010:	e0850000 	add	r0, r5, r0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
80804014:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
					prvAddTaskToReadyList( pxTCB );
80804018:	eafff039 	b	80800104 <vListInsertEnd>

8080401c <xTaskPriorityDisinherit>:
	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
8080401c:	e3500000 	cmp	r0, #0
80804020:	0a000034 	beq	808040f8 <xTaskPriorityDisinherit+0xdc>
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
80804024:	e92d4070 	push	{r4, r5, r6, lr}
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
80804028:	e30c5000 	movw	r5, #49152	; 0xc000
8080402c:	e3485080 	movt	r5, #32896	; 0x8080
80804030:	e1a04000 	mov	r4, r0
80804034:	e5953000 	ldr	r3, [r5]
80804038:	e1500003 	cmp	r0, r3
8080403c:	0a000003 	beq	80804050 <xTaskPriorityDisinherit+0x34>
80804040:	e3090998 	movw	r0, #39320	; 0x9998
80804044:	e3001ec7 	movw	r1, #3783	; 0xec7
80804048:	e3480080 	movt	r0, #32896	; 0x8080
8080404c:	eb0006e1 	bl	80805bd8 <vAssertCalled>

			configASSERT( pxTCB->uxMutexesHeld );
80804050:	e5943054 	ldr	r3, [r4, #84]	; 0x54
80804054:	e3530000 	cmp	r3, #0
80804058:	0a000020 	beq	808040e0 <xTaskPriorityDisinherit+0xc4>
			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
8080405c:	e594202c 	ldr	r2, [r4, #44]	; 0x2c
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
80804060:	e2433001 	sub	r3, r3, #1
			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
80804064:	e5941050 	ldr	r1, [r4, #80]	; 0x50
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
80804068:	e5843054 	str	r3, [r4, #84]	; 0x54
			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
8080406c:	e0522001 	subs	r2, r2, r1
80804070:	13a02001 	movne	r2, #1
80804074:	e3530000 	cmp	r3, #0
80804078:	13a02000 	movne	r2, #0
8080407c:	e3520000 	cmp	r2, #0
80804080:	1a000001 	bne	8080408c <xTaskPriorityDisinherit+0x70>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
80804084:	e3a00000 	mov	r0, #0
80804088:	e8bd8070 	pop	{r4, r5, r6, pc}
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
8080408c:	e2846004 	add	r6, r4, #4
80804090:	e1a00006 	mov	r0, r6
80804094:	ebfff03b 	bl	80800188 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
80804098:	e5943050 	ldr	r3, [r4, #80]	; 0x50

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
8080409c:	e30c2000 	movw	r2, #49152	; 0xc000
808040a0:	e5951130 	ldr	r1, [r5, #304]	; 0x130
808040a4:	e3482080 	movt	r2, #32896	; 0x8080
808040a8:	e30c000c 	movw	r0, #49164	; 0xc00c
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
808040ac:	e584302c 	str	r3, [r4, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
					prvAddTaskToReadyList( pxTCB );
808040b0:	e3480080 	movt	r0, #32896	; 0x8080
808040b4:	e1530001 	cmp	r3, r1
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
808040b8:	e263100a 	rsb	r1, r3, #10
					prvAddTaskToReadyList( pxTCB );
808040bc:	85823130 	strhi	r3, [r2, #304]	; 0x130
808040c0:	e1a02203 	lsl	r2, r3, #4
					pxTCB->uxPriority = pxTCB->uxBasePriority;

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
808040c4:	e5841018 	str	r1, [r4, #24]
					prvAddTaskToReadyList( pxTCB );
808040c8:	e1a01006 	mov	r1, r6
808040cc:	e0823103 	add	r3, r2, r3, lsl #2
808040d0:	e0800003 	add	r0, r0, r3
808040d4:	ebfff00a 	bl	80800104 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
808040d8:	e3a00001 	mov	r0, #1
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
808040dc:	e8bd8070 	pop	{r4, r5, r6, pc}
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
808040e0:	e3090998 	movw	r0, #39320	; 0x9998
808040e4:	e3001ec9 	movw	r1, #3785	; 0xec9
808040e8:	e3480080 	movt	r0, #32896	; 0x8080
808040ec:	eb0006b9 	bl	80805bd8 <vAssertCalled>
808040f0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
808040f4:	eaffffd8 	b	8080405c <xTaskPriorityDisinherit+0x40>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
808040f8:	e3a00000 	mov	r0, #0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
808040fc:	e12fff1e 	bx	lr

80804100 <vTaskEnterCritical>:
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
80804100:	e92d4010 	push	{r4, lr}
		portDISABLE_INTERRUPTS();
80804104:	eb0003d7 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80804108:	e30c3000 	movw	r3, #49152	; 0xc000
8080410c:	e3483080 	movt	r3, #32896	; 0x8080
80804110:	e5932004 	ldr	r2, [r3, #4]
80804114:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804118:	15932000 	ldrne	r2, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
8080411c:	15933000 	ldrne	r3, [r3]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804120:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80804124:	12833001 	addne	r3, r3, #1
80804128:	15823044 	strne	r3, [r2, #68]	; 0x44
8080412c:	e8bd8010 	pop	{r4, pc}

80804130 <vTaskExitCritical>:

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80804130:	e30c3000 	movw	r3, #49152	; 0xc000
80804134:	e3483080 	movt	r3, #32896	; 0x8080
80804138:	e5932004 	ldr	r2, [r3, #4]
8080413c:	e3520000 	cmp	r2, #0
80804140:	012fff1e 	bxeq	lr
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80804144:	e5932000 	ldr	r2, [r3]
80804148:	e5922044 	ldr	r2, [r2, #68]	; 0x44
8080414c:	e3520000 	cmp	r2, #0
80804150:	012fff1e 	bxeq	lr
			{
				( pxCurrentTCB->uxCriticalNesting )--;
80804154:	e5932000 	ldr	r2, [r3]

				if( pxCurrentTCB->uxCriticalNesting == 0U )
80804158:	e5931000 	ldr	r1, [r3]
	{
		if( xSchedulerRunning != pdFALSE )
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
			{
				( pxCurrentTCB->uxCriticalNesting )--;
8080415c:	e5923044 	ldr	r3, [r2, #68]	; 0x44
80804160:	e2433001 	sub	r3, r3, #1
80804164:	e5823044 	str	r3, [r2, #68]	; 0x44

				if( pxCurrentTCB->uxCriticalNesting == 0U )
80804168:	e5913044 	ldr	r3, [r1, #68]	; 0x44
8080416c:	e3530000 	cmp	r3, #0
80804170:	112fff1e 	bxne	lr
/*-----------------------------------------------------------*/

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
80804174:	e92d4010 	push	{r4, lr}
#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	portCLEAR_INTERRUPT_MASK(x)
#define portDISABLE_INTERRUPTS()				((void)portSET_INTERRUPT_MASK())
/* #define portENABLE_INTERRUPTS()					portCLEAR_INTERRUPT_MASK(configLOWEST_INTERRUPT_PRIORITY) */
static inline void portENABLE_INTERRUPTS(void)
{
	portCLEAR_INTERRUPT_MASK(configLOWEST_INTERRUPT_PRIORITY);
80804178:	e3a000ff 	mov	r0, #255	; 0xff
8080417c:	eb0003bf 	bl	80805080 <vPortClearInterruptMask>
	__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80804180:	e320f000 	nop	{0}
#if configPLATFORM==3
	__asm__ __volatile__ ( "nop" );
80804184:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80804188:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080418c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80804190:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80804194:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
80804198:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
8080419c:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041a0:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041a4:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041a8:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041ac:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041b0:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041b4:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041b8:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041bc:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041c0:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041c4:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041c8:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041cc:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041d0:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041d4:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041d8:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041dc:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041e0:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041e4:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041e8:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041ec:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041f0:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041f4:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041f8:	e320f000 	nop	{0}
	__asm__ __volatile__ ( "nop" );
808041fc:	e320f000 	nop	{0}
80804200:	e8bd8010 	pop	{r4, pc}

80804204 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
80804204:	e30c3000 	movw	r3, #49152	; 0xc000
80804208:	e3483080 	movt	r3, #32896	; 0x8080
8080420c:	e5931000 	ldr	r1, [r3]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80804210:	e5932000 	ldr	r2, [r3]
80804214:	e5933000 	ldr	r3, [r3]

TickType_t uxTaskResetEventItemValue( void )
{
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
80804218:	e5910018 	ldr	r0, [r1, #24]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
8080421c:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
80804220:	e263300a 	rsb	r3, r3, #10
80804224:	e5823018 	str	r3, [r2, #24]

	return uxReturn;
}
80804228:	e12fff1e 	bx	lr

8080422c <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
8080422c:	e30c3000 	movw	r3, #49152	; 0xc000
80804230:	e3483080 	movt	r3, #32896	; 0x8080
80804234:	e5932000 	ldr	r2, [r3]
80804238:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxMutexesHeld )++;
8080423c:	15931000 	ldrne	r1, [r3]
		}

		return pxCurrentTCB;
80804240:	e5930000 	ldr	r0, [r3]
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
		{
			( pxCurrentTCB->uxMutexesHeld )++;
80804244:	15912054 	ldrne	r2, [r1, #84]	; 0x54
80804248:	12822001 	addne	r2, r2, #1
8080424c:	15812054 	strne	r2, [r1, #84]	; 0x54
		}

		return pxCurrentTCB;
	}
80804250:	e12fff1e 	bx	lr

80804254 <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
80804254:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80804258:	e30c4000 	movw	r4, #49152	; 0xc000
8080425c:	e3484080 	movt	r4, #32896	; 0x8080
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
80804260:	e1a07000 	mov	r7, r0
80804264:	e1a06001 	mov	r6, r1
	uint32_t ulReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
80804268:	e30c5000 	movw	r5, #49152	; 0xc000

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
8080426c:	eb00037d 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80804270:	e5943004 	ldr	r3, [r4, #4]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
80804274:	e3485080 	movt	r5, #32896	; 0x8080

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80804278:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
8080427c:	15942000 	ldrne	r2, [r4]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80804280:	15943000 	ldrne	r3, [r4]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804284:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80804288:	12833001 	addne	r3, r3, #1
8080428c:	15823044 	strne	r3, [r2, #68]	; 0x44
	uint32_t ulReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
80804290:	e5943000 	ldr	r3, [r4]
80804294:	e5933058 	ldr	r3, [r3, #88]	; 0x58
80804298:	e3530000 	cmp	r3, #0
8080429c:	1a000004 	bne	808042b4 <ulTaskNotifyTake+0x60>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
808042a0:	e5953000 	ldr	r3, [r5]

				if( xTicksToWait > ( TickType_t ) 0 )
808042a4:	e3560000 	cmp	r6, #0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
808042a8:	e3a02001 	mov	r2, #1
808042ac:	e5c3205c 	strb	r2, [r3, #92]	; 0x5c

				if( xTicksToWait > ( TickType_t ) 0 )
808042b0:	1a000030 	bne	80804378 <ulTaskNotifyTake+0x124>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
808042b4:	e5942004 	ldr	r2, [r4, #4]
808042b8:	e30c3000 	movw	r3, #49152	; 0xc000
808042bc:	e3483080 	movt	r3, #32896	; 0x8080
808042c0:	e3520000 	cmp	r2, #0
808042c4:	0a000003 	beq	808042d8 <ulTaskNotifyTake+0x84>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
808042c8:	e5933000 	ldr	r3, [r3]
808042cc:	e5933044 	ldr	r3, [r3, #68]	; 0x44
808042d0:	e3530000 	cmp	r3, #0
808042d4:	1a000025 	bne	80804370 <ulTaskNotifyTake+0x11c>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
808042d8:	eb000362 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
808042dc:	e5942004 	ldr	r2, [r4, #4]
808042e0:	e30c3000 	movw	r3, #49152	; 0xc000
808042e4:	e3483080 	movt	r3, #32896	; 0x8080
808042e8:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808042ec:	15932000 	ldrne	r2, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
808042f0:	15933000 	ldrne	r3, [r3]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808042f4:	15923044 	ldrne	r3, [r2, #68]	; 0x44
808042f8:	12833001 	addne	r3, r3, #1
808042fc:	15823044 	strne	r3, [r2, #68]	; 0x44
		taskEXIT_CRITICAL();

		taskENTER_CRITICAL();
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
80804300:	e30c3000 	movw	r3, #49152	; 0xc000
80804304:	e5942000 	ldr	r2, [r4]
80804308:	e3483080 	movt	r3, #32896	; 0x8080
8080430c:	e5925058 	ldr	r5, [r2, #88]	; 0x58

			if( ulReturn != 0UL )
80804310:	e3550000 	cmp	r5, #0
80804314:	0a000004 	beq	8080432c <ulTaskNotifyTake+0xd8>
			{
				if( xClearCountOnExit != pdFALSE )
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
80804318:	e5933000 	ldr	r3, [r3]
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;

			if( ulReturn != 0UL )
			{
				if( xClearCountOnExit != pdFALSE )
8080431c:	e3570000 	cmp	r7, #0
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
80804320:	13a02000 	movne	r2, #0
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
80804324:	02452001 	subeq	r2, r5, #1
80804328:	e5832058 	str	r2, [r3, #88]	; 0x58
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
8080432c:	e5942000 	ldr	r2, [r4]
80804330:	e3a01000 	mov	r1, #0
80804334:	e30c3000 	movw	r3, #49152	; 0xc000
80804338:	e3483080 	movt	r3, #32896	; 0x8080
8080433c:	e5c2105c 	strb	r1, [r2, #92]	; 0x5c

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80804340:	e5942004 	ldr	r2, [r4, #4]
80804344:	e1520001 	cmp	r2, r1
80804348:	0a000003 	beq	8080435c <ulTaskNotifyTake+0x108>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
8080434c:	e5933000 	ldr	r3, [r3]
80804350:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80804354:	e1530001 	cmp	r3, r1
80804358:	1a000001 	bne	80804364 <ulTaskNotifyTake+0x110>
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
		}
		taskEXIT_CRITICAL();

		return ulReturn;
	}
8080435c:	e1a00005 	mov	r0, r5
80804360:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
80804364:	ebfff55a 	bl	808018d4 <vTaskExitCritical.part.7>
80804368:	e1a00005 	mov	r0, r5
8080436c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
80804370:	ebfff557 	bl	808018d4 <vTaskExitCritical.part.7>
80804374:	eaffffd7 	b	808042d8 <ulTaskNotifyTake+0x84>


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
80804378:	e5958144 	ldr	r8, [r5, #324]	; 0x144
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
8080437c:	e5950000 	ldr	r0, [r5]
80804380:	e2800004 	add	r0, r0, #4
80804384:	ebffef7f 	bl	80800188 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80804388:	e3760001 	cmn	r6, #1
8080438c:	0a00003c 	beq	80804484 <ulTaskNotifyTake+0x230>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
80804390:	e0866008 	add	r6, r6, r8

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80804394:	e5953000 	ldr	r3, [r5]

			if( xTimeToWake < xConstTickCount )
80804398:	e1580006 	cmp	r8, r6
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
8080439c:	e5836004 	str	r6, [r3, #4]

			if( xTimeToWake < xConstTickCount )
808043a0:	8a000032 	bhi	80804470 <ulTaskNotifyTake+0x21c>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
808043a4:	e5950124 	ldr	r0, [r5, #292]	; 0x124
808043a8:	e5951000 	ldr	r1, [r5]
808043ac:	e2811004 	add	r1, r1, #4
808043b0:	ebffef5d 	bl	8080012c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
808043b4:	e595313c 	ldr	r3, [r5, #316]	; 0x13c
808043b8:	e1560003 	cmp	r6, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
808043bc:	3585613c 	strcc	r6, [r5, #316]	; 0x13c
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808043c0:	e3a03a01 	mov	r3, #4096	; 0x1000
808043c4:	e3443824 	movt	r3, #18468	; 0x4824
808043c8:	e5932200 	ldr	r2, [r3, #512]	; 0x200
808043cc:	e3120001 	tst	r2, #1
808043d0:	1affffb7 	bne	808042b4 <ulTaskNotifyTake+0x60>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808043d4:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808043d8:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808043dc:	e2022003 	and	r2, r2, #3
808043e0:	e1a02211 	lsl	r2, r1, r2
808043e4:	e3822001 	orr	r2, r2, #1
808043e8:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
808043ec:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
808043f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808043f4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808043f8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808043fc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804400:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804404:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804408:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080440c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804410:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804414:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804418:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080441c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804420:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804424:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804428:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080442c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804430:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804434:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804438:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080443c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804440:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804444:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804448:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080444c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804450:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804454:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804458:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080445c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804460:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804464:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804468:	e320f000 	nop	{0}
8080446c:	eaffff90 	b	808042b4 <ulTaskNotifyTake+0x60>

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80804470:	e5950128 	ldr	r0, [r5, #296]	; 0x128
80804474:	e5951000 	ldr	r1, [r5]
80804478:	e2811004 	add	r1, r1, #4
8080447c:	ebffef2a 	bl	8080012c <vListInsert>
80804480:	eaffffce 	b	808043c0 <ulTaskNotifyTake+0x16c>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80804484:	e1a00005 	mov	r0, r5
80804488:	e4901110 	ldr	r1, [r0], #272	; 0x110
8080448c:	e2811004 	add	r1, r1, #4
80804490:	ebffef1b 	bl	80800104 <vListInsertEnd>
80804494:	eaffffc9 	b	808043c0 <ulTaskNotifyTake+0x16c>

80804498 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
80804498:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
8080449c:	e30c4000 	movw	r4, #49152	; 0xc000
808044a0:	e3484080 	movt	r4, #32896	; 0x8080
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
808044a4:	e1a07002 	mov	r7, r2
808044a8:	e1a08003 	mov	r8, r3
808044ac:	e1a09000 	mov	r9, r0
808044b0:	e1a06001 	mov	r6, r1
	BaseType_t xReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
808044b4:	e30c5000 	movw	r5, #49152	; 0xc000

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
808044b8:	eb0002ea 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
808044bc:	e5943004 	ldr	r3, [r4, #4]
	BaseType_t xReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
808044c0:	e3485080 	movt	r5, #32896	; 0x8080

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
808044c4:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808044c8:	15942000 	ldrne	r2, [r4]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
808044cc:	15943000 	ldrne	r3, [r4]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
808044d0:	15923044 	ldrne	r3, [r2, #68]	; 0x44
808044d4:	12833001 	addne	r3, r3, #1
808044d8:	15823044 	strne	r3, [r2, #68]	; 0x44
	BaseType_t xReturn;

		taskENTER_CRITICAL();
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
808044dc:	e5943000 	ldr	r3, [r4]
808044e0:	e5d3305c 	ldrb	r3, [r3, #92]	; 0x5c
808044e4:	e3530002 	cmp	r3, #2
808044e8:	0a000008 	beq	80804510 <xTaskNotifyWait+0x78>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
808044ec:	e5953000 	ldr	r3, [r5]

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;

				if( xTicksToWait > ( TickType_t ) 0 )
808044f0:	e3580000 	cmp	r8, #0
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
808044f4:	e3a02001 	mov	r2, #1
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
808044f8:	e5930058 	ldr	r0, [r3, #88]	; 0x58
808044fc:	e1c00009 	bic	r0, r0, r9
80804500:	e5830058 	str	r0, [r3, #88]	; 0x58

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
80804504:	e5953000 	ldr	r3, [r5]
80804508:	e5c3205c 	strb	r2, [r3, #92]	; 0x5c

				if( xTicksToWait > ( TickType_t ) 0 )
8080450c:	1a000032 	bne	808045dc <xTaskNotifyWait+0x144>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80804510:	e5942004 	ldr	r2, [r4, #4]
80804514:	e30c3000 	movw	r3, #49152	; 0xc000
80804518:	e3483080 	movt	r3, #32896	; 0x8080
8080451c:	e3520000 	cmp	r2, #0
80804520:	0a000003 	beq	80804534 <xTaskNotifyWait+0x9c>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80804524:	e5933000 	ldr	r3, [r3]
80804528:	e5933044 	ldr	r3, [r3, #68]	; 0x44
8080452c:	e3530000 	cmp	r3, #0
80804530:	1a000067 	bne	808046d4 <xTaskNotifyWait+0x23c>

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80804534:	eb0002cb 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80804538:	e5942004 	ldr	r2, [r4, #4]
8080453c:	e30c3000 	movw	r3, #49152	; 0xc000
80804540:	e3483080 	movt	r3, #32896	; 0x8080
80804544:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804548:	15932000 	ldrne	r2, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
8080454c:	15933000 	ldrne	r3, [r3]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804550:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80804554:	12833001 	addne	r3, r3, #1
80804558:	15823044 	strne	r3, [r2, #68]	; 0x44

		taskENTER_CRITICAL();
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
8080455c:	e3570000 	cmp	r7, #0
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
80804560:	15943000 	ldrne	r3, [r4]
80804564:	15933058 	ldrne	r3, [r3, #88]	; 0x58

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
80804568:	e5942000 	ldr	r2, [r4]

			if( pulNotificationValue != NULL )
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
8080456c:	15873000 	strne	r3, [r7]

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
80804570:	e30c3000 	movw	r3, #49152	; 0xc000
80804574:	e5d2205c 	ldrb	r2, [r2, #92]	; 0x5c
80804578:	e3483080 	movt	r3, #32896	; 0x8080
8080457c:	e3520001 	cmp	r2, #1
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
80804580:	15933000 	ldrne	r3, [r3]
				xReturn = pdTRUE;
80804584:	13a05001 	movne	r5, #1
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
80804588:	03a05000 	moveq	r5, #0
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
8080458c:	15931058 	ldrne	r1, [r3, #88]	; 0x58
80804590:	11c11006 	bicne	r1, r1, r6
80804594:	15831058 	strne	r1, [r3, #88]	; 0x58
				xReturn = pdTRUE;
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
80804598:	e3a01000 	mov	r1, #0
8080459c:	e5942000 	ldr	r2, [r4]
808045a0:	e30c3000 	movw	r3, #49152	; 0xc000
808045a4:	e3483080 	movt	r3, #32896	; 0x8080
808045a8:	e5c2105c 	strb	r1, [r2, #92]	; 0x5c

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
808045ac:	e5942004 	ldr	r2, [r4, #4]
808045b0:	e1520001 	cmp	r2, r1
808045b4:	0a000003 	beq	808045c8 <xTaskNotifyWait+0x130>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
808045b8:	e5933000 	ldr	r3, [r3]
808045bc:	e5933044 	ldr	r3, [r3, #68]	; 0x44
808045c0:	e1530001 	cmp	r3, r1
808045c4:	1a000001 	bne	808045d0 <xTaskNotifyWait+0x138>
			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
808045c8:	e1a00005 	mov	r0, r5
808045cc:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
808045d0:	ebfff4bf 	bl	808018d4 <vTaskExitCritical.part.7>
808045d4:	e1a00005 	mov	r0, r5
808045d8:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
808045dc:	e5959144 	ldr	r9, [r5, #324]	; 0x144
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
808045e0:	e5950000 	ldr	r0, [r5]
808045e4:	e2800004 	add	r0, r0, #4
808045e8:	ebffeee6 	bl	80800188 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
808045ec:	e3780001 	cmn	r8, #1
808045f0:	0a00003e 	beq	808046f0 <xTaskNotifyWait+0x258>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
808045f4:	e0888009 	add	r8, r8, r9

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
808045f8:	e5953000 	ldr	r3, [r5]

			if( xTimeToWake < xConstTickCount )
808045fc:	e1590008 	cmp	r9, r8
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
80804600:	e5838004 	str	r8, [r3, #4]

			if( xTimeToWake < xConstTickCount )
80804604:	8a000034 	bhi	808046dc <xTaskNotifyWait+0x244>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
80804608:	e5950124 	ldr	r0, [r5, #292]	; 0x124
8080460c:	e5951000 	ldr	r1, [r5]
80804610:	e2811004 	add	r1, r1, #4
80804614:	ebffeec4 	bl	8080012c <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
80804618:	e595313c 	ldr	r3, [r5, #316]	; 0x13c
8080461c:	e1580003 	cmp	r8, r3
				{
					xNextTaskUnblockTime = xTimeToWake;
80804620:	3585813c 	strcc	r8, [r5, #316]	; 0x13c
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80804624:	e3a03a01 	mov	r3, #4096	; 0x1000
80804628:	e3443824 	movt	r3, #18468	; 0x4824
8080462c:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80804630:	e3120001 	tst	r2, #1
80804634:	1affffb5 	bne	80804510 <xTaskNotifyWait+0x78>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80804638:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
8080463c:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80804640:	e2022003 	and	r2, r2, #3
80804644:	e1a02211 	lsl	r2, r1, r2
80804648:	e3822001 	orr	r2, r2, #1
8080464c:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80804650:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80804654:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804658:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080465c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804660:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804664:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804668:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080466c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804670:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804674:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804678:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080467c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804680:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804684:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804688:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080468c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804690:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804694:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804698:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080469c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046a0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046a4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046a8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046ac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046b0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046b4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046b8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046bc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046c0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046c4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046c8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808046cc:	e320f000 	nop	{0}
808046d0:	eaffff8e 	b	80804510 <xTaskNotifyWait+0x78>
808046d4:	ebfff47e 	bl	808018d4 <vTaskExitCritical.part.7>
808046d8:	eaffff95 	b	80804534 <xTaskNotifyWait+0x9c>

			if( xTimeToWake < xConstTickCount )
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
808046dc:	e5950128 	ldr	r0, [r5, #296]	; 0x128
808046e0:	e5951000 	ldr	r1, [r5]
808046e4:	e2811004 	add	r1, r1, #4
808046e8:	ebffee8f 	bl	8080012c <vListInsert>
808046ec:	eaffffcc 	b	80804624 <xTaskNotifyWait+0x18c>
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
808046f0:	e1a00005 	mov	r0, r5
808046f4:	e4901110 	ldr	r1, [r0], #272	; 0x110
808046f8:	e2811004 	add	r1, r1, #4
808046fc:	ebffee80 	bl	80800104 <vListInsertEnd>
80804700:	eaffffc7 	b	80804624 <xTaskNotifyWait+0x18c>

80804704 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
80804704:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
80804708:	e2505000 	subs	r5, r0, #0
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
8080470c:	e1a08001 	mov	r8, r1
80804710:	e1a06002 	mov	r6, r2
80804714:	e1a07003 	mov	r7, r3
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
80804718:	0a00007e 	beq	80804918 <xTaskGenericNotify+0x214>

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
8080471c:	e30c4000 	movw	r4, #49152	; 0xc000
80804720:	e3484080 	movt	r4, #32896	; 0x8080

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80804724:	eb00024f 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80804728:	e5943004 	ldr	r3, [r4, #4]
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
8080472c:	e3a01002 	mov	r1, #2

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
80804730:	e3530000 	cmp	r3, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804734:	15942000 	ldrne	r2, [r4]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80804738:	15943000 	ldrne	r3, [r4]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
8080473c:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80804740:	12833001 	addne	r3, r3, #1
80804744:	15823044 	strne	r3, [r2, #68]	; 0x44
		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
		{
			if( pulPreviousNotificationValue != NULL )
80804748:	e3570000 	cmp	r7, #0
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
8080474c:	15953058 	ldrne	r3, [r5, #88]	; 0x58

			ucOriginalNotifyState = pxTCB->ucNotifyState;

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
80804750:	e2462001 	sub	r2, r6, #1

		taskENTER_CRITICAL();
		{
			if( pulPreviousNotificationValue != NULL )
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
80804754:	15873000 	strne	r3, [r7]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
80804758:	e5d5305c 	ldrb	r3, [r5, #92]	; 0x5c

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
8080475c:	e5c5105c 	strb	r1, [r5, #92]	; 0x5c
			if( pulPreviousNotificationValue != NULL )
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
80804760:	e6ef3073 	uxtb	r3, r3

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
80804764:	e3520003 	cmp	r2, #3
80804768:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
8080476c:	ea000007 	b	80804790 <xTaskGenericNotify+0x8c>
80804770:	808048fc 	.word	0x808048fc
80804774:	808047c8 	.word	0x808047c8
80804778:	8080478c 	.word	0x8080478c
8080477c:	80804780 	.word	0x80804780
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80804780:	e3530002 	cmp	r3, #2
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
80804784:	03a05000 	moveq	r5, #0
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80804788:	0a000003 	beq	8080479c <xTaskGenericNotify+0x98>
					{
						pxTCB->ulNotifiedValue = ulValue;
8080478c:	e5858058 	str	r8, [r5, #88]	; 0x58

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80804790:	e3530001 	cmp	r3, #1
80804794:	0a000010 	beq	808047dc <xTaskGenericNotify+0xd8>
80804798:	e3a05001 	mov	r5, #1

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
8080479c:	e5942004 	ldr	r2, [r4, #4]
808047a0:	e30c3000 	movw	r3, #49152	; 0xc000
808047a4:	e3483080 	movt	r3, #32896	; 0x8080
808047a8:	e3520000 	cmp	r2, #0
808047ac:	0a000003 	beq	808047c0 <xTaskGenericNotify+0xbc>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
808047b0:	e5933000 	ldr	r3, [r3]
808047b4:	e5933044 	ldr	r3, [r3, #68]	; 0x44
808047b8:	e3530000 	cmp	r3, #0
808047bc:	1a000052 	bne	8080490c <xTaskGenericNotify+0x208>
			}
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
808047c0:	e1a00005 	mov	r0, r5
808047c4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
808047c8:	e5952058 	ldr	r2, [r5, #88]	; 0x58

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
808047cc:	e3530001 	cmp	r3, #1
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
808047d0:	e2822001 	add	r2, r2, #1
808047d4:	e5852058 	str	r2, [r5, #88]	; 0x58

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
808047d8:	1affffee 	bne	80804798 <xTaskGenericNotify+0x94>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
808047dc:	e2856004 	add	r6, r5, #4
808047e0:	e1a00006 	mov	r0, r6
808047e4:	ebffee67 	bl	80800188 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
808047e8:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
808047ec:	e30c2000 	movw	r2, #49152	; 0xc000
808047f0:	e5941130 	ldr	r1, [r4, #304]	; 0x130
808047f4:	e3482080 	movt	r2, #32896	; 0x8080
808047f8:	e30c000c 	movw	r0, #49164	; 0xc00c
808047fc:	e3480080 	movt	r0, #32896	; 0x8080
80804800:	e1530001 	cmp	r3, r1
80804804:	e1a01006 	mov	r1, r6
80804808:	85823130 	strhi	r3, [r2, #304]	; 0x130
8080480c:	e1a02203 	lsl	r2, r3, #4
80804810:	e0823103 	add	r3, r2, r3, lsl #2
80804814:	e0800003 	add	r0, r0, r3
80804818:	ebffee39 	bl	80800104 <vListInsertEnd>

				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
8080481c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
80804820:	e3530000 	cmp	r3, #0
80804824:	0a000003 	beq	80804838 <xTaskGenericNotify+0x134>
80804828:	e3090998 	movw	r0, #39320	; 0x9998
8080482c:	e3011135 	movw	r1, #4405	; 0x1135
80804830:	e3480080 	movt	r0, #32896	; 0x8080
80804834:	eb0004e7 	bl	80805bd8 <vAssertCalled>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
80804838:	e5943000 	ldr	r3, [r4]
8080483c:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
80804840:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
80804844:	e1520003 	cmp	r2, r3
80804848:	9affffd2 	bls	80804798 <xTaskGenericNotify+0x94>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
8080484c:	e3a03a01 	mov	r3, #4096	; 0x1000
80804850:	e3443824 	movt	r3, #18468	; 0x4824
80804854:	e5932200 	ldr	r2, [r3, #512]	; 0x200
80804858:	e3120001 	tst	r2, #1
8080485c:	1affffcd 	bne	80804798 <xTaskGenericNotify+0x94>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80804860:	e3a01801 	mov	r1, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80804864:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80804868:	e2022003 	and	r2, r2, #3
8080486c:	e1a02211 	lsl	r2, r1, r2
80804870:	e3822001 	orr	r2, r2, #1
80804874:	e5832f00 	str	r2, [r3, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80804878:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
8080487c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804880:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804884:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804888:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080488c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804890:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804894:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804898:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080489c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048a0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048a4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048a8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048ac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048b0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048b4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048b8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048bc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048c0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048c4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048c8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048cc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048d0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048d4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048d8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048dc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048e0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048e4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048e8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048ec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808048f4:	e320f000 	nop	{0}
808048f8:	eaffffa6 	b	80804798 <xTaskGenericNotify+0x94>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
808048fc:	e5952058 	ldr	r2, [r5, #88]	; 0x58
80804900:	e1828008 	orr	r8, r2, r8
80804904:	e5858058 	str	r8, [r5, #88]	; 0x58
					break;
80804908:	eaffffa0 	b	80804790 <xTaskGenericNotify+0x8c>
8080490c:	ebfff3f0 	bl	808018d4 <vTaskExitCritical.part.7>
			}
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
80804910:	e1a00005 	mov	r0, r5
80804914:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
	{
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
80804918:	e3090998 	movw	r0, #39320	; 0x9998
8080491c:	e30110fd 	movw	r1, #4349	; 0x10fd
80804920:	e3480080 	movt	r0, #32896	; 0x8080
80804924:	eb0004ab 	bl	80805bd8 <vAssertCalled>
80804928:	eaffff7b 	b	8080471c <xTaskGenericNotify+0x18>

8080492c <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
8080492c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
80804930:	e2504000 	subs	r4, r0, #0
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
80804934:	e1a08001 	mov	r8, r1
80804938:	e1a05002 	mov	r5, r2
8080493c:	e1a06003 	mov	r6, r3
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
80804940:	0a000050 	beq	80804a88 <xTaskGenericNotifyFromISR+0x15c>
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80804944:	eb0001c7 	bl	80805068 <xPortSetInterruptMask>
		{
			if( pulPreviousNotificationValue != NULL )
80804948:	e3560000 	cmp	r6, #0
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
8080494c:	e3a01002 	mov	r1, #2

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
80804950:	15943058 	ldrne	r3, [r4, #88]	; 0x58
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
80804954:	e2452001 	sub	r2, r5, #1
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80804958:	e1a07000 	mov	r7, r0
		{
			if( pulPreviousNotificationValue != NULL )
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
8080495c:	15863000 	strne	r3, [r6]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
80804960:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
80804964:	e5c4105c 	strb	r1, [r4, #92]	; 0x5c
			if( pulPreviousNotificationValue != NULL )
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
80804968:	e6ef3073 	uxtb	r3, r3
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
8080496c:	e3520003 	cmp	r2, #3
80804970:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
80804974:	ea000007 	b	80804998 <xTaskGenericNotifyFromISR+0x6c>
80804978:	80804a3c 	.word	0x80804a3c
8080497c:	808049b4 	.word	0x808049b4
80804980:	80804994 	.word	0x80804994
80804984:	80804988 	.word	0x80804988
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80804988:	e3530002 	cmp	r3, #2
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
8080498c:	03a04000 	moveq	r4, #0
				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80804990:	0a000003 	beq	808049a4 <xTaskGenericNotifyFromISR+0x78>
					{
						pxTCB->ulNotifiedValue = ulValue;
80804994:	e5848058 	str	r8, [r4, #88]	; 0x58

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80804998:	e3530001 	cmp	r3, #1
8080499c:	0a000009 	beq	808049c8 <xTaskGenericNotifyFromISR+0x9c>
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
808049a0:	e3a04001 	mov	r4, #1
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
808049a4:	e1a00007 	mov	r0, r7
808049a8:	eb0001b4 	bl	80805080 <vPortClearInterruptMask>

		return xReturn;
	}
808049ac:	e1a00004 	mov	r0, r4
808049b0:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
808049b4:	e5942058 	ldr	r2, [r4, #88]	; 0x58

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
808049b8:	e3530001 	cmp	r3, #1
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
808049bc:	e2822001 	add	r2, r2, #1
808049c0:	e5842058 	str	r2, [r4, #88]	; 0x58

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
808049c4:	1afffff5 	bne	808049a0 <xTaskGenericNotifyFromISR+0x74>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
808049c8:	e5943028 	ldr	r3, [r4, #40]	; 0x28
808049cc:	e3530000 	cmp	r3, #0
808049d0:	0a000003 	beq	808049e4 <xTaskGenericNotifyFromISR+0xb8>
808049d4:	e3090998 	movw	r0, #39320	; 0x9998
808049d8:	e30111af 	movw	r1, #4527	; 0x11af
808049dc:	e3480080 	movt	r0, #32896	; 0x8080
808049e0:	eb00047c 	bl	80805bd8 <vAssertCalled>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
808049e4:	e30c5000 	movw	r5, #49152	; 0xc000
808049e8:	e3485080 	movt	r5, #32896	; 0x8080
808049ec:	e5953134 	ldr	r3, [r5, #308]	; 0x134
808049f0:	e3530000 	cmp	r3, #0
808049f4:	0a000014 	beq	80804a4c <xTaskGenericNotifyFromISR+0x120>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
808049f8:	e2841018 	add	r1, r4, #24
808049fc:	e28500fc 	add	r0, r5, #252	; 0xfc
80804a00:	ebffedbf 	bl	80800104 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
80804a04:	e5952000 	ldr	r2, [r5]
80804a08:	e30c3000 	movw	r3, #49152	; 0xc000
80804a0c:	e594102c 	ldr	r1, [r4, #44]	; 0x2c
80804a10:	e3483080 	movt	r3, #32896	; 0x8080
80804a14:	e592202c 	ldr	r2, [r2, #44]	; 0x2c
80804a18:	e1510002 	cmp	r1, r2
80804a1c:	9affffdf 	bls	808049a0 <xTaskGenericNotifyFromISR+0x74>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
80804a20:	e59d2018 	ldr	r2, [sp, #24]
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
80804a24:	e3a04001 	mov	r4, #1

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
80804a28:	e3520000 	cmp	r2, #0
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
80804a2c:	11a03002 	movne	r3, r2
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
80804a30:	05834138 	streq	r4, [r3, #312]	; 0x138
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
80804a34:	15834000 	strne	r4, [r3]
80804a38:	eaffffd9 	b	808049a4 <xTaskGenericNotifyFromISR+0x78>
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			switch( eAction )
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
80804a3c:	e5942058 	ldr	r2, [r4, #88]	; 0x58
80804a40:	e1828008 	orr	r8, r2, r8
80804a44:	e5848058 	str	r8, [r4, #88]	; 0x58
					break;
80804a48:	eaffffd2 	b	80804998 <xTaskGenericNotifyFromISR+0x6c>
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80804a4c:	e2846004 	add	r6, r4, #4
80804a50:	e1a00006 	mov	r0, r6
80804a54:	ebffedcb 	bl	80800188 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80804a58:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
80804a5c:	e30c000c 	movw	r0, #49164	; 0xc00c
80804a60:	e5952130 	ldr	r2, [r5, #304]	; 0x130
80804a64:	e3480080 	movt	r0, #32896	; 0x8080
80804a68:	e1a01006 	mov	r1, r6
80804a6c:	e1530002 	cmp	r3, r2
80804a70:	e1a02203 	lsl	r2, r3, #4
80804a74:	85853130 	strhi	r3, [r5, #304]	; 0x130
80804a78:	e0823103 	add	r3, r2, r3, lsl #2
80804a7c:	e0800003 	add	r0, r0, r3
80804a80:	ebffed9f 	bl	80800104 <vListInsertEnd>
80804a84:	eaffffde 	b	80804a04 <xTaskGenericNotifyFromISR+0xd8>
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
80804a88:	e3090998 	movw	r0, #39320	; 0x9998
80804a8c:	e3011168 	movw	r1, #4456	; 0x1168
80804a90:	e3480080 	movt	r0, #32896	; 0x8080
80804a94:	eb00044f 	bl	80805bd8 <vAssertCalled>
80804a98:	eaffffa9 	b	80804944 <xTaskGenericNotifyFromISR+0x18>

80804a9c <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
80804a9c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
80804aa0:	e2504000 	subs	r4, r0, #0
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
80804aa4:	e1a07001 	mov	r7, r1
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
80804aa8:	0a000039 	beq	80804b94 <vTaskNotifyGiveFromISR+0xf8>
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80804aac:	eb00016d 	bl	80805068 <xPortSetInterruptMask>
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
80804ab0:	e5d4205c 	ldrb	r2, [r4, #92]	; 0x5c
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
80804ab4:	e3a03002 	mov	r3, #2
80804ab8:	e5c4305c 	strb	r3, [r4, #92]	; 0x5c
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80804abc:	e1a06000 	mov	r6, r0
			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
80804ac0:	e5943058 	ldr	r3, [r4, #88]	; 0x58

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80804ac4:	e3520001 	cmp	r2, #1
			ucOriginalNotifyState = pxTCB->ucNotifyState;
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
80804ac8:	e2833001 	add	r3, r3, #1
80804acc:	e5843058 	str	r3, [r4, #88]	; 0x58

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80804ad0:	0a000002 	beq	80804ae0 <vTaskNotifyGiveFromISR+0x44>
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
80804ad4:	e1a00006 	mov	r0, r6
	}
80804ad8:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
80804adc:	ea000167 	b	80805080 <vPortClearInterruptMask>
			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
80804ae0:	e5943028 	ldr	r3, [r4, #40]	; 0x28
80804ae4:	e3530000 	cmp	r3, #0
80804ae8:	0a000003 	beq	80804afc <vTaskNotifyGiveFromISR+0x60>
80804aec:	e3090998 	movw	r0, #39320	; 0x9998
80804af0:	e3011209 	movw	r1, #4617	; 0x1209
80804af4:	e3480080 	movt	r0, #32896	; 0x8080
80804af8:	eb000436 	bl	80805bd8 <vAssertCalled>

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80804afc:	e30c5000 	movw	r5, #49152	; 0xc000
80804b00:	e3485080 	movt	r5, #32896	; 0x8080
80804b04:	e5953134 	ldr	r3, [r5, #308]	; 0x134
80804b08:	e3530000 	cmp	r3, #0
80804b0c:	0a000011 	beq	80804b58 <vTaskNotifyGiveFromISR+0xbc>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80804b10:	e2841018 	add	r1, r4, #24
80804b14:	e28500fc 	add	r0, r5, #252	; 0xfc
80804b18:	ebffed79 	bl	80800104 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
80804b1c:	e5952000 	ldr	r2, [r5]
80804b20:	e30c3000 	movw	r3, #49152	; 0xc000
80804b24:	e594102c 	ldr	r1, [r4, #44]	; 0x2c
80804b28:	e3483080 	movt	r3, #32896	; 0x8080
80804b2c:	e592202c 	ldr	r2, [r2, #44]	; 0x2c
80804b30:	e1510002 	cmp	r1, r2
80804b34:	9affffe6 	bls	80804ad4 <vTaskNotifyGiveFromISR+0x38>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
80804b38:	e3570000 	cmp	r7, #0
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
80804b3c:	e1a00006 	mov	r0, r6
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
80804b40:	13a03001 	movne	r3, #1
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
80804b44:	03a02001 	moveq	r2, #1
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
80804b48:	15873000 	strne	r3, [r7]
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
80804b4c:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
80804b50:	05832138 	streq	r2, [r3, #312]	; 0x138
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
80804b54:	ea000149 	b	80805080 <vPortClearInterruptMask>
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80804b58:	e2848004 	add	r8, r4, #4
80804b5c:	e1a00008 	mov	r0, r8
80804b60:	ebffed88 	bl	80800188 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80804b64:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
80804b68:	e30c000c 	movw	r0, #49164	; 0xc00c
80804b6c:	e5952130 	ldr	r2, [r5, #304]	; 0x130
80804b70:	e3480080 	movt	r0, #32896	; 0x8080
80804b74:	e1a01008 	mov	r1, r8
80804b78:	e1530002 	cmp	r3, r2
80804b7c:	e1a02203 	lsl	r2, r3, #4
80804b80:	85853130 	strhi	r3, [r5, #304]	; 0x130
80804b84:	e0823103 	add	r3, r2, r3, lsl #2
80804b88:	e0800003 	add	r0, r0, r3
80804b8c:	ebffed5c 	bl	80800104 <vListInsertEnd>
80804b90:	eaffffe1 	b	80804b1c <vTaskNotifyGiveFromISR+0x80>
	{
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	UBaseType_t uxSavedInterruptStatus;

		configASSERT( xTaskToNotify );
80804b94:	e3090998 	movw	r0, #39320	; 0x9998
80804b98:	e30111e3 	movw	r1, #4579	; 0x11e3
80804b9c:	e3480080 	movt	r0, #32896	; 0x8080
80804ba0:	eb00040c 	bl	80805bd8 <vAssertCalled>
80804ba4:	eaffffc0 	b	80804aac <vTaskNotifyGiveFromISR+0x10>

80804ba8 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
80804ba8:	e92d4070 	push	{r4, r5, r6, lr}
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
80804bac:	e30c4000 	movw	r4, #49152	; 0xc000
80804bb0:	e2505000 	subs	r5, r0, #0
80804bb4:	e3484080 	movt	r4, #32896	; 0x8080
80804bb8:	05945000 	ldreq	r5, [r4]

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskEnterCritical( void )
	{
		portDISABLE_INTERRUPTS();
80804bbc:	eb000129 	bl	80805068 <xPortSetInterruptMask>

		if( xSchedulerRunning != pdFALSE )
80804bc0:	e5942004 	ldr	r2, [r4, #4]
80804bc4:	e30c3000 	movw	r3, #49152	; 0xc000
80804bc8:	e3483080 	movt	r3, #32896	; 0x8080
80804bcc:	e3520000 	cmp	r2, #0
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804bd0:	15932000 	ldrne	r2, [r3]
			function so	assert() if it is being called from an interrupt
			context.  Only API functions that end in "FromISR" can be used in an
			interrupt.  Only assert if the critical nesting count is 1 to
			protect against recursive calls if the assert function also uses a
			critical section. */
			if( pxCurrentTCB->uxCriticalNesting == 1 )
80804bd4:	15933000 	ldrne	r3, [r3]
	{
		portDISABLE_INTERRUPTS();

		if( xSchedulerRunning != pdFALSE )
		{
			( pxCurrentTCB->uxCriticalNesting )++;
80804bd8:	15923044 	ldrne	r3, [r2, #68]	; 0x44
80804bdc:	12833001 	addne	r3, r3, #1
80804be0:	15823044 	strne	r3, [r2, #68]	; 0x44
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );

		taskENTER_CRITICAL();
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
80804be4:	e5d5305c 	ldrb	r3, [r5, #92]	; 0x5c
80804be8:	e3530002 	cmp	r3, #2
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
80804bec:	03a03000 	moveq	r3, #0
				xReturn = pdPASS;
80804bf0:	03a06001 	moveq	r6, #1

		taskENTER_CRITICAL();
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
80804bf4:	05c5305c 	strbeq	r3, [r5, #92]	; 0x5c
				xReturn = pdPASS;
			}
			else
			{
				xReturn = pdFAIL;
80804bf8:	13a06000 	movne	r6, #0

#if ( portCRITICAL_NESTING_IN_TCB == 1 )

	void vTaskExitCritical( void )
	{
		if( xSchedulerRunning != pdFALSE )
80804bfc:	e5942004 	ldr	r2, [r4, #4]
80804c00:	e30c3000 	movw	r3, #49152	; 0xc000
80804c04:	e3483080 	movt	r3, #32896	; 0x8080
80804c08:	e3520000 	cmp	r2, #0
80804c0c:	0a000003 	beq	80804c20 <xTaskNotifyStateClear+0x78>
		{
			if( pxCurrentTCB->uxCriticalNesting > 0U )
80804c10:	e5933000 	ldr	r3, [r3]
80804c14:	e5933044 	ldr	r3, [r3, #68]	; 0x44
80804c18:	e3530000 	cmp	r3, #0
80804c1c:	1a000001 	bne	80804c28 <xTaskNotifyStateClear+0x80>
			}
		}
		taskEXIT_CRITICAL();

		return xReturn;
	}
80804c20:	e1a00006 	mov	r0, r6
80804c24:	e8bd8070 	pop	{r4, r5, r6, pc}
80804c28:	ebfff329 	bl	808018d4 <vTaskExitCritical.part.7>
80804c2c:	e1a00006 	mov	r0, r6
80804c30:	e8bd8070 	pop	{r4, r5, r6, pc}

80804c34 <vPortYieldFromISR>:
	/* Nothing to do. */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
80804c34:	e92d4010 	push	{r4, lr}
	vTaskSwitchContext();
80804c38:	ebfffa82 	bl	80803648 <vTaskSwitchContext>
	portSGI_CLEAR_YIELD( portGIC_DISTRIBUTOR_BASE, portCORE_ID() );
80804c3c:	e3a03a01 	mov	r3, #4096	; 0x1000
80804c40:	e3a02001 	mov	r2, #1
80804c44:	e3443824 	movt	r3, #18468	; 0x4824
80804c48:	e5832280 	str	r2, [r3, #640]	; 0x280
80804c4c:	e8bd8010 	pop	{r4, pc}

80804c50 <vPortSysTickHandler>:
extern BaseType_t xTaskIncrementTick( void );

void vPortSysTickHandler( void *pvParameter )
{
	/* Clear the Interrupt. */
	*(portSYSTICK_INTERRUPT_STATUS) = 0x01UL;
80804c50:	e3a03000 	mov	r3, #0
80804c54:	e3a02001 	mov	r2, #1
80804c58:	e3443824 	movt	r3, #18468	; 0x4824
//  extern void vTaskIncrementTick( void );

extern BaseType_t xTaskIncrementTick( void );

void vPortSysTickHandler( void *pvParameter )
{
80804c5c:	e92d4010 	push	{r4, lr}
	/* Clear the Interrupt. */
	*(portSYSTICK_INTERRUPT_STATUS) = 0x01UL;
80804c60:	e583260c 	str	r2, [r3, #1548]	; 0x60c

	xTaskIncrementTick();
80804c64:	ebfff780 	bl	80802a6c <xTaskIncrementTick>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80804c68:	e3a01a01 	mov	r1, #4096	; 0x1000
80804c6c:	e3441824 	movt	r1, #18468	; 0x4824
80804c70:	e5913200 	ldr	r3, [r1, #512]	; 0x200
80804c74:	e3130001 	tst	r3, #1
80804c78:	18bd8010 	popne	{r4, pc}
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80804c7c:	e3a02801 	mov	r2, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80804c80:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80804c84:	e2033003 	and	r3, r3, #3
80804c88:	e1a03312 	lsl	r3, r2, r3
80804c8c:	e3833001 	orr	r3, r3, #1
80804c90:	e5813f00 	str	r3, [r1, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80804c94:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80804c98:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804c9c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804ca0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804ca4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804ca8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cac:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cb0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cb4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cb8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cbc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cc0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cc4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cc8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804ccc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cd0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cd4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cd8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cdc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804ce0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804ce4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804ce8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cf0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cf4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cf8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804cfc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804d00:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804d04:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804d08:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804d0c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80804d10:	e320f000 	nop	{0}
80804d14:	e8bd8010 	pop	{r4, pc}

80804d18 <itoa>:
extern unsigned long _ebss;
extern unsigned long _stack_top;
/*----------------------------------------------------------------------------*/

char *itoa( int iIn, char *pcBuffer )
{
80804d18:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
int iDivisor = 0;
int iResult = 0;
	for ( iDivisor = 100; iDivisor > 0; iDivisor /= 10 )
	{
		iResult = ( iIn / iDivisor ) % 10;
		*pcBuffer++ = (char)iResult + '0';
80804d1c:	e3064667 	movw	r4, #26215	; 0x6667
80804d20:	e308651f 	movw	r6, #34079	; 0x851f
extern unsigned long _ebss;
extern unsigned long _stack_top;
/*----------------------------------------------------------------------------*/

char *itoa( int iIn, char *pcBuffer )
{
80804d24:	e1a02000 	mov	r2, r0
int iDivisor = 0;
int iResult = 0;
	for ( iDivisor = 100; iDivisor > 0; iDivisor /= 10 )
	{
		iResult = ( iIn / iDivisor ) % 10;
		*pcBuffer++ = (char)iResult + '0';
80804d28:	e3464666 	movt	r4, #26214	; 0x6666
80804d2c:	e34561eb 	movt	r6, #20971	; 0x51eb
80804d30:	e0c98492 	smull	r8, r9, r2, r4
80804d34:	e1a03fc0 	asr	r3, r0, #31
80804d38:	e0c76690 	smull	r6, r7, r0, r6
	}
	return pcReturn;
}
80804d3c:	e1a00001 	mov	r0, r1
int iDivisor = 0;
int iResult = 0;
	for ( iDivisor = 100; iDivisor > 0; iDivisor /= 10 )
	{
		iResult = ( iIn / iDivisor ) % 10;
		*pcBuffer++ = (char)iResult + '0';
80804d40:	e063c2c7 	rsb	ip, r3, r7, asr #5
80804d44:	e0633149 	rsb	r3, r3, r9, asr #2
80804d48:	e0c7649c 	smull	r6, r7, ip, r4
80804d4c:	e1a0efc3 	asr	lr, r3, #31
80804d50:	e1a06fcc 	asr	r6, ip, #31
80804d54:	e0c54493 	smull	r4, r5, r3, r4
80804d58:	e0664147 	rsb	r4, r6, r7, asr #2
80804d5c:	e1a06183 	lsl	r6, r3, #3
80804d60:	e1a07184 	lsl	r7, r4, #3
80804d64:	e06ee145 	rsb	lr, lr, r5, asr #2
80804d68:	e0866083 	add	r6, r6, r3, lsl #1
80804d6c:	e0874084 	add	r4, r7, r4, lsl #1
80804d70:	e1a0518e 	lsl	r5, lr, #3
80804d74:	e0662002 	rsb	r2, r6, r2
80804d78:	e064c00c 	rsb	ip, r4, ip
80804d7c:	e085e08e 	add	lr, r5, lr, lsl #1
80804d80:	e28cc030 	add	ip, ip, #48	; 0x30
80804d84:	e2822030 	add	r2, r2, #48	; 0x30
80804d88:	e5c1c000 	strb	ip, [r1]
80804d8c:	e06e3003 	rsb	r3, lr, r3
80804d90:	e5c12002 	strb	r2, [r1, #2]
80804d94:	e2833030 	add	r3, r3, #48	; 0x30
80804d98:	e5c13001 	strb	r3, [r1, #1]
	}
	return pcReturn;
}
80804d9c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

80804da0 <pxPortInitialiseStack>:
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
portSTACK_TYPE *pxOriginalStack = pxTopOfStack;
	/* Align top of stack */
	pxTopOfStack = (portSTACK_TYPE *)((unsigned long)(pxTopOfStack)&~portBYTE_ALIGNMENT_MASK);
80804da0:	e3c03007 	bic	r3, r0, #7

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
80804da4:	e92d4010 	push	{r4, lr}
80804da8:	e1a0c000 	mov	ip, r0
portSTACK_TYPE *pxOriginalStack = pxTopOfStack;
	/* Align top of stack */
	pxTopOfStack = (portSTACK_TYPE *)((unsigned long)(pxTopOfStack)&~portBYTE_ALIGNMENT_MASK);
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
80804dac:	e3a0401f 	mov	r4, #31
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0;	/* LR */
80804db0:	e3a0e000 	mov	lr, #0
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxOriginalStack;	/* SP */
	pxTopOfStack -= 12;		/* R1 through R12 */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
80804db4:	e1a00003 	mov	r0, r3
	pxTopOfStack = (portSTACK_TYPE *)((unsigned long)(pxTopOfStack)&~portBYTE_ALIGNMENT_MASK);
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
80804db8:	e5031004 	str	r1, [r3, #-4]
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0;	/* LR */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxOriginalStack;	/* SP */
80804dbc:	e503c00c 	str	ip, [r3, #-12]
portSTACK_TYPE *pxOriginalStack = pxTopOfStack;
	/* Align top of stack */
	pxTopOfStack = (portSTACK_TYPE *)((unsigned long)(pxTopOfStack)&~portBYTE_ALIGNMENT_MASK);
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
80804dc0:	e5834000 	str	r4, [r3]
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0;	/* LR */
80804dc4:	e503e008 	str	lr, [r3, #-8]
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pxOriginalStack;	/* SP */
	pxTopOfStack -= 12;		/* R1 through R12 */
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
80804dc8:	e5202040 	str	r2, [r0, #-64]!	; 0xffffffc0

	return pxTopOfStack;
}
80804dcc:	e8bd8010 	pop	{r4, pc}

80804dd0 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile(
80804dd0:	e59f9018 	ldr	r9, [pc, #24]	; 80804df0 <pxCurrentTCBConst2>
80804dd4:	e5998000 	ldr	r8, [r9]
80804dd8:	e598e000 	ldr	lr, [r8]
80804ddc:	e8de7fff 	ldm	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
80804de0:	e28ee03c 	add	lr, lr, #60	; 0x3c
80804de4:	e320f000 	nop	{0}
80804de8:	f89e0a00 	rfeia	lr
80804dec:	e320f000 	nop	{0}

80804df0 <pxCurrentTCBConst2>:
80804df0:	8080c000 	.word	0x8080c000

80804df4 <vPortInterruptContext>:
}
/*-----------------------------------------------------------*/

void vPortInterruptContext( void )
{
	__asm volatile(
80804df4:	e24ee004 	sub	lr, lr, #4
80804df8:	f94d051f 	srsdb	sp, #31
80804dfc:	e94d2000 	stmdb	sp, {sp}^
80804e00:	e24dd004 	sub	sp, sp, #4
80804e04:	e8bd4000 	ldmfd	sp!, {lr}
80804e08:	e24ee008 	sub	lr, lr, #8
80804e0c:	e94e7fff 	stmdb	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
80804e10:	e24ee03c 	sub	lr, lr, #60	; 0x3c
80804e14:	e51f902c 	ldr	r9, [pc, #-44]	; 80804df0 <pxCurrentTCBConst2>
80804e18:	e5998000 	ldr	r8, [r9]
80804e1c:	e588e000 	str	lr, [r8]
80804e20:	eb00007f 	bl	80805024 <vPortGICInterruptHandler>
80804e24:	e5998000 	ldr	r8, [r9]
80804e28:	e598e000 	ldr	lr, [r8]
80804e2c:	e8de7fff 	ldm	lr, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
80804e30:	e28ee03c 	add	lr, lr, #60	; 0x3c
80804e34:	f89e0a00 	rfeia	lr
80804e38:	e320f000 	nop	{0}

80804e3c <vPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
80804e3c:	e30c3000 	movw	r3, #49152	; 0xc000
80804e40:	e30023fc 	movw	r2, #1020	; 0x3fc
80804e44:	e3483080 	movt	r3, #32896	; 0x8080
80804e48:	e3482081 	movt	r2, #32897	; 0x8081
80804e4c:	e5933000 	ldr	r3, [r3]
80804e50:	e1a0d002 	mov	sp, r2
80804e54:	ef000000 	svc	0x00000000
80804e58:	e320f000 	nop	{0}

80804e5c <vPortSMCHandler>:
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804e5c:	e3a03a01 	mov	r3, #4096	; 0x1000

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
80804e60:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804e64:	e3443824 	movt	r3, #18468	; 0x4824

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804e68:	e3a04001 	mov	r4, #1
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80804e6c:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804e70:	e593ec04 	ldr	lr, [r3, #3076]	; 0xc04

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804e74:	e2022003 	and	r2, r2, #3
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804e78:	e5930004 	ldr	r0, [r3, #4]

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804e7c:	e1a02214 	lsl	r2, r4, r2
{
	/* Install the interrupt handler. */
	vPortInstallInterruptHandler( vPortSysTickHandler, NULL, portSYSTICK_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Configure SysTick to interrupt at the requested rate. */
	*(portSYSTICK_LOAD) = (configCPU_PERIPH_HZ / (portSYSTICK_PRESCALE+1) / configTICK_RATE_HZ ) - 1UL;
80804e80:	e3a01000 	mov	r1, #0
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
		{
			portGIC_SET( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804e84:	e5936280 	ldr	r6, [r3, #640]	; 0x280
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804e88:	e300c000 	movw	ip, #0
80804e8c:	e3047c50 	movw	r7, #19536	; 0x4c50
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804e90:	e18ee000 	orr	lr, lr, r0

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804e94:	e1a02402 	lsl	r2, r2, #8

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
		pxInterruptHandlers[ ulVector ].pvParameter = pvParameter;
80804e98:	e1a00001 	mov	r0, r1

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
		{
			portGIC_SET( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
			portGIC_SET( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804e9c:	e5935100 	ldr	r5, [r3, #256]	; 0x100
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804ea0:	e348c081 	movt	ip, #32897	; 0x8081
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804ea4:	e38ee302 	orr	lr, lr, #134217728	; 0x8000000
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804ea8:	e3487080 	movt	r7, #32896	; 0x8080
		pxInterruptHandlers[ ulVector ].pvParameter = pvParameter;
80804eac:	e58c04ec 	str	r0, [ip, #1260]	; 0x4ec
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804eb0:	e58c74e8 	str	r7, [ip, #1256]	; 0x4e8
{
	/* Install the interrupt handler. */
	vPortInstallInterruptHandler( vPortSysTickHandler, NULL, portSYSTICK_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Configure SysTick to interrupt at the requested rate. */
	*(portSYSTICK_LOAD) = (configCPU_PERIPH_HZ / (portSYSTICK_PRESCALE+1) / configTICK_RATE_HZ ) - 1UL;
80804eb4:	e3441824 	movt	r1, #18468	; 0x4824
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804eb8:	e583ec04 	str	lr, [r3, #3076]	; 0xc04

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804ebc:	e2022cff 	and	r2, r2, #65280	; 0xff00
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
		}

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );
80804ec0:	e3a08903 	mov	r8, #49152	; 0xc000
{
	/* Install the interrupt handler. */
	vPortInstallInterruptHandler( vPortSysTickHandler, NULL, portSYSTICK_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Configure SysTick to interrupt at the requested rate. */
	*(portSYSTICK_LOAD) = (configCPU_PERIPH_HZ / (portSYSTICK_PRESCALE+1) / configTICK_RATE_HZ ) - 1UL;
80804ec4:	e3007dab 	movw	r7, #3499	; 0xdab
	*(portSYSTICK_CONTROL) = ( portSYSTICK_PRESCALE << 8 ) | portSYSTICK_CTRL_ENABLE_PERIODIC_INTERRUPTS;
80804ec8:	e306e307 	movw	lr, #25351	; 0x6307

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804ecc:	e583281c 	str	r2, [r3, #2076]	; 0x81c
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
		}

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );
80804ed0:	e583841c 	str	r8, [r3, #1052]	; 0x41c
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
		{
			portGIC_SET( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804ed4:	e3866222 	orr	r6, r6, #536870914	; 0x20000002
{
	/* Install the interrupt handler. */
	vPortInstallInterruptHandler( vPortSysTickHandler, NULL, portSYSTICK_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Configure SysTick to interrupt at the requested rate. */
	*(portSYSTICK_LOAD) = (configCPU_PERIPH_HZ / (portSYSTICK_PRESCALE+1) / configTICK_RATE_HZ ) - 1UL;
80804ed8:	e5817600 	str	r7, [r1, #1536]	; 0x600
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804edc:	e3047c34 	movw	r7, #19508	; 0x4c34
	/* Install the interrupt handler. */
	vPortInstallInterruptHandler( vPortSysTickHandler, NULL, portSYSTICK_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Configure SysTick to interrupt at the requested rate. */
	*(portSYSTICK_LOAD) = (configCPU_PERIPH_HZ / (portSYSTICK_PRESCALE+1) / configTICK_RATE_HZ ) - 1UL;
	*(portSYSTICK_CONTROL) = ( portSYSTICK_PRESCALE << 8 ) | portSYSTICK_CTRL_ENABLE_PERIODIC_INTERRUPTS;
80804ee0:	e581e608 	str	lr, [r1, #1544]	; 0x608
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804ee4:	e3487080 	movt	r7, #32896	; 0x8080
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804ee8:	e593ac00 	ldr	sl, [r3, #3072]	; 0xc00

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
		{
			portGIC_SET( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
			portGIC_SET( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804eec:	e3855222 	orr	r5, r5, #536870914	; 0x20000002
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804ef0:	e593e000 	ldr	lr, [r3]
	vPortInstallInterruptHandler( (void (*)(void *))vPortYieldFromISR, NULL, portSGI_YIELD_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Finally, allow the GIC to pass interrupts to the processor. */
	portGIC_WRITE( portGIC_ICDDCR(portGIC_DISTRIBUTOR_BASE), 0x01UL );
	portGIC_WRITE( portGIC_ICCBPR(portGIC_PRIVATE_BASE), 0x00UL );
	portGIC_WRITE( portGIC_ICCPMR(portGIC_PRIVATE_BASE), configLOWEST_INTERRUPT_PRIORITY );
80804ef4:	e3a090ff 	mov	r9, #255	; 0xff

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
		pxInterruptHandlers[ ulVector ].pvParameter = pvParameter;
80804ef8:	e58c040c 	str	r0, [ip, #1036]	; 0x40c
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804efc:	e58c7408 	str	r7, [ip, #1032]	; 0x408
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804f00:	e18ac00e 	orr	ip, sl, lr

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804f04:	e5832800 	str	r2, [r3, #2048]	; 0x800
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804f08:	e38c2008 	orr	r2, ip, #8
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
		{
			portGIC_SET( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804f0c:	e5836280 	str	r6, [r3, #640]	; 0x280
			portGIC_SET( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804f10:	e5835100 	str	r5, [r3, #256]	; 0x100
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
		}

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );
80804f14:	e5838400 	str	r8, [r3, #1024]	; 0x400
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804f18:	e5832c00 	str	r2, [r3, #3072]	; 0xc00

	/* Install the interrupt handler. */
	vPortInstallInterruptHandler( (void (*)(void *))vPortYieldFromISR, NULL, portSGI_YIELD_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Finally, allow the GIC to pass interrupts to the processor. */
	portGIC_WRITE( portGIC_ICDDCR(portGIC_DISTRIBUTOR_BASE), 0x01UL );
80804f1c:	e5834000 	str	r4, [r3]
	portGIC_WRITE( portGIC_ICCBPR(portGIC_PRIVATE_BASE), 0x00UL );
80804f20:	e5810108 	str	r0, [r1, #264]	; 0x108
	portGIC_WRITE( portGIC_ICCPMR(portGIC_PRIVATE_BASE), configLOWEST_INTERRUPT_PRIORITY );
	portGIC_WRITE( portGIC_ICCICR(portGIC_PRIVATE_BASE), 0x01UL );
80804f24:	e5814100 	str	r4, [r1, #256]	; 0x100
	vPortInstallInterruptHandler( (void (*)(void *))vPortYieldFromISR, NULL, portSGI_YIELD_VECTOR_ID, pdTRUE, /* configMAX_SYSCALL_INTERRUPT_PRIORITY */ configKERNEL_INTERRUPT_PRIORITY, 1<<portCORE_ID() );

	/* Finally, allow the GIC to pass interrupts to the processor. */
	portGIC_WRITE( portGIC_ICDDCR(portGIC_DISTRIBUTOR_BASE), 0x01UL );
	portGIC_WRITE( portGIC_ICCBPR(portGIC_PRIVATE_BASE), 0x00UL );
	portGIC_WRITE( portGIC_ICCPMR(portGIC_PRIVATE_BASE), configLOWEST_INTERRUPT_PRIORITY );
80804f28:	e5819104 	str	r9, [r1, #260]	; 0x104
	portGIC_WRITE( portGIC_ICCPMR(portGIC_QUATERNARY_BASE), configLOWEST_INTERRUPT_PRIORITY );
	portGIC_WRITE( portGIC_ICCICR(portGIC_QUATERNARY_BASE), 0x01UL );
#endif /* configPLATFORM */

	/* Start the first task. */
	vPortStartFirstTask();
80804f2c:	ebffffc2 	bl	80804e3c <vPortStartFirstTask>

	/* Should not get here! */
	return 0;
}
80804f30:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}

80804f34 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
80804f34:	e12fff1e 	bx	lr

80804f38 <vPortInstallInterruptHandler>:
	else if ( ulVector < 160 )
	{
		puxGICAddress = portGIC_QUATERNARY_BASE;
	}
#elif configPLATFORM == 2 || configPLATFORM == 3
	if ( ulVector < 32 )
80804f38:	e352001f 	cmp	r2, #31
#endif /* configPLATFORM */
}
/*-----------------------------------------------------------*/

void vPortInstallInterruptHandler( void (*vHandler)(void *), void *pvParameter, unsigned long ulVector, unsigned char ucEdgeTriggered, unsigned char ucPriority, unsigned char ucProcessorTargets )
{
80804f3c:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
80804f40:	e5dde01c 	ldrb	lr, [sp, #28]
80804f44:	e5dd7020 	ldrb	r7, [sp, #32]
	else if ( ulVector < 160 )
	{
		puxGICAddress = portGIC_QUATERNARY_BASE;
	}
#elif configPLATFORM == 2 || configPLATFORM == 3
	if ( ulVector < 32 )
80804f48:	9a000000 	bls	80804f50 <vPortInstallInterruptHandler+0x18>
80804f4c:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804f50:	e300c000 	movw	ip, #0

		/* First make the Interrupt a Secure one. */
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
80804f54:	e3530000 	cmp	r3, #0
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804f58:	e348c081 	movt	ip, #32897	; 0x8081
		pxInterruptHandlers[ ulVector ].pvParameter = pvParameter;

		/* Now calculate all of the offsets for the specific GIC. */
		ulBank32 = 4 * ( ulVector / 32 );
		ulOffset32 = ulVector % 32;
		ulBank4 = 4 * ( ulVector / 4 );
80804f5c:	e3c26003 	bic	r6, r2, #3
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804f60:	e08cc182 	add	ip, ip, r2, lsl #3

		/* Now calculate all of the offsets for the specific GIC. */
		ulBank32 = 4 * ( ulVector / 32 );
		ulOffset32 = ulVector % 32;
		ulBank4 = 4 * ( ulVector / 4 );
		ulOffset4 = ulVector % 4;
80804f64:	e2023003 	and	r3, r2, #3
	}

	/* Record the Handler. */
	if (ulVector < ulMaxVectorId )
	{
		pxInterruptHandlers[ ulVector ].vHandler = vHandler;
80804f68:	e58c0400 	str	r0, [ip, #1024]	; 0x400
		pxInterruptHandlers[ ulVector ].pvParameter = pvParameter;
80804f6c:	e58c1404 	str	r1, [ip, #1028]	; 0x404

		/* First make the Interrupt a Secure one. */
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
80804f70:	0a00000c 	beq	80804fa8 <vPortInstallInterruptHandler+0x70>
		/* Now calculate all of the offsets for the specific GIC. */
		ulBank32 = 4 * ( ulVector / 32 );
		ulOffset32 = ulVector % 32;
		ulBank4 = 4 * ( ulVector / 4 );
		ulOffset4 = ulVector % 4;
		ulBank16 = 4 * ( ulVector / 16 );
80804f74:	e1a08222 	lsr	r8, r2, #4
	//	*(portGIC_ICDISR_BASE(puxGICDistributorAddress) + ulBank32) &= ~( 1 << ulOffset32 );

		/* Is it Edge Triggered?. */
		if ( 0 != ucEdgeTriggered )
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
80804f78:	e3a01b07 	mov	r1, #7168	; 0x1c00
80804f7c:	e3a0ca01 	mov	ip, #4096	; 0x1000
80804f80:	e3441824 	movt	r1, #18468	; 0x4824
80804f84:	e344c824 	movt	ip, #18468	; 0x4824
80804f88:	e79cc108 	ldr	ip, [ip, r8, lsl #2]
80804f8c:	e202500f 	and	r5, r2, #15
80804f90:	e7914108 	ldr	r4, [r1, r8, lsl #2]
80804f94:	e1a05085 	lsl	r5, r5, #1
80804f98:	e3a09002 	mov	r9, #2
80804f9c:	e18c4004 	orr	r4, ip, r4
80804fa0:	e184c519 	orr	ip, r4, r9, lsl r5
80804fa4:	e781c108 	str	ip, [r1, r8, lsl #2]
		}

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );
80804fa8:	e1a01183 	lsl	r1, r3, #3
80804fac:	e3a03a01 	mov	r3, #4096	; 0x1000
80804fb0:	e3443824 	movt	r3, #18468	; 0x4824
80804fb4:	e1a0e11e 	lsl	lr, lr, r1

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
80804fb8:	e3500000 	cmp	r0, #0

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804fbc:	e1a01117 	lsl	r1, r7, r1
		{
			portGIC_SET( (portGIC_ICDICR_BASE(puxGICDistributorAddress + ulBank16) ), ( portGIC_READ(puxGICDistributorAddress + ulBank16) | ( 0x02 << ( ulOffset16 * 2 ) ) ) );
		}

		/* Set the Priority. */
		portGIC_WRITE( portGIC_ICDIPR_BASE(puxGICDistributorAddress) + ulBank4, ( ( (unsigned long)ucPriority ) << ( ulOffset4 * 8 ) ) );
80804fc0:	e0863003 	add	r3, r6, r3
80804fc4:	e583e400 	str	lr, [r3, #1024]	; 0x400

		/* Set the targeted Processors. */
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );
80804fc8:	e5831800 	str	r1, [r3, #2048]	; 0x800

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
80804fcc:	0a00000c 	beq	80805004 <vPortInstallInterruptHandler+0xcc>
		{
			portGIC_SET( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804fd0:	e3a01d4a 	mov	r1, #4736	; 0x1280
80804fd4:	e3a03001 	mov	r3, #1
80804fd8:	e3441824 	movt	r1, #18468	; 0x4824
80804fdc:	e1a02213 	lsl	r2, r3, r2
80804fe0:	e5910000 	ldr	r0, [r1]
			portGIC_SET( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804fe4:	e3a03c11 	mov	r3, #4352	; 0x1100
80804fe8:	e3443824 	movt	r3, #18468	; 0x4824
		portGIC_WRITE( portGIC_ICDIPTR_BASE(puxGICDistributorAddress + ulBank4), ( ( (unsigned long)ucProcessorTargets ) << ( ulOffset4 * 8 ) ) );

		/* Enable the Interrupt. */
		if ( NULL != vHandler )
		{
			portGIC_SET( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804fec:	e1800002 	orr	r0, r0, r2
80804ff0:	e5810000 	str	r0, [r1]
			portGIC_SET( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80804ff4:	e5931000 	ldr	r1, [r3]
80804ff8:	e1812002 	orr	r2, r1, r2
80804ffc:	e5832000 	str	r2, [r3]
80805000:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}
		}
		else
		{
			/* Or disable when passed a NULL handler. */
			portGIC_CLEAR( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80805004:	e3a02d4a 	mov	r2, #4736	; 0x1280
			portGIC_CLEAR( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80805008:	e3a03c11 	mov	r3, #4352	; 0x1100
			portGIC_SET( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
		}
		else
		{
			/* Or disable when passed a NULL handler. */
			portGIC_CLEAR( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
8080500c:	e3a00000 	mov	r0, #0
80805010:	e3442824 	movt	r2, #18468	; 0x4824
			portGIC_CLEAR( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80805014:	e3443824 	movt	r3, #18468	; 0x4824
			portGIC_SET( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
		}
		else
		{
			/* Or disable when passed a NULL handler. */
			portGIC_CLEAR( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDICPR_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
80805018:	e5820000 	str	r0, [r2]
			portGIC_CLEAR( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32), ( portGIC_READ( portGIC_ICDISER_BASE(puxGICDistributorAddress + ulBank32) ) | ( 1 << ulOffset32 ) ) );
8080501c:	e5830000 	str	r0, [r3]
		}
	}
}
80805020:	e8bd83f0 	pop	{r4, r5, r6, r7, r8, r9, pc}

80805024 <vPortGICInterruptHandler>:
/*----------------------------------------------------------------------------*/

void vPortGICInterruptHandler( void )
{
80805024:	e92d4070 	push	{r4, r5, r6, lr}
unsigned long ulVector = 0UL;
unsigned long ulGICBaseAddress = portGIC_PRIVATE_BASE;

	/* Query the private address first. */
	ulVector = portGIC_READ( portGIC_ICCIAR(portGIC_PRIVATE_BASE) );
80805028:	e3a04000 	mov	r4, #0
8080502c:	e3444824 	movt	r4, #18468	; 0x4824
80805030:	e594510c 	ldr	r5, [r4, #268]	; 0x10c
		ulVector = portGIC_READ( portGIC_ICCIAR(portGIC_QUATERNARY_BASE) ) + 128;
		ulGICBaseAddress = portGIC_QUATERNARY_BASE;
	}
#endif /* configPLATFORM */

	if ( ( ( ulVector & portGIC_VECTOR_MASK ) < ulMaxVectorId ) && ( NULL != pxInterruptHandlers[ ( ulVector & portGIC_VECTOR_MASK ) ].vHandler ) )
80805034:	e7e92055 	ubfx	r2, r5, #0, #10
80805038:	e352001f 	cmp	r2, #31
8080503c:	88bd8070 	pophi	{r4, r5, r6, pc}
80805040:	e3003000 	movw	r3, #0
80805044:	e3483081 	movt	r3, #32897	; 0x8081
80805048:	e0833182 	add	r3, r3, r2, lsl #3
8080504c:	e5932400 	ldr	r2, [r3, #1024]	; 0x400
80805050:	e3520000 	cmp	r2, #0
80805054:	08bd8070 	popeq	{r4, r5, r6, pc}
	{
		/* Call the associated handler. */
		pxInterruptHandlers[ ( ulVector & portGIC_VECTOR_MASK ) ].vHandler( pxInterruptHandlers[ ( ulVector & portGIC_VECTOR_MASK ) ].pvParameter );
80805058:	e5930404 	ldr	r0, [r3, #1028]	; 0x404
8080505c:	e12fff32 	blx	r2
		/* And acknowledge the interrupt. */
		portGIC_WRITE( portGIC_ICCEOIR(ulGICBaseAddress), ulVector );
80805060:	e5845110 	str	r5, [r4, #272]	; 0x110
80805064:	e8bd8070 	pop	{r4, r5, r6, pc}

80805068 <xPortSetInterruptMask>:
}
/*----------------------------------------------------------------------------*/

portBASE_TYPE xPortSetInterruptMask( void )
{
portBASE_TYPE xPriorityMask = portGIC_READ( portGIC_ICCPMR(portGIC_PRIVATE_BASE) );
80805068:	e3a03000 	mov	r3, #0
	portGIC_WRITE( portGIC_ICCPMR(portGIC_PRIVATE_BASE), configMAX_SYSCALL_INTERRUPT_PRIORITY );
8080506c:	e3a020a0 	mov	r2, #160	; 0xa0
}
/*----------------------------------------------------------------------------*/

portBASE_TYPE xPortSetInterruptMask( void )
{
portBASE_TYPE xPriorityMask = portGIC_READ( portGIC_ICCPMR(portGIC_PRIVATE_BASE) );
80805070:	e3443824 	movt	r3, #18468	; 0x4824
80805074:	e5930104 	ldr	r0, [r3, #260]	; 0x104
	portGIC_WRITE( portGIC_ICCPMR(portGIC_PRIVATE_BASE), configMAX_SYSCALL_INTERRUPT_PRIORITY );
80805078:	e5832104 	str	r2, [r3, #260]	; 0x104
#if configPLATFORM == 1
	portGIC_WRITE( portGIC_ICCPMR(portGIC_PRIMARY_BASE), configMAX_SYSCALL_INTERRUPT_PRIORITY );
	portGIC_WRITE( portGIC_ICCPMR(portGIC_SECONDARY_BASE), configMAX_SYSCALL_INTERRUPT_PRIORITY );
#endif /* configPLATFORM */
	return xPriorityMask;
}
8080507c:	e12fff1e 	bx	lr

80805080 <vPortClearInterruptMask>:
/*----------------------------------------------------------------------------*/

void vPortClearInterruptMask( portBASE_TYPE xPriorityMask )
{
	portGIC_WRITE( portGIC_ICCPMR(portGIC_PRIVATE_BASE), xPriorityMask );
80805080:	e3a03000 	mov	r3, #0
80805084:	e3443824 	movt	r3, #18468	; 0x4824
80805088:	e5830104 	str	r0, [r3, #260]	; 0x104
8080508c:	e12fff1e 	bx	lr

80805090 <vPortUnknownInterruptHandler>:
#endif /* configPLATFORM */
}
/*----------------------------------------------------------------------------*/

void vPortUnknownInterruptHandler( void *pvParameter )
{
80805090:	e12fff1e 	bx	lr

80805094 <kputc>:
void kputc(char c)
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
80805094:	e350000a 	cmp	r0, #10
80805098:	0a000008 	beq	808050c0 <kputc+0x2c>
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
8080509c:	e3a01000 	mov	r1, #0
808050a0:	e3441802 	movt	r1, #18434	; 0x4802
808050a4:	e5912014 	ldr	r2, [r1, #20]
808050a8:	e3a03000 	mov	r3, #0
808050ac:	e3443802 	movt	r3, #18434	; 0x4802
808050b0:	e3120020 	tst	r2, #32
808050b4:	0afffffa 	beq	808050a4 <kputc+0x10>
    *thr = c;
808050b8:	e5830000 	str	r0, [r3]
808050bc:	e12fff1e 	bx	lr
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
        while (!(*lsr & 0x20));
808050c0:	e3a01000 	mov	r1, #0
808050c4:	e3441802 	movt	r1, #18434	; 0x4802
808050c8:	e5912014 	ldr	r2, [r1, #20]
808050cc:	e3a03000 	mov	r3, #0
808050d0:	e3443802 	movt	r3, #18434	; 0x4802
808050d4:	e3120020 	tst	r2, #32
808050d8:	0afffffa 	beq	808050c8 <kputc+0x34>
        *thr = '\r';
808050dc:	e3a0200d 	mov	r2, #13
808050e0:	e5832000 	str	r2, [r3]
808050e4:	eaffffec 	b	8080509c <kputc+0x8>

808050e8 <kputhex>:
    *thr = c;
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
808050e8:	e3510000 	cmp	r1, #0
808050ec:	d12fff1e 	bxle	lr
808050f0:	e2411001 	sub	r1, r1, #1
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
808050f4:	e3a02000 	mov	r2, #0
808050f8:	e3442802 	movt	r2, #18434	; 0x4802
808050fc:	e1a0c101 	lsl	ip, r1, #2
    *thr = c;
}

void kputhex(unsigned int value, int digits)
{
80805100:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
80805104:	e1a0e002 	mov	lr, r2
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
        unsigned int tmp = (value >> (4 * digits)) & 0xf;
80805108:	e1a03c30 	lsr	r3, r0, ip
8080510c:	e203300f 	and	r3, r3, #15
        kputc(tmp > 9 ? tmp - 10 + 'a' : tmp + '0');
80805110:	e3530009 	cmp	r3, #9
80805114:	82831057 	addhi	r1, r3, #87	; 0x57
80805118:	92831030 	addls	r1, r3, #48	; 0x30
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
8080511c:	e5923014 	ldr	r3, [r2, #20]
80805120:	e3130020 	tst	r3, #32
80805124:	0afffffc 	beq	8080511c <kputhex+0x34>
80805128:	e24cc004 	sub	ip, ip, #4
    *thr = c;
8080512c:	e58e1000 	str	r1, [lr]
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
80805130:	e37c0004 	cmn	ip, #4
80805134:	1afffff3 	bne	80805108 <kputhex+0x20>
80805138:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

8080513c <kputs>:
    }
}

void kputs(char *s)
{
    while (*s) {
8080513c:	e5d01000 	ldrb	r1, [r0]
80805140:	e3510000 	cmp	r1, #0
80805144:	012fff1e 	bxeq	lr
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
        while (!(*lsr & 0x20));
80805148:	e3a02000 	mov	r2, #0
        kputc(tmp > 9 ? tmp - 10 + 'a' : tmp + '0');
    }
}

void kputs(char *s)
{
8080514c:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
        while (!(*lsr & 0x20));
80805150:	e3442802 	movt	r2, #18434	; 0x4802
        *thr = '\r';
80805154:	e3a0e00d 	mov	lr, #13
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
        while (!(*lsr & 0x20));
80805158:	e1a0c002 	mov	ip, r2
void kputc(char c)
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
8080515c:	e351000a 	cmp	r1, #10
80805160:	0a000007 	beq	80805184 <kputs+0x48>
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
80805164:	e5923014 	ldr	r3, [r2, #20]
80805168:	e3130020 	tst	r3, #32
8080516c:	0afffffc 	beq	80805164 <kputs+0x28>
    *thr = c;
80805170:	e58c1000 	str	r1, [ip]
    }
}

void kputs(char *s)
{
    while (*s) {
80805174:	e5f01001 	ldrb	r1, [r0, #1]!
80805178:	e3510000 	cmp	r1, #0
8080517c:	1afffff6 	bne	8080515c <kputs+0x20>
80805180:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
        while (!(*lsr & 0x20));
80805184:	e5923014 	ldr	r3, [r2, #20]
80805188:	e3130020 	tst	r3, #32
8080518c:	0afffffc 	beq	80805184 <kputs+0x48>
        *thr = '\r';
80805190:	e58ce000 	str	lr, [ip]
80805194:	eafffff2 	b	80805164 <kputs+0x28>

80805198 <_init>:
    }

    while (!(*lsr & 0x20));
80805198:	e3a01000 	mov	r1, #0
        kputc(*s++);
    }
}

void _init(void)
{
8080519c:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
extern int main( void );
int i;
unsigned long *pulSrc, *pulDest;
volatile unsigned long ulSCTLR = 0UL;
808051a0:	e1a03001 	mov	r3, r1
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
808051a4:	e3441802 	movt	r1, #18434	; 0x4802
        kputc(*s++);
    }
}

void _init(void)
{
808051a8:	e24dd008 	sub	sp, sp, #8
extern int main( void );
int i;
unsigned long *pulSrc, *pulDest;
volatile unsigned long ulSCTLR = 0UL;
808051ac:	e58d3004 	str	r3, [sp, #4]
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
808051b0:	e5912014 	ldr	r2, [r1, #20]
808051b4:	e3a03000 	mov	r3, #0
808051b8:	e3443802 	movt	r3, #18434	; 0x4802
808051bc:	e3120020 	tst	r2, #32
808051c0:	0afffffa 	beq	808051b0 <_init+0x18>
     *pulDest++ = *pulSrc++;
     }*/

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
808051c4:	e308c124 	movw	ip, #33060	; 0x8124
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
808051c8:	e1a02003 	mov	r2, r3
     *pulDest++ = *pulSrc++;
     }*/

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
808051cc:	e348c101 	movt	ip, #33025	; 0x8101
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
808051d0:	e1a04003 	mov	r4, r3
     *pulDest++ = *pulSrc++;
     }*/

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
808051d4:	e1a0e00c 	mov	lr, ip
808051d8:	e3a0001c 	mov	r0, #28
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
    *thr = c;
808051dc:	e3a01023 	mov	r1, #35	; 0x23
808051e0:	e5831000 	str	r1, [r3]
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
        unsigned int tmp = (value >> (4 * digits)) & 0xf;
808051e4:	e1a0303e 	lsr	r3, lr, r0
808051e8:	e203300f 	and	r3, r3, #15
        kputc(tmp > 9 ? tmp - 10 + 'a' : tmp + '0');
808051ec:	e3530009 	cmp	r3, #9
808051f0:	82831057 	addhi	r1, r3, #87	; 0x57
808051f4:	92831030 	addls	r1, r3, #48	; 0x30
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
808051f8:	e5923014 	ldr	r3, [r2, #20]
808051fc:	e3130020 	tst	r3, #32
80805200:	0afffffc 	beq	808051f8 <_init+0x60>
80805204:	e2400004 	sub	r0, r0, #4
    *thr = c;
80805208:	e5841000 	str	r1, [r4]
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
8080520c:	e3700004 	cmn	r0, #4
80805210:	1afffff3 	bne	808051e4 <_init+0x4c>
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
80805214:	e3a01000 	mov	r1, #0
80805218:	e3441802 	movt	r1, #18434	; 0x4802
8080521c:	e5912014 	ldr	r2, [r1, #20]
80805220:	e3a03000 	mov	r3, #0
80805224:	e3443802 	movt	r3, #18434	; 0x4802
80805228:	e3120020 	tst	r2, #32
8080522c:	0afffffa 	beq	8080521c <_init+0x84>
     *pulDest++ = *pulSrc++;
     }*/

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
80805230:	e30ce000 	movw	lr, #49152	; 0xc000
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
80805234:	e1a02003 	mov	r2, r3
     *pulDest++ = *pulSrc++;
     }*/

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
80805238:	e348e080 	movt	lr, #32896	; 0x8080
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
8080523c:	e1a05003 	mov	r5, r3
     *pulDest++ = *pulSrc++;
     }*/

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
80805240:	e1a0400e 	mov	r4, lr
80805244:	e3a0001c 	mov	r0, #28
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
    *thr = c;
80805248:	e3a01040 	mov	r1, #64	; 0x40
8080524c:	e5831000 	str	r1, [r3]
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
        unsigned int tmp = (value >> (4 * digits)) & 0xf;
80805250:	e1a03034 	lsr	r3, r4, r0
80805254:	e203300f 	and	r3, r3, #15
        kputc(tmp > 9 ? tmp - 10 + 'a' : tmp + '0');
80805258:	e3530009 	cmp	r3, #9
8080525c:	82831057 	addhi	r1, r3, #87	; 0x57
80805260:	92831030 	addls	r1, r3, #48	; 0x30
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
80805264:	e5923014 	ldr	r3, [r2, #20]
80805268:	e3130020 	tst	r3, #32
8080526c:	0afffffc 	beq	80805264 <_init+0xcc>
80805270:	e2400004 	sub	r0, r0, #4
    *thr = c;
80805274:	e5851000 	str	r1, [r5]
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
80805278:	e3700004 	cmn	r0, #4
8080527c:	1afffff3 	bne	80805250 <_init+0xb8>
{
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
        while (!(*lsr & 0x20));
80805280:	e3a01000 	mov	r1, #0
80805284:	e3441802 	movt	r1, #18434	; 0x4802
80805288:	e5912014 	ldr	r2, [r1, #20]
8080528c:	e3a03000 	mov	r3, #0
80805290:	e3443802 	movt	r3, #18434	; 0x4802
80805294:	e3120020 	tst	r2, #32
80805298:	0afffffa 	beq	80805288 <_init+0xf0>
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
8080529c:	e1a01003 	mov	r1, r3
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
    volatile unsigned int *thr = (unsigned int *) 0x48020000;

    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
808052a0:	e3a0200d 	mov	r2, #13
808052a4:	e5832000 	str	r2, [r3]
    }

    while (!(*lsr & 0x20));
808052a8:	e5912014 	ldr	r2, [r1, #20]
808052ac:	e3a03000 	mov	r3, #0
808052b0:	e3443802 	movt	r3, #18434	; 0x4802
808052b4:	e3120020 	tst	r2, #32
808052b8:	0afffffa 	beq	808052a8 <_init+0x110>

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
    /* Zero fill the bss segment. */
    for (pulDest = &_bss; pulDest < &_ebss;)
808052bc:	e15e000c 	cmp	lr, ip
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
    *thr = c;
808052c0:	e3a0200a 	mov	r2, #10
808052c4:	e5832000 	str	r2, [r3]

    //kputc('#');kputc('*');kputc('@');

    kputc('#'); kputhex((int)&_ebss, 8);kputc('@');kputhex((int)&_bss, 8);kputc('\n');
    /* Zero fill the bss segment. */
    for (pulDest = &_bss; pulDest < &_ebss;)
808052c8:	2a000009 	bcs	808052f4 <_init+0x15c>
808052cc:	e3082127 	movw	r2, #33063	; 0x8127
808052d0:	e30c0004 	movw	r0, #49156	; 0xc004
808052d4:	e3480080 	movt	r0, #32896	; 0x8080
808052d8:	e3482101 	movt	r2, #33025	; 0x8101
808052dc:	e0602002 	rsb	r2, r0, r2
808052e0:	e3a01000 	mov	r1, #0
808052e4:	e3c22003 	bic	r2, r2, #3
808052e8:	e2400004 	sub	r0, r0, #4
808052ec:	e2822004 	add	r2, r2, #4
808052f0:	fa001179 	blx	808098dc <memset>
    if (c == '\n') {
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
808052f4:	e3a01000 	mov	r1, #0
808052f8:	e3441802 	movt	r1, #18434	; 0x4802
808052fc:	e5912014 	ldr	r2, [r1, #20]
80805300:	e3a03000 	mov	r3, #0
80805304:	e3443802 	movt	r3, #18434	; 0x4802
80805308:	e3120020 	tst	r2, #32
8080530c:	0afffffa 	beq	808052fc <_init+0x164>
    }
    kputc('@');


	/* Configure the Stack Pointer for the Processor Modes. */
	__asm volatile (
80805310:	e30028fc 	movw	r2, #2300	; 0x8fc
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
    *thr = c;
80805314:	e3a01040 	mov	r1, #64	; 0x40
    }
    kputc('@');


	/* Configure the Stack Pointer for the Processor Modes. */
	__asm volatile (
80805318:	e3482081 	movt	r2, #32897	; 0x8081
        while (!(*lsr & 0x20));
        *thr = '\r';
    }

    while (!(*lsr & 0x20));
    *thr = c;
8080531c:	e5831000 	str	r1, [r3]
    }
    kputc('@');


	/* Configure the Stack Pointer for the Processor Modes. */
	__asm volatile (
80805320:	e2420c05 	sub	r0, r2, #1280	; 0x500
80805324:	e2823b01 	add	r3, r2, #1024	; 0x400
80805328:	e2821b02 	add	r1, r2, #2048	; 0x800
8080532c:	f1020011 	cps	#17
80805330:	e320f000 	nop	{0}
80805334:	e1a0d002 	mov	sp, r2
80805338:	e320f000 	nop	{0}
8080533c:	f1020012 	cps	#18
80805340:	e320f000 	nop	{0}
80805344:	e1a0d003 	mov	sp, r3
80805348:	e320f000 	nop	{0}
8080534c:	f1020017 	cps	#23
80805350:	e320f000 	nop	{0}
80805354:	e1a0d001 	mov	sp, r1
80805358:	e320f000 	nop	{0}
8080535c:	f102001b 	cps	#27
80805360:	e320f000 	nop	{0}
80805364:	e1a0d001 	mov	sp, r1
80805368:	e320f000 	nop	{0}
8080536c:	f1020013 	cps	#19
80805370:	e320f000 	nop	{0}
80805374:	e1a0d000 	mov	sp, r0
80805378:	e320f000 	nop	{0}


	/* Finally, copy the exception vector table over the boot loader. */
	pulSrc = (unsigned long *)&__isr_vector_start;
	pulDest = (unsigned long *)portEXCEPTION_VECTORS_BASE;
	for ( pulSrc = &__isr_vector_start; pulSrc < &__isr_vector_end; )
8080537c:	e3003000 	movw	r3, #0
80805380:	e300c0d8 	movw	ip, #216	; 0xd8
80805384:	e3483080 	movt	r3, #32896	; 0x8080
80805388:	e348c080 	movt	ip, #32896	; 0x8080
8080538c:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}
80805390:	e153000c 	cmp	r3, ip



	/* Finally, copy the exception vector table over the boot loader. */
	pulSrc = (unsigned long *)&__isr_vector_start;
	pulDest = (unsigned long *)portEXCEPTION_VECTORS_BASE;
80805394:	e2022003 	and	r2, r2, #3
80805398:	e2822004 	add	r2, r2, #4
8080539c:	e1a01e82 	lsl	r1, r2, #29
	for ( pulSrc = &__isr_vector_start; pulSrc < &__isr_vector_end; )
808053a0:	2a000023 	bcs	80805434 <_init+0x29c>
808053a4:	e24c401c 	sub	r4, ip, #28
808053a8:	e2832004 	add	r2, r3, #4
808053ac:	e1540002 	cmp	r4, r2
808053b0:	835c001b 	cmphi	ip, #27
808053b4:	9a0000e8 	bls	8080575c <_init+0x5c4>
808053b8:	e2812020 	add	r2, r1, #32
808053bc:	e2833020 	add	r3, r3, #32
	{
		*pulDest++ = *pulSrc++;
808053c0:	e513e020 	ldr	lr, [r3, #-32]	; 0xffffffe0
808053c4:	e2831004 	add	r1, r3, #4
808053c8:	f5d3f068 	pld	[r3, #104]	; 0x68
808053cc:	e1540001 	cmp	r4, r1
808053d0:	e1a00003 	mov	r0, r3
808053d4:	e1a01002 	mov	r1, r2
808053d8:	e502e020 	str	lr, [r2, #-32]	; 0xffffffe0
808053dc:	e2833020 	add	r3, r3, #32
808053e0:	e513e03c 	ldr	lr, [r3, #-60]	; 0xffffffc4
808053e4:	e2822020 	add	r2, r2, #32
808053e8:	e502e03c 	str	lr, [r2, #-60]	; 0xffffffc4
808053ec:	e513e038 	ldr	lr, [r3, #-56]	; 0xffffffc8
808053f0:	e502e038 	str	lr, [r2, #-56]	; 0xffffffc8
808053f4:	e513e034 	ldr	lr, [r3, #-52]	; 0xffffffcc
808053f8:	e502e034 	str	lr, [r2, #-52]	; 0xffffffcc
808053fc:	e513e030 	ldr	lr, [r3, #-48]	; 0xffffffd0
80805400:	e502e030 	str	lr, [r2, #-48]	; 0xffffffd0
80805404:	e513e02c 	ldr	lr, [r3, #-44]	; 0xffffffd4
80805408:	e502e02c 	str	lr, [r2, #-44]	; 0xffffffd4
8080540c:	e513e028 	ldr	lr, [r3, #-40]	; 0xffffffd8
80805410:	e502e028 	str	lr, [r2, #-40]	; 0xffffffd8
80805414:	e513e024 	ldr	lr, [r3, #-36]	; 0xffffffdc
80805418:	e502e024 	str	lr, [r2, #-36]	; 0xffffffdc
8080541c:	8affffe7 	bhi	808053c0 <_init+0x228>
80805420:	e2412004 	sub	r2, r1, #4
80805424:	e4903004 	ldr	r3, [r0], #4


	/* Finally, copy the exception vector table over the boot loader. */
	pulSrc = (unsigned long *)&__isr_vector_start;
	pulDest = (unsigned long *)portEXCEPTION_VECTORS_BASE;
	for ( pulSrc = &__isr_vector_start; pulSrc < &__isr_vector_end; )
80805428:	e150000c 	cmp	r0, ip
	{
		*pulDest++ = *pulSrc++;
8080542c:	e5a23004 	str	r3, [r2, #4]!


	/* Finally, copy the exception vector table over the boot loader. */
	pulSrc = (unsigned long *)&__isr_vector_start;
	pulDest = (unsigned long *)portEXCEPTION_VECTORS_BASE;
	for ( pulSrc = &__isr_vector_start; pulSrc < &__isr_vector_end; )
80805430:	3afffffb 	bcc	80805424 <_init+0x28c>
80805434:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}
		*pulDest++ = *pulSrc++;
	}

	/* VBAR is modified to point to the new Vector Table. */
	pulDest = (unsigned long *)portEXCEPTION_VECTORS_BASE;
	__asm volatile(
80805438:	e2033003 	and	r3, r3, #3
8080543c:	e2833004 	add	r3, r3, #4
80805440:	e1a03e83 	lsl	r3, r3, #29
80805444:	ee0c3f10 	mcr	15, 0, r3, cr12, cr0, {0}


static unsigned long ReadSCTLR()
{
	unsigned long SCTLR;
	__asm volatile("mrc p15, 0, %[sctlr], c1, c0, 0"
80805448:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
			" mcr p15, 0, %[vbar], c12, c0, 0 			\n"
			: : [vbar] "r" (pulDest) :
			);

	/* Now we modify the SCTLR to change the Vector Table Address. */
	ulSCTLR=ReadSCTLR();
8080544c:	e58d3004 	str	r3, [sp, #4]
	ulSCTLR&=~(1<<13);
80805450:	e59d3004 	ldr	r3, [sp, #4]
80805454:	e3c33a02 	bic	r3, r3, #8192	; 0x2000
80805458:	e58d3004 	str	r3, [sp, #4]
	WriteSCTLR(ulSCTLR);
8080545c:	e59d3004 	ldr	r3, [sp, #4]
	return SCTLR;
}

static void WriteSCTLR(unsigned long SCTLR)
{
	__asm volatile("mcr p15, 0, %[sctlr], c1, c0, 0"
80805460:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}


static unsigned long ReadSCTLR()
{
	unsigned long SCTLR;
	__asm volatile("mrc p15, 0, %[sctlr], c1, c0, 0"
80805464:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
	return SCTLR;
}

static void WriteSCTLR(unsigned long SCTLR)
{
	__asm volatile("mcr p15, 0, %[sctlr], c1, c0, 0"
80805468:	e3833b02 	orr	r3, r3, #2048	; 0x800
8080546c:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
80805470:	e3042074 	movw	r2, #16500	; 0x4074
	// Mark first 64 megabytes as cached, the rest non-cached.
	for(i=0;i<64;i++) PageTable[i]=(i<<20)|0x05de6;
	for(i=64;i<4096;i++) PageTable[i]=(i<<20)|0x0de2;
#elif configPLATFORM == 3
	// Mark the 1 GB of RAM at 0x80000000 as cached, the rest non-cachned.
	for(i=0;i<2048;i++) PageTable[i]=(i<<20)|0x0de2;
80805474:	e3a03000 	mov	r3, #0
80805478:	e3482081 	movt	r2, #32897	; 0x8081
8080547c:	e30087f8 	movw	r8, #2040	; 0x7f8
80805480:	e2837001 	add	r7, r3, #1
80805484:	e2836002 	add	r6, r3, #2
80805488:	e2835003 	add	r5, r3, #3
8080548c:	e2834004 	add	r4, r3, #4
80805490:	e283e005 	add	lr, r3, #5
80805494:	e283c006 	add	ip, r3, #6
80805498:	e2830007 	add	r0, r3, #7
8080549c:	e1a01a03 	lsl	r1, r3, #20
808054a0:	e1a07a07 	lsl	r7, r7, #20
808054a4:	e1a06a06 	lsl	r6, r6, #20
808054a8:	e1a05a05 	lsl	r5, r5, #20
808054ac:	e1a04a04 	lsl	r4, r4, #20
808054b0:	e1a0ea0e 	lsl	lr, lr, #20
808054b4:	e1a0ca0c 	lsl	ip, ip, #20
808054b8:	e1a00a00 	lsl	r0, r0, #20
808054bc:	f5d2f000 	pld	[r2]
808054c0:	e2833008 	add	r3, r3, #8
808054c4:	e3877ede 	orr	r7, r7, #3552	; 0xde0
808054c8:	e3866ede 	orr	r6, r6, #3552	; 0xde0
808054cc:	e3855ede 	orr	r5, r5, #3552	; 0xde0
808054d0:	e3844ede 	orr	r4, r4, #3552	; 0xde0
808054d4:	e38eeede 	orr	lr, lr, #3552	; 0xde0
808054d8:	e38ccede 	orr	ip, ip, #3552	; 0xde0
808054dc:	e3800ede 	orr	r0, r0, #3552	; 0xde0
808054e0:	e3811ede 	orr	r1, r1, #3552	; 0xde0
808054e4:	e1530008 	cmp	r3, r8
808054e8:	e3877002 	orr	r7, r7, #2
808054ec:	e3866002 	orr	r6, r6, #2
808054f0:	e3855002 	orr	r5, r5, #2
808054f4:	e3844002 	orr	r4, r4, #2
808054f8:	e38ee002 	orr	lr, lr, #2
808054fc:	e38cc002 	orr	ip, ip, #2
80805500:	e3800002 	orr	r0, r0, #2
80805504:	e3811002 	orr	r1, r1, #2
80805508:	e5027070 	str	r7, [r2, #-112]	; 0xffffff90
8080550c:	e502606c 	str	r6, [r2, #-108]	; 0xffffff94
80805510:	e2822020 	add	r2, r2, #32
80805514:	e5025088 	str	r5, [r2, #-136]	; 0xffffff78
80805518:	e5024084 	str	r4, [r2, #-132]	; 0xffffff7c
8080551c:	e502e080 	str	lr, [r2, #-128]	; 0xffffff80
80805520:	e502c07c 	str	ip, [r2, #-124]	; 0xffffff84
80805524:	e5020078 	str	r0, [r2, #-120]	; 0xffffff88
80805528:	e5021094 	str	r1, [r2, #-148]	; 0xffffff6c
8080552c:	1affffd3 	bne	80805480 <_init+0x2e8>
80805530:	e3051fdc 	movw	r1, #24540	; 0x5fdc
80805534:	e3481081 	movt	r1, #32897	; 0x8081
80805538:	e1a02a03 	lsl	r2, r3, #20
8080553c:	e2833001 	add	r3, r3, #1
80805540:	e3530b02 	cmp	r3, #2048	; 0x800
80805544:	e3822ede 	orr	r2, r2, #3552	; 0xde0
80805548:	e3822002 	orr	r2, r2, #2
8080554c:	e5a12004 	str	r2, [r1, #4]!
80805550:	1afffff8 	bne	80805538 <_init+0x3a0>
80805554:	e3062074 	movw	r2, #24692	; 0x6074
80805558:	e3008bf8 	movw	r8, #3064	; 0xbf8
8080555c:	e3482081 	movt	r2, #32897	; 0x8081
	for(i=2048;i<3072;i++) PageTable[i]=(i<<20)|0x05de6;
80805560:	e2837001 	add	r7, r3, #1
80805564:	e2836002 	add	r6, r3, #2
80805568:	e2835003 	add	r5, r3, #3
8080556c:	e2834004 	add	r4, r3, #4
80805570:	e283e005 	add	lr, r3, #5
80805574:	e283c006 	add	ip, r3, #6
80805578:	e2830007 	add	r0, r3, #7
8080557c:	e1a01a03 	lsl	r1, r3, #20
80805580:	e1a07a07 	lsl	r7, r7, #20
80805584:	e1a06a06 	lsl	r6, r6, #20
80805588:	e1a05a05 	lsl	r5, r5, #20
8080558c:	e1a04a04 	lsl	r4, r4, #20
80805590:	e1a0ea0e 	lsl	lr, lr, #20
80805594:	e1a0ca0c 	lsl	ip, ip, #20
80805598:	e1a00a00 	lsl	r0, r0, #20
8080559c:	f5d2f000 	pld	[r2]
808055a0:	e2833008 	add	r3, r3, #8
808055a4:	e3877c5d 	orr	r7, r7, #23808	; 0x5d00
808055a8:	e3866c5d 	orr	r6, r6, #23808	; 0x5d00
808055ac:	e3855c5d 	orr	r5, r5, #23808	; 0x5d00
808055b0:	e3844c5d 	orr	r4, r4, #23808	; 0x5d00
808055b4:	e38eec5d 	orr	lr, lr, #23808	; 0x5d00
808055b8:	e38ccc5d 	orr	ip, ip, #23808	; 0x5d00
808055bc:	e3800c5d 	orr	r0, r0, #23808	; 0x5d00
808055c0:	e3811c5d 	orr	r1, r1, #23808	; 0x5d00
808055c4:	e1530008 	cmp	r3, r8
808055c8:	e38770e6 	orr	r7, r7, #230	; 0xe6
808055cc:	e38660e6 	orr	r6, r6, #230	; 0xe6
808055d0:	e38550e6 	orr	r5, r5, #230	; 0xe6
808055d4:	e38440e6 	orr	r4, r4, #230	; 0xe6
808055d8:	e38ee0e6 	orr	lr, lr, #230	; 0xe6
808055dc:	e38cc0e6 	orr	ip, ip, #230	; 0xe6
808055e0:	e38000e6 	orr	r0, r0, #230	; 0xe6
808055e4:	e38110e6 	orr	r1, r1, #230	; 0xe6
808055e8:	e5027070 	str	r7, [r2, #-112]	; 0xffffff90
808055ec:	e502606c 	str	r6, [r2, #-108]	; 0xffffff94
808055f0:	e2822020 	add	r2, r2, #32
808055f4:	e5025088 	str	r5, [r2, #-136]	; 0xffffff78
808055f8:	e5024084 	str	r4, [r2, #-132]	; 0xffffff7c
808055fc:	e502e080 	str	lr, [r2, #-128]	; 0xffffff80
80805600:	e502c07c 	str	ip, [r2, #-124]	; 0xffffff84
80805604:	e5020078 	str	r0, [r2, #-120]	; 0xffffff88
80805608:	e5021094 	str	r1, [r2, #-148]	; 0xffffff6c
8080560c:	1affffd3 	bne	80805560 <_init+0x3c8>
80805610:	e3061fdc 	movw	r1, #28636	; 0x6fdc
80805614:	e3481081 	movt	r1, #32897	; 0x8081
80805618:	e1a02a03 	lsl	r2, r3, #20
8080561c:	e2833001 	add	r3, r3, #1
80805620:	e3530b03 	cmp	r3, #3072	; 0xc00
80805624:	e3822c5d 	orr	r2, r2, #23808	; 0x5d00
80805628:	e38220e6 	orr	r2, r2, #230	; 0xe6
8080562c:	e5a12004 	str	r2, [r1, #4]!
80805630:	1afffff8 	bne	80805618 <_init+0x480>
80805634:	e3072074 	movw	r2, #28788	; 0x7074
80805638:	e3008ff8 	movw	r8, #4088	; 0xff8
8080563c:	e3482081 	movt	r2, #32897	; 0x8081
	for(i=3072;i<4096;i++) PageTable[i]=(i<<20)|0x0de2;
80805640:	e2837001 	add	r7, r3, #1
80805644:	e2836002 	add	r6, r3, #2
80805648:	e2835003 	add	r5, r3, #3
8080564c:	e2834004 	add	r4, r3, #4
80805650:	e283e005 	add	lr, r3, #5
80805654:	e283c006 	add	ip, r3, #6
80805658:	e2830007 	add	r0, r3, #7
8080565c:	e1a01a03 	lsl	r1, r3, #20
80805660:	e1a07a07 	lsl	r7, r7, #20
80805664:	e1a06a06 	lsl	r6, r6, #20
80805668:	e1a05a05 	lsl	r5, r5, #20
8080566c:	e1a04a04 	lsl	r4, r4, #20
80805670:	e1a0ea0e 	lsl	lr, lr, #20
80805674:	e1a0ca0c 	lsl	ip, ip, #20
80805678:	e1a00a00 	lsl	r0, r0, #20
8080567c:	f5d2f000 	pld	[r2]
80805680:	e2833008 	add	r3, r3, #8
80805684:	e3877ede 	orr	r7, r7, #3552	; 0xde0
80805688:	e3866ede 	orr	r6, r6, #3552	; 0xde0
8080568c:	e3855ede 	orr	r5, r5, #3552	; 0xde0
80805690:	e3844ede 	orr	r4, r4, #3552	; 0xde0
80805694:	e38eeede 	orr	lr, lr, #3552	; 0xde0
80805698:	e38ccede 	orr	ip, ip, #3552	; 0xde0
8080569c:	e3800ede 	orr	r0, r0, #3552	; 0xde0
808056a0:	e3811ede 	orr	r1, r1, #3552	; 0xde0
808056a4:	e1530008 	cmp	r3, r8
808056a8:	e3877002 	orr	r7, r7, #2
808056ac:	e3866002 	orr	r6, r6, #2
808056b0:	e3855002 	orr	r5, r5, #2
808056b4:	e3844002 	orr	r4, r4, #2
808056b8:	e38ee002 	orr	lr, lr, #2
808056bc:	e38cc002 	orr	ip, ip, #2
808056c0:	e3800002 	orr	r0, r0, #2
808056c4:	e3811002 	orr	r1, r1, #2
808056c8:	e5027070 	str	r7, [r2, #-112]	; 0xffffff90
808056cc:	e502606c 	str	r6, [r2, #-108]	; 0xffffff94
808056d0:	e2822020 	add	r2, r2, #32
808056d4:	e5025088 	str	r5, [r2, #-136]	; 0xffffff78
808056d8:	e5024084 	str	r4, [r2, #-132]	; 0xffffff7c
808056dc:	e502e080 	str	lr, [r2, #-128]	; 0xffffff80
808056e0:	e502c07c 	str	ip, [r2, #-124]	; 0xffffff84
808056e4:	e5020078 	str	r0, [r2, #-120]	; 0xffffff88
808056e8:	e5021094 	str	r1, [r2, #-148]	; 0xffffff6c
808056ec:	1affffd3 	bne	80805640 <_init+0x4a8>
808056f0:	e3071fdc 	movw	r1, #32732	; 0x7fdc
808056f4:	e3481081 	movt	r1, #32897	; 0x8081
808056f8:	e1a02a03 	lsl	r2, r3, #20
808056fc:	e2833001 	add	r3, r3, #1
80805700:	e3530a01 	cmp	r3, #4096	; 0x1000
80805704:	e3822ede 	orr	r2, r2, #3552	; 0xde0
80805708:	e3822002 	orr	r2, r2, #2
8080570c:	e5a12004 	str	r2, [r1, #4]!
80805710:	1afffff8 	bne	808056f8 <_init+0x560>
	// Initialize MMU.

	// Enable TTB0 only.
	// Set translation table base address.
	// Set all domains to client.
	__asm volatile (
80805714:	e3053555 	movw	r3, #21845	; 0x5555
80805718:	e3041000 	movw	r1, #16384	; 0x4000
8080571c:	e3a02000 	mov	r2, #0
80805720:	e7df3813 	bfi	r3, r3, #16, #16
80805724:	e3481081 	movt	r1, #32897	; 0x8081
80805728:	ee022f50 	mcr	15, 0, r2, cr2, cr0, {2}
8080572c:	ee021f10 	mcr	15, 0, r1, cr2, cr0, {0}
80805730:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}


static unsigned long ReadSCTLR()
{
	unsigned long SCTLR;
	__asm volatile("mrc p15, 0, %[sctlr], c1, c0, 0"
80805734:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
	return SCTLR;
}

static void WriteSCTLR(unsigned long SCTLR)
{
	__asm volatile("mcr p15, 0, %[sctlr], c1, c0, 0"
80805738:	e3833001 	orr	r3, r3, #1
8080573c:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}


static unsigned long ReadSCTLR()
{
	unsigned long SCTLR;
	__asm volatile("mrc p15, 0, %[sctlr], c1, c0, 0"
80805740:	ee113f10 	mrc	15, 0, r3, cr1, cr0, {0}
	return SCTLR;
}

static void WriteSCTLR(unsigned long SCTLR)
{
	__asm volatile("mcr p15, 0, %[sctlr], c1, c0, 0"
80805744:	e3833a01 	orr	r3, r3, #4096	; 0x1000
80805748:	e3833004 	orr	r3, r3, #4
8080574c:	ee013f10 	mcr	15, 0, r3, cr1, cr0, {0}
	WriteSCTLR(ReadSCTLR()|(1<<0));

	// Enable L1 I & D caches.
	WriteSCTLR(ReadSCTLR()|(1<<2)|(1<<12));

	main();
80805750:	eb000128 	bl	80805bf8 <main>
}
80805754:	e28dd008 	add	sp, sp, #8
80805758:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}


	/* Finally, copy the exception vector table over the boot loader. */
	pulSrc = (unsigned long *)&__isr_vector_start;
	pulDest = (unsigned long *)portEXCEPTION_VECTORS_BASE;
	for ( pulSrc = &__isr_vector_start; pulSrc < &__isr_vector_end; )
8080575c:	e1a00003 	mov	r0, r3
80805760:	eaffff2e 	b	80805420 <_init+0x288>

80805764 <Undefined_Handler_Panic>:

void vSerialPutString(int,const signed char * cons,int);

void Undefined_Handler_Panic( void )
{
vSerialPutString(2,(const signed char * const)"u\r\n", 3 );
80805764:	e3091a84 	movw	r1, #39556	; 0x9a84
/*----------------------------------------------------------------------------*/

void vSerialPutString(int,const signed char * cons,int);

void Undefined_Handler_Panic( void )
{
80805768:	e92d4010 	push	{r4, lr}
vSerialPutString(2,(const signed char * const)"u\r\n", 3 );
8080576c:	e3a02003 	mov	r2, #3
80805770:	e3481080 	movt	r1, #32896	; 0x8080
80805774:	e3a00002 	mov	r0, #2
80805778:	eb0006ee 	bl	80807338 <vSerialPutString>
	__asm volatile ( " smc #0 " );
8080577c:	e1600070 	smc	0
80805780:	eafffffe 	b	80805780 <Undefined_Handler_Panic+0x1c>

80805784 <Prefetch_Handler_Panic>:
}
/*----------------------------------------------------------------------------*/

void Prefetch_Handler_Panic( void )
{
vSerialPutString(2,(const signed char * const)"p\r\n", 3 );
80805784:	e30919bc 	movw	r1, #39356	; 0x99bc
	for (;;);
}
/*----------------------------------------------------------------------------*/

void Prefetch_Handler_Panic( void )
{
80805788:	e92d4010 	push	{r4, lr}
vSerialPutString(2,(const signed char * const)"p\r\n", 3 );
8080578c:	e3a02003 	mov	r2, #3
80805790:	e3481080 	movt	r1, #32896	; 0x8080
80805794:	e3a00002 	mov	r0, #2
80805798:	eb0006e6 	bl	80807338 <vSerialPutString>
	__asm volatile ( " smc #0 " );
8080579c:	e1600070 	smc	0
808057a0:	eafffffe 	b	808057a0 <Prefetch_Handler_Panic+0x1c>

808057a4 <Abort_Handler_Panic>:
}
/*----------------------------------------------------------------------------*/

void Abort_Handler_Panic( void )
{
vSerialPutString(2,(const signed char * const)"a\r\n", 3 );
808057a4:	e30919c0 	movw	r1, #39360	; 0x99c0
	for (;;);
}
/*----------------------------------------------------------------------------*/

void Abort_Handler_Panic( void )
{
808057a8:	e92d4010 	push	{r4, lr}
vSerialPutString(2,(const signed char * const)"a\r\n", 3 );
808057ac:	e3a02003 	mov	r2, #3
808057b0:	e3481080 	movt	r1, #32896	; 0x8080
808057b4:	e3a00002 	mov	r0, #2
808057b8:	eb0006de 	bl	80807338 <vSerialPutString>
808057bc:	eafffffe 	b	808057bc <Abort_Handler_Panic+0x18>

808057c0 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
808057c0:	e92d4070 	push	{r4, r5, r6, lr}
808057c4:	e1a04000 	mov	r4, r0
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
808057c8:	ebfff46b 	bl	8080297c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
808057cc:	e3083000 	movw	r3, #32768	; 0x8000
808057d0:	e3483081 	movt	r3, #32897	; 0x8081
808057d4:	e5932008 	ldr	r2, [r3, #8]
808057d8:	e3520000 	cmp	r2, #0
808057dc:	1a00000e 	bne	8080581c <pvPortMalloc+0x5c>
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
808057e0:	e3070ff8 	movw	r0, #32760	; 0x7ff8
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
808057e4:	e2831014 	add	r1, r3, #20
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
808057e8:	e3480101 	movt	r0, #33025	; 0x8101
808057ec:	e30fcff8 	movw	ip, #65528	; 0xfff8
{
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
808057f0:	e3c11007 	bic	r1, r1, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
	xEnd.pxNextFreeBlock = NULL;
808057f4:	e1a0e000 	mov	lr, r0
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
808057f8:	e340c07f 	movt	ip, #127	; 0x7f
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
808057fc:	e3a05001 	mov	r5, #1
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
	xEnd.pxNextFreeBlock = NULL;
80805800:	e5ae2014 	str	r2, [lr, #20]!
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;
80805804:	e5832004 	str	r2, [r3, #4]
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
80805808:	e5831000 	str	r1, [r3]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
8080580c:	e581e000 	str	lr, [r1]
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
	xStart.xBlockSize = ( size_t ) 0;

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
80805810:	e580c018 	str	ip, [r0, #24]
	xEnd.pxNextFreeBlock = NULL;

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
80805814:	e581c004 	str	ip, [r1, #4]
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
80805818:	e5835008 	str	r5, [r3, #8]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
8080581c:	e3540000 	cmp	r4, #0
80805820:	0a000037 	beq	80805904 <pvPortMalloc+0x144>
		{
			xWantedSize += heapSTRUCT_SIZE;
80805824:	e2840008 	add	r0, r4, #8
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
80805828:	e30f2ff6 	movw	r2, #65526	; 0xfff6
		if( xWantedSize > 0 )
		{
			xWantedSize += heapSTRUCT_SIZE;

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
8080582c:	e3100007 	tst	r0, #7
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
80805830:	e340207f 	movt	r2, #127	; 0x7f

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
80805834:	13c00007 	bicne	r0, r0, #7
80805838:	12800008 	addne	r0, r0, #8
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
8080583c:	e2401001 	sub	r1, r0, #1
80805840:	e1510002 	cmp	r1, r2
80805844:	8a00002e 	bhi	80805904 <pvPortMalloc+0x144>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
80805848:	e308c000 	movw	ip, #32768	; 0x8000
			pxBlock = xStart.pxNextFreeBlock;
8080584c:	e5933000 	ldr	r3, [r3]

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
80805850:	e348c081 	movt	ip, #32897	; 0x8081
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
80805854:	ea000004 	b	8080586c <pvPortMalloc+0xac>
80805858:	e5932000 	ldr	r2, [r3]
8080585c:	e3520000 	cmp	r2, #0
80805860:	0a000004 	beq	80805878 <pvPortMalloc+0xb8>
80805864:	e1a0c003 	mov	ip, r3
80805868:	e1a03002 	mov	r3, r2
8080586c:	e5931004 	ldr	r1, [r3, #4]
80805870:	e1500001 	cmp	r0, r1
80805874:	8afffff7 	bhi	80805858 <pvPortMalloc+0x98>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
80805878:	e308200c 	movw	r2, #32780	; 0x800c
8080587c:	e3482101 	movt	r2, #33025	; 0x8101
80805880:	e1530002 	cmp	r3, r2
80805884:	0a00001e 	beq	80805904 <pvPortMalloc+0x144>
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
80805888:	e5932000 	ldr	r2, [r3]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
8080588c:	e0605001 	rsb	r5, r0, r1
80805890:	e3550010 	cmp	r5, #16
			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
80805894:	e2834008 	add	r4, r3, #8

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
80805898:	e58c2000 	str	r2, [ip]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
8080589c:	9a00000e 	bls	808058dc <pvPortMalloc+0x11c>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
808058a0:	e083e000 	add	lr, r3, r0
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
					pxBlock->xBlockSize = xWantedSize;

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
808058a4:	e3082000 	movw	r2, #32768	; 0x8000
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
808058a8:	e58e5004 	str	r5, [lr, #4]
					pxBlock->xBlockSize = xWantedSize;

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
808058ac:	e3482081 	movt	r2, #32897	; 0x8081
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
					pxBlock->xBlockSize = xWantedSize;
808058b0:	e5830004 	str	r0, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
808058b4:	e59ec004 	ldr	ip, [lr, #4]
808058b8:	ea000000 	b	808058c0 <pvPortMalloc+0x100>
808058bc:	e1a02003 	mov	r2, r3
808058c0:	e5923000 	ldr	r3, [r2]
808058c4:	e5931004 	ldr	r1, [r3, #4]
808058c8:	e15c0001 	cmp	ip, r1
808058cc:	8afffffa 	bhi	808058bc <pvPortMalloc+0xfc>
808058d0:	e1a01000 	mov	r1, r0
808058d4:	e58e3000 	str	r3, [lr]
808058d8:	e582e000 	str	lr, [r2]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
808058dc:	e3093c10 	movw	r3, #39952	; 0x9c10
808058e0:	e3483080 	movt	r3, #32896	; 0x8080
808058e4:	e5932000 	ldr	r2, [r3]
808058e8:	e0611002 	rsb	r1, r1, r2
808058ec:	e5831000 	str	r1, [r3]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
808058f0:	ebfff4c9 	bl	80802c1c <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
808058f4:	e3540000 	cmp	r4, #0
808058f8:	0a000002 	beq	80805908 <pvPortMalloc+0x148>
		}
	}
	#endif

	return pvReturn;
}
808058fc:	e1a00004 	mov	r0, r4
80805900:	e8bd8070 	pop	{r4, r5, r6, pc}
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
80805904:	ebfff4c4 	bl	80802c1c <xTaskResumeAll>
	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
80805908:	e3a04000 	mov	r4, #0
8080590c:	eb0000af 	bl	80805bd0 <vApplicationMallocFailedHook>
		}
	}
	#endif

	return pvReturn;
}
80805910:	e1a00004 	mov	r0, r4
80805914:	e8bd8070 	pop	{r4, r5, r6, pc}

80805918 <vPortFree>:
void vPortFree( void *pv )
{
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
80805918:	e3500000 	cmp	r0, #0
8080591c:	012fff1e 	bxeq	lr
	return pvReturn;
}
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
80805920:	e92d4010 	push	{r4, lr}
80805924:	e1a04000 	mov	r4, r0

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
80805928:	ebfff413 	bl	8080297c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
8080592c:	e3082000 	movw	r2, #32768	; 0x8000

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
80805930:	e2440008 	sub	r0, r4, #8
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
80805934:	e3482081 	movt	r2, #32897	; 0x8081
80805938:	e514c004 	ldr	ip, [r4, #-4]
8080593c:	ea000000 	b	80805944 <vPortFree+0x2c>
80805940:	e1a02003 	mov	r2, r3
80805944:	e5923000 	ldr	r3, [r2]
80805948:	e5931004 	ldr	r1, [r3, #4]
8080594c:	e15c0001 	cmp	ip, r1
80805950:	8afffffa 	bhi	80805940 <vPortFree+0x28>
			xFreeBytesRemaining += pxLink->xBlockSize;
80805954:	e3091c10 	movw	r1, #39952	; 0x9c10
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
80805958:	e5043008 	str	r3, [r4, #-8]
			xFreeBytesRemaining += pxLink->xBlockSize;
8080595c:	e3481080 	movt	r1, #32896	; 0x8080
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
80805960:	e5820000 	str	r0, [r2]
			xFreeBytesRemaining += pxLink->xBlockSize;
80805964:	e5913000 	ldr	r3, [r1]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
	}
}
80805968:	e8bd4010 	pop	{r4, lr}

		vTaskSuspendAll();
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
			xFreeBytesRemaining += pxLink->xBlockSize;
8080596c:	e083c00c 	add	ip, r3, ip
80805970:	e581c000 	str	ip, [r1]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
80805974:	eafff4a8 	b	80802c1c <xTaskResumeAll>

80805978 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
80805978:	e3093c10 	movw	r3, #39952	; 0x9c10
8080597c:	e3483080 	movt	r3, #32896	; 0x8080
}
80805980:	e5930000 	ldr	r0, [r3]
80805984:	e12fff1e 	bx	lr

80805988 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
80805988:	e12fff1e 	bx	lr

8080598c <vCheckTask>:
}
/*----------------------------------------------------------------------------*/
#endif /* configPLATFORM */

static void vCheckTask( void *pvParameters )
{
8080598c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
portBASE_TYPE xErrorOccurred = pdFALSE;
portTickType xLastExecutionTime, xFailureTime = 0;
signed char cBuffer[64];

	/* First Task Started. */
	vSerialPutString((xComPortHandle)mainPRINT_PORT,(const signed char * const)"FTS\r\n", 5 );
80805990:	e30919c4 	movw	r1, #39364	; 0x99c4
}
/*----------------------------------------------------------------------------*/
#endif /* configPLATFORM */

static void vCheckTask( void *pvParameters )
{
80805994:	e24dd04c 	sub	sp, sp, #76	; 0x4c
portBASE_TYPE xErrorOccurred = pdFALSE;
portTickType xLastExecutionTime, xFailureTime = 0;
signed char cBuffer[64];

	/* First Task Started. */
	vSerialPutString((xComPortHandle)mainPRINT_PORT,(const signed char * const)"FTS\r\n", 5 );
80805998:	e3481080 	movt	r1, #32896	; 0x8080
8080599c:	e3a02005 	mov	r2, #5
808059a0:	e3a00002 	mov	r0, #2
#endif /* configPLATFORM */

static void vCheckTask( void *pvParameters )
{
portBASE_TYPE xErrorOccurred = pdFALSE;
portTickType xLastExecutionTime, xFailureTime = 0;
808059a4:	e3a05000 	mov	r5, #0
		{
			if ( 0 == xFailureTime )
			{
				xFailureTime = xLastExecutionTime;
			}
			sprintf( (char *)cBuffer, "Fail: %lu\r\n", xFailureTime / 1000 );
808059a8:	e3047dd3 	movw	r7, #19923	; 0x4dd3
	/* First Task Started. */
	vSerialPutString((xComPortHandle)mainPRINT_PORT,(const signed char * const)"FTS\r\n", 5 );

	/* Initialise xLastExecutionTime so the first call to vTaskDelayUntil()
	works correctly. */
	xLastExecutionTime = xTaskGetTickCount();
808059ac:	e28d6048 	add	r6, sp, #72	; 0x48
/*----------------------------------------------------------------------------*/
#endif /* configPLATFORM */

static void vCheckTask( void *pvParameters )
{
portBASE_TYPE xErrorOccurred = pdFALSE;
808059b0:	e1a04005 	mov	r4, r5
portTickType xLastExecutionTime, xFailureTime = 0;
signed char cBuffer[64];

	/* First Task Started. */
	vSerialPutString((xComPortHandle)mainPRINT_PORT,(const signed char * const)"FTS\r\n", 5 );
808059b4:	eb00065f 	bl	80807338 <vSerialPutString>
		{
			if ( 0 == xFailureTime )
			{
				xFailureTime = xLastExecutionTime;
			}
			sprintf( (char *)cBuffer, "Fail: %lu\r\n", xFailureTime / 1000 );
808059b8:	e3417062 	movt	r7, #4194	; 0x1062
	/* First Task Started. */
	vSerialPutString((xComPortHandle)mainPRINT_PORT,(const signed char * const)"FTS\r\n", 5 );

	/* Initialise xLastExecutionTime so the first call to vTaskDelayUntil()
	works correctly. */
	xLastExecutionTime = xTaskGetTickCount();
808059bc:	ebfff3f4 	bl	80802994 <xTaskGetTickCount>
808059c0:	e5260044 	str	r0, [r6, #-68]!	; 0xffffffbc
808059c4:	ea000019 	b	80805a30 <vCheckTask+0xa4>
		}

		if( xAreQueuePeekTasksStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: PeekQ\r\n", sizeof( "Fail: PeekQ\r\n" ) );
808059c8:	e3091a58 	movw	r1, #39512	; 0x9a58
808059cc:	e3a0200e 	mov	r2, #14
808059d0:	e3481080 	movt	r1, #32896	; 0x8080
808059d4:	e3a00002 	mov	r0, #2
808059d8:	eb000656 	bl	80807338 <vSerialPutString>
		}

		if( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
808059dc:	eb000e77 	bl	808093c0 <xAreRecursiveMutexTasksStillRunning>
808059e0:	e3500001 	cmp	r0, #1
808059e4:	0a000004 	beq	808059fc <vCheckTask+0x70>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: RecMutex\r\n", sizeof( "Fail: RecMutex\r\n" ) );
808059e8:	e3091a68 	movw	r1, #39528	; 0x9a68
808059ec:	e3a02011 	mov	r2, #17
808059f0:	e3481080 	movt	r1, #32896	; 0x8080
808059f4:	e3a00002 	mov	r0, #2
808059f8:	eb00064e 	bl	80807338 <vSerialPutString>
		/* Send either a pass or fail message.  If an error is found it is
		never cleared again.  We do not write directly to the LCD, but instead
		queue a message for display by the print task. */
		if( xErrorOccurred == pdTRUE )
		{
			if ( 0 == xFailureTime )
808059fc:	e3550000 	cmp	r5, #0
			{
				xFailureTime = xLastExecutionTime;
			}
			sprintf( (char *)cBuffer, "Fail: %lu\r\n", xFailureTime / 1000 );
80805a00:	e3091a7c 	movw	r1, #39548	; 0x9a7c
		queue a message for display by the print task. */
		if( xErrorOccurred == pdTRUE )
		{
			if ( 0 == xFailureTime )
			{
				xFailureTime = xLastExecutionTime;
80805a04:	059d5004 	ldreq	r5, [sp, #4]
			}
			sprintf( (char *)cBuffer, "Fail: %lu\r\n", xFailureTime / 1000 );
80805a08:	e3481080 	movt	r1, #32896	; 0x8080
80805a0c:	e28d0008 	add	r0, sp, #8
80805a10:	e3a04001 	mov	r4, #1
80805a14:	e0832795 	umull	r2, r3, r5, r7
80805a18:	e1a02323 	lsr	r2, r3, #6
80805a1c:	eb00060c 	bl	80807254 <sprintf>
		}
		else
		{
			sprintf( (char *)cBuffer, "Pass: %lu\r\n", xLastExecutionTime / 1000 );
		}
		vSerialPutString((xComPortHandle)mainPRINT_PORT, (const signed char * const)cBuffer, sizeof((char *)cBuffer) );
80805a20:	e3a02004 	mov	r2, #4
80805a24:	e28d1008 	add	r1, sp, #8
80805a28:	e3a00002 	mov	r0, #2
80805a2c:	eb000641 	bl	80807338 <vSerialPutString>
	xLastExecutionTime = xTaskGetTickCount();

	for( ;; )
	{
		/* Perform this check every mainCHECK_DELAY milliseconds. */
		vTaskDelayUntil( &xLastExecutionTime, mainCHECK_DELAY );
80805a30:	e3011388 	movw	r1, #5000	; 0x1388
80805a34:	e1a00006 	mov	r0, r6
80805a38:	ebfff50e 	bl	80802e78 <vTaskDelayUntil>

		/* Has an error been found in any task? */

		if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
80805a3c:	eb000c30 	bl	80808b04 <xAreIntegerMathsTaskStillRunning>
80805a40:	e3500001 	cmp	r0, #1
80805a44:	0a000005 	beq	80805a60 <vCheckTask+0xd4>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Integer Maths\r\n", sizeof( "Fail: Integer Maths\r\n" ) );
80805a48:	e30919cc 	movw	r1, #39372	; 0x99cc
80805a4c:	e3a02016 	mov	r2, #22
80805a50:	e3481080 	movt	r1, #32896	; 0x8080
80805a54:	e3a00002 	mov	r0, #2

		/* Has an error been found in any task? */

		if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
80805a58:	e3a04001 	mov	r4, #1
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Integer Maths\r\n", sizeof( "Fail: Integer Maths\r\n" ) );
80805a5c:	eb000635 	bl	80807338 <vSerialPutString>
		}

		if( xArePollingQueuesStillRunning() != pdTRUE )
80805a60:	eb000c94 	bl	80808cb8 <xArePollingQueuesStillRunning>
80805a64:	e3500001 	cmp	r0, #1
80805a68:	0a000005 	beq	80805a84 <vCheckTask+0xf8>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Polling Queues\r\n", sizeof( "Fail: Polling Queues\r\n" ) );
80805a6c:	e30919e4 	movw	r1, #39396	; 0x99e4
80805a70:	e3a02017 	mov	r2, #23
80805a74:	e3481080 	movt	r1, #32896	; 0x8080
80805a78:	e3a00002 	mov	r0, #2
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Integer Maths\r\n", sizeof( "Fail: Integer Maths\r\n" ) );
		}

		if( xArePollingQueuesStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
80805a7c:	e3a04001 	mov	r4, #1
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Polling Queues\r\n", sizeof( "Fail: Polling Queues\r\n" ) );
80805a80:	eb00062c 	bl	80807338 <vSerialPutString>
		}

		if( xAreSemaphoreTasksStillRunning() != pdTRUE )
80805a84:	eb000f3a 	bl	80809774 <xAreSemaphoreTasksStillRunning>
80805a88:	e3500001 	cmp	r0, #1
80805a8c:	0a000005 	beq	80805aa8 <vCheckTask+0x11c>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Sem Tasks\r\n", sizeof( "Fail: Sem Tasks\r\n" ) );
80805a90:	e30919fc 	movw	r1, #39420	; 0x99fc
80805a94:	e3a02012 	mov	r2, #18
80805a98:	e3481080 	movt	r1, #32896	; 0x8080
80805a9c:	e3a00002 	mov	r0, #2
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Polling Queues\r\n", sizeof( "Fail: Polling Queues\r\n" ) );
		}

		if( xAreSemaphoreTasksStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
80805aa0:	e3a04001 	mov	r4, #1
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Sem Tasks\r\n", sizeof( "Fail: Sem Tasks\r\n" ) );
80805aa4:	eb000623 	bl	80807338 <vSerialPutString>
		}

		if( xAreBlockingQueuesStillRunning() != pdTRUE )
80805aa8:	eb000715 	bl	80807704 <xAreBlockingQueuesStillRunning>
80805aac:	e3500001 	cmp	r0, #1
80805ab0:	0a000005 	beq	80805acc <vCheckTask+0x140>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: BlockQ\r\n", sizeof( "Fail: BlockQ\r\n" ) );
80805ab4:	e3091a10 	movw	r1, #39440	; 0x9a10
80805ab8:	e3a0200f 	mov	r2, #15
80805abc:	e3481080 	movt	r1, #32896	; 0x8080
80805ac0:	e3a00002 	mov	r0, #2
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: Sem Tasks\r\n", sizeof( "Fail: Sem Tasks\r\n" ) );
		}

		if( xAreBlockingQueuesStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
80805ac4:	e3a04001 	mov	r4, #1
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: BlockQ\r\n", sizeof( "Fail: BlockQ\r\n" ) );
80805ac8:	eb00061a 	bl	80807338 <vSerialPutString>
		}

		if( xAreCountingSemaphoreTasksStillRunning() != pdTRUE )
80805acc:	eb000977 	bl	808080b0 <xAreCountingSemaphoreTasksStillRunning>
80805ad0:	e3500001 	cmp	r0, #1
80805ad4:	0a000005 	beq	80805af0 <vCheckTask+0x164>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: SemCount\r\n", sizeof( "Fail: SemCount\r\n" ) );
80805ad8:	e3091a20 	movw	r1, #39456	; 0x9a20
80805adc:	e3a02011 	mov	r2, #17
80805ae0:	e3481080 	movt	r1, #32896	; 0x8080
80805ae4:	e3a00002 	mov	r0, #2
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: BlockQ\r\n", sizeof( "Fail: BlockQ\r\n" ) );
		}

		if( xAreCountingSemaphoreTasksStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
80805ae8:	e3a04001 	mov	r4, #1
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: SemCount\r\n", sizeof( "Fail: SemCount\r\n" ) );
80805aec:	eb000611 	bl	80807338 <vSerialPutString>
		}

		if( xAreDynamicPriorityTasksStillRunning() != pdTRUE )
80805af0:	eb000a3e 	bl	808083f0 <xAreDynamicPriorityTasksStillRunning>
80805af4:	e3500001 	cmp	r0, #1
80805af8:	0a000005 	beq	80805b14 <vCheckTask+0x188>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: DynamicPrio\r\n", sizeof( "Fail: DynamicPrio\r\n" ) );
80805afc:	e3091a34 	movw	r1, #39476	; 0x9a34
80805b00:	e3a02014 	mov	r2, #20
80805b04:	e3481080 	movt	r1, #32896	; 0x8080
80805b08:	e3a00002 	mov	r0, #2
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: SemCount\r\n", sizeof( "Fail: SemCount\r\n" ) );
		}

		if( xAreDynamicPriorityTasksStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
80805b0c:	e3a04001 	mov	r4, #1
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: DynamicPrio\r\n", sizeof( "Fail: DynamicPrio\r\n" ) );
80805b10:	eb000608 	bl	80807338 <vSerialPutString>
//		{
//			xErrorOccurred = pdTRUE;
//			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: FloatMaths\r\n", sizeof( "Fail: FloatMaths\r\n" ) );
//		}

		if( xAreGenericQueueTasksStillRunning() != pdTRUE )
80805b14:	eb000bae 	bl	808089d4 <xAreGenericQueueTasksStillRunning>
80805b18:	e3500001 	cmp	r0, #1
80805b1c:	0a000005 	beq	80805b38 <vCheckTask+0x1ac>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: GenQ\r\n", sizeof( "Fail: GenQ\r\n" ) );
80805b20:	e3091a48 	movw	r1, #39496	; 0x9a48
80805b24:	e3a0200d 	mov	r2, #13
80805b28:	e3481080 	movt	r1, #32896	; 0x8080
80805b2c:	e3a00002 	mov	r0, #2
//			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: FloatMaths\r\n", sizeof( "Fail: FloatMaths\r\n" ) );
//		}

		if( xAreGenericQueueTasksStillRunning() != pdTRUE )
		{
			xErrorOccurred = pdTRUE;
80805b30:	e3a04001 	mov	r4, #1
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: GenQ\r\n", sizeof( "Fail: GenQ\r\n" ) );
80805b34:	eb0005ff 	bl	80807338 <vSerialPutString>
		}

		if( xAreQueuePeekTasksStillRunning() != pdTRUE )
80805b38:	eb000d77 	bl	8080911c <xAreQueuePeekTasksStillRunning>
80805b3c:	e3500001 	cmp	r0, #1
80805b40:	1affffa0 	bne	808059c8 <vCheckTask+0x3c>
		{
			xErrorOccurred = pdTRUE;
			vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Fail: PeekQ\r\n", sizeof( "Fail: PeekQ\r\n" ) );
		}

		if( xAreRecursiveMutexTasksStillRunning() != pdTRUE )
80805b44:	eb000e1d 	bl	808093c0 <xAreRecursiveMutexTasksStillRunning>
80805b48:	e3500001 	cmp	r0, #1
80805b4c:	1affffa5 	bne	808059e8 <vCheckTask+0x5c>
		}
*/
		/* Send either a pass or fail message.  If an error is found it is
		never cleared again.  We do not write directly to the LCD, but instead
		queue a message for display by the print task. */
		if( xErrorOccurred == pdTRUE )
80805b50:	e3540001 	cmp	r4, #1
80805b54:	0affffa8 	beq	808059fc <vCheckTask+0x70>
			}
			sprintf( (char *)cBuffer, "Fail: %lu\r\n", xFailureTime / 1000 );
		}
		else
		{
			sprintf( (char *)cBuffer, "Pass: %lu\r\n", xLastExecutionTime / 1000 );
80805b58:	e59d2004 	ldr	r2, [sp, #4]
80805b5c:	e3091a88 	movw	r1, #39560	; 0x9a88
80805b60:	e3481080 	movt	r1, #32896	; 0x8080
80805b64:	e28d0008 	add	r0, sp, #8
80805b68:	e3a04000 	mov	r4, #0
80805b6c:	e0832792 	umull	r2, r3, r2, r7
80805b70:	e1a02323 	lsr	r2, r3, #6
80805b74:	eb0005b6 	bl	80807254 <sprintf>
80805b78:	eaffffa8 	b	80805a20 <vCheckTask+0x94>

80805b7c <vApplicationTickHook>:
}
/*----------------------------------------------------------------------------*/

void vApplicationTickHook( void )
{
	vSerialPutString( (xComPortHandle)mainPRINT_PORT, (const signed char * const)"Tick\r\n", 6 );
80805b7c:	e3091ac4 	movw	r1, #39620	; 0x9ac4
80805b80:	e3a02006 	mov	r2, #6
80805b84:	e3481080 	movt	r1, #32896	; 0x8080
80805b88:	e3a00002 	mov	r0, #2
80805b8c:	ea0005e9 	b	80807338 <vSerialPutString>

80805b90 <vApplicationIdleHook>:
}
/*----------------------------------------------------------------------------*/

void vApplicationIdleHook( void )
{
80805b90:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
80805b94:	e24dd00c 	sub	sp, sp, #12
signed char cChar;
	if ( pdTRUE == xSerialGetChar( (xComPortHandle)mainPRINT_PORT, &cChar, 0UL ) )
80805b98:	e3a02000 	mov	r2, #0
80805b9c:	e28d1007 	add	r1, sp, #7
80805ba0:	e3a00002 	mov	r0, #2
80805ba4:	eb0005f3 	bl	80807378 <xSerialGetChar>
80805ba8:	e3500001 	cmp	r0, #1
80805bac:	0a000001 	beq	80805bb8 <vApplicationIdleHook+0x28>
	{
		(void)xSerialPutChar( (xComPortHandle)mainPRINT_PORT, cChar, 0UL );
	}
}
80805bb0:	e28dd00c 	add	sp, sp, #12
80805bb4:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)
void vApplicationIdleHook( void )
{
signed char cChar;
	if ( pdTRUE == xSerialGetChar( (xComPortHandle)mainPRINT_PORT, &cChar, 0UL ) )
	{
		(void)xSerialPutChar( (xComPortHandle)mainPRINT_PORT, cChar, 0UL );
80805bb8:	e3a02000 	mov	r2, #0
80805bbc:	e1dd10d7 	ldrsb	r1, [sp, #7]
80805bc0:	e3a00002 	mov	r0, #2
80805bc4:	eb0005ec 	bl	8080737c <xSerialPutChar>
	}
}
80805bc8:	e28dd00c 	add	sp, sp, #12
80805bcc:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

80805bd0 <vApplicationMallocFailedHook>:
}
/*----------------------------------------------------------------------------*/

void vApplicationMallocFailedHook( void )
{
	__asm volatile (" smc #0 ");
80805bd0:	e1600070 	smc	0
80805bd4:	e12fff1e 	bx	lr

80805bd8 <vAssertCalled>:
}
/*----------------------------------------------------------------------------*/

extern void vAssertCalled( char *file, int line )
{
	printf("Assertion failed at %s, line %d\n\r",file,line);
80805bd8:	e1a02001 	mov	r2, r1
80805bdc:	e1a01000 	mov	r1, r0
80805be0:	e3090acc 	movw	r0, #39628	; 0x9acc
	__asm volatile (" smc #0 ");
}
/*----------------------------------------------------------------------------*/

extern void vAssertCalled( char *file, int line )
{
80805be4:	e92d4010 	push	{r4, lr}
	printf("Assertion failed at %s, line %d\n\r",file,line);
80805be8:	e3480080 	movt	r0, #32896	; 0x8080
80805bec:	eb00058c 	bl	80807224 <printf>
	taskDISABLE_INTERRUPTS();
80805bf0:	ebfffd1c 	bl	80805068 <xPortSetInterruptMask>
80805bf4:	eafffffe 	b	80805bf4 <vAssertCalled+0x1c>

80805bf8 <main>:
#define SYS_CFGDATA (*(volatile uint32_t *)0x100000a0)
#define SYS_CFGCTRL (*(volatile uint32_t *)0x100000a4)
#define SYS_CFGSTAT (*(volatile uint32_t *)0x100000a8)

int main( void )
{
80805bf8:	e92d4070 	push	{r4, r5, r6, lr}
80805bfc:	e24dd028 	sub	sp, sp, #40	; 0x28
	portDISABLE_INTERRUPTS();

	/* Install the Spurious Interrupt Handler to help catch interrupts. */
extern void vPortUnknownInterruptHandler( void *pvParameter );
extern void vPortInstallInterruptHandler( void (*vHandler)(void *), void *pvParameter, unsigned long ulVector, unsigned char ucEdgeTriggered, unsigned char ucPriority, unsigned char ucProcessorTargets );
	for ( ulVector = 0; ulVector < portMAX_VECTORS; ulVector++ )
80805c00:	e3a04000 	mov	r4, #0
		vPortInstallInterruptHandler( vPortUnknownInterruptHandler, (void *)ulVector, ulVector, pdTRUE, configMAX_SYSCALL_INTERRUPT_PRIORITY, 1 );
80805c04:	e3a06001 	mov	r6, #1
80805c08:	e3a050a0 	mov	r5, #160	; 0xa0
{
unsigned long ulVector = 0UL;
unsigned long ulValue = 0UL;
char cAddress[32];

	portDISABLE_INTERRUPTS();
80805c0c:	ebfffd15 	bl	80805068 <xPortSetInterruptMask>

	/* Install the Spurious Interrupt Handler to help catch interrupts. */
extern void vPortUnknownInterruptHandler( void *pvParameter );
extern void vPortInstallInterruptHandler( void (*vHandler)(void *), void *pvParameter, unsigned long ulVector, unsigned char ucEdgeTriggered, unsigned char ucPriority, unsigned char ucProcessorTargets );
	for ( ulVector = 0; ulVector < portMAX_VECTORS; ulVector++ )
		vPortInstallInterruptHandler( vPortUnknownInterruptHandler, (void *)ulVector, ulVector, pdTRUE, configMAX_SYSCALL_INTERRUPT_PRIORITY, 1 );
80805c10:	e3a03001 	mov	r3, #1
80805c14:	e3050090 	movw	r0, #20624	; 0x5090
80805c18:	e1a02004 	mov	r2, r4
80805c1c:	e1a01004 	mov	r1, r4
80805c20:	e88d0060 	stm	sp, {r5, r6}
	portDISABLE_INTERRUPTS();

	/* Install the Spurious Interrupt Handler to help catch interrupts. */
extern void vPortUnknownInterruptHandler( void *pvParameter );
extern void vPortInstallInterruptHandler( void (*vHandler)(void *), void *pvParameter, unsigned long ulVector, unsigned char ucEdgeTriggered, unsigned char ucPriority, unsigned char ucProcessorTargets );
	for ( ulVector = 0; ulVector < portMAX_VECTORS; ulVector++ )
80805c24:	e0844003 	add	r4, r4, r3
		vPortInstallInterruptHandler( vPortUnknownInterruptHandler, (void *)ulVector, ulVector, pdTRUE, configMAX_SYSCALL_INTERRUPT_PRIORITY, 1 );
80805c28:	e3480080 	movt	r0, #32896	; 0x8080
80805c2c:	ebfffcc1 	bl	80804f38 <vPortInstallInterruptHandler>
	portDISABLE_INTERRUPTS();

	/* Install the Spurious Interrupt Handler to help catch interrupts. */
extern void vPortUnknownInterruptHandler( void *pvParameter );
extern void vPortInstallInterruptHandler( void (*vHandler)(void *), void *pvParameter, unsigned long ulVector, unsigned char ucEdgeTriggered, unsigned char ucPriority, unsigned char ucProcessorTargets );
	for ( ulVector = 0; ulVector < portMAX_VECTORS; ulVector++ )
80805c30:	e3540020 	cmp	r4, #32
80805c34:	1afffff5 	bne	80805c10 <main+0x18>
		vPortInstallInterruptHandler( vPortUnknownInterruptHandler, (void *)ulVector, ulVector, pdTRUE, configMAX_SYSCALL_INTERRUPT_PRIORITY, 1 );

extern void vUARTInitialise(unsigned long ulUARTPeripheral, unsigned long ulBaud, unsigned long ulQueueSize );
	vUARTInitialise( mainPRINT_PORT, mainPRINT_BAUDRATE, 64 );
80805c38:	e3a01cc2 	mov	r1, #49664	; 0xc200
80805c3c:	e3a02040 	mov	r2, #64	; 0x40
80805c40:	e3401001 	movt	r1, #1
80805c44:	e3a00002 	mov	r0, #2
80805c48:	eb00002b 	bl	80805cfc <vUARTInitialise>

	ulValue = portCORE_ID();
	sprintf( cAddress, "Core: %ld\r\n", ulValue );
80805c4c:	e3091a94 	movw	r1, #39572	; 0x9a94
80805c50:	e28d0008 	add	r0, sp, #8
80805c54:	e3481080 	movt	r1, #32896	; 0x8080
void vUARTEchoTask( void *pvParameters );
	xTaskCreate( vUARTEchoTask, (const char * const)"UARTEcho", configMINIMAL_STACK_SIZE, (xComPortHandle)mainPRINT_PORT, tskIDLE_PRIORITY + 4, NULL );
#endif /* configPLATFORM */

	/* Start the tasks defined within the file. */
	xTaskCreate( vCheckTask, (const char * const)"Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
80805c58:	e3a05000 	mov	r5, #0
80805c5c:	ee102fb0 	mrc	15, 0, r2, cr0, cr0, {5}

extern void vUARTInitialise(unsigned long ulUARTPeripheral, unsigned long ulBaud, unsigned long ulQueueSize );
	vUARTInitialise( mainPRINT_PORT, mainPRINT_BAUDRATE, 64 );

	ulValue = portCORE_ID();
	sprintf( cAddress, "Core: %ld\r\n", ulValue );
80805c60:	e2022003 	and	r2, r2, #3
80805c64:	eb00057a 	bl	80807254 <sprintf>
	vSerialPutString((xComPortHandle)configUART_PORT,(const signed char * const)cAddress, sizeof(cAddress) );
80805c68:	e1a02004 	mov	r2, r4
80805c6c:	e28d1008 	add	r1, sp, #8
80805c70:	e3a00002 	mov	r0, #2
80805c74:	eb0005af 	bl	80807338 <vSerialPutString>
{
	/* Initialise the Hardware. */
	prvSetupHardware();

	/* Start the standard demo tasks. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
80805c78:	e1a00005 	mov	r0, r5
80805c7c:	eb000b91 	bl	80808ac8 <vStartIntegerMathTasks>
    vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
80805c80:	e3a00002 	mov	r0, #2
80805c84:	eb000bed 	bl	80808c40 <vStartPolledQueueTasks>
    vStartSemaphoreTasks( mainSEM_TEST_PRIORITY );
80805c88:	e3a00001 	mov	r0, #1
80805c8c:	eb000e5a 	bl	808095fc <vStartSemaphoreTasks>
    vStartBlockingQueueTasks( mainBLOCK_Q_PRIORITY );
80805c90:	e3a00002 	mov	r0, #2
80805c94:	eb000627 	bl	80807538 <vStartBlockingQueueTasks>
    vStartCountingSemaphoreTasks();
80805c98:	eb0008d3 	bl	80807fec <vStartCountingSemaphoreTasks>
    vStartDynamicPriorityTasks();
80805c9c:	eb000995 	bl	808082f8 <vStartDynamicPriorityTasks>
//    vStartMathTasks( tskIDLE_PRIORITY );
    vStartGenericQueueTasks( mainGEN_Q_PRIORITY );
80805ca0:	e1a00005 	mov	r0, r5
80805ca4:	eb000b14 	bl	808088fc <vStartGenericQueueTasks>
    vStartQueuePeekTasks();
80805ca8:	eb000ce4 	bl	80809040 <vStartQueuePeekTasks>
    vStartRecursiveMutexTasks();
80805cac:	eb000d99 	bl	80809318 <vStartRecursiveMutexTasks>
void vUARTEchoTask( void *pvParameters );
	xTaskCreate( vUARTEchoTask, (const char * const)"UARTEcho", configMINIMAL_STACK_SIZE, (xComPortHandle)mainPRINT_PORT, tskIDLE_PRIORITY + 4, NULL );
#endif /* configPLATFORM */

	/* Start the tasks defined within the file. */
	xTaskCreate( vCheckTask, (const char * const)"Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
80805cb0:	e3a02003 	mov	r2, #3
80805cb4:	e3091aa0 	movw	r1, #39584	; 0x9aa0
80805cb8:	e305098c 	movw	r0, #22924	; 0x598c
80805cbc:	e1a03005 	mov	r3, r5
80805cc0:	e58d2000 	str	r2, [sp]
80805cc4:	e3481080 	movt	r1, #32896	; 0x8080
80805cc8:	e3a02b01 	mov	r2, #1024	; 0x400
80805ccc:	e58d5004 	str	r5, [sp, #4]
80805cd0:	e3480080 	movt	r0, #32896	; 0x8080
80805cd4:	ebffef2c 	bl	8080198c <xTaskCreate>

	/* Start the scheduler. */
	vTaskStartScheduler();
80805cd8:	ebfff2fb 	bl	808028cc <vTaskStartScheduler>

	/* Should never reach here. */
	vSerialPutString((xComPortHandle)mainPRINT_PORT, (const signed char * const)"Should never reach here!\r\n", 26 );
80805cdc:	e3091aa8 	movw	r1, #39592	; 0x9aa8
80805ce0:	e3a0201a 	mov	r2, #26
80805ce4:	e3481080 	movt	r1, #32896	; 0x8080
80805ce8:	e3a00002 	mov	r0, #2
80805cec:	eb000591 	bl	80807338 <vSerialPutString>

	/* Will only get here if there was not enough heap space to create the idle task. */
	return 0;
}
80805cf0:	e1a00005 	mov	r0, r5
80805cf4:	e28dd028 	add	sp, sp, #40	; 0x28
80805cf8:	e8bd8070 	pop	{r4, r5, r6, pc}

80805cfc <vUARTInitialise>:
#if configPLATFORM == 3

//#define UART_CLK 3686400

void vUARTInitialise(unsigned long ulUARTPeripheral, unsigned long ulBaud, unsigned long ulQueueSize )
{
80805cfc:	e12fff1e 	bx	lr

80805d00 <xUARTSendCharacter>:
/*----------------------------------------------------------------------------*/

portBASE_TYPE xUARTSendCharacter( unsigned long ulUARTPeripheral, signed char cChar, portTickType xDelay )
{
	unsigned long base;
	switch(ulUARTPeripheral)
80805d00:	e3500003 	cmp	r0, #3
80805d04:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
80805d08:	ea00001d 	b	80805d84 <xUARTSendCharacter+0x84>
80805d0c:	80805d48 	.word	0x80805d48
80805d10:	80805d1c 	.word	0x80805d1c
80805d14:	80805d70 	.word	0x80805d70
80805d18:	80805d5c 	.word	0x80805d5c
80805d1c:	e3a0c903 	mov	ip, #49152	; 0xc000
80805d20:	e30c2014 	movw	r2, #49172	; 0xc014
80805d24:	e344c806 	movt	ip, #18438	; 0x4806
80805d28:	e3442806 	movt	r2, #18438	; 0x4806
		case 2: base=UART2_BASE; break;
		case 3: base=UART3_BASE; break;
		default: return pdFALSE;
	}

	while((UART_LSR(base)&0x20)==0);
80805d2c:	e5d23000 	ldrb	r3, [r2]
80805d30:	e3130020 	tst	r3, #32
80805d34:	0afffffc 	beq	80805d2c <xUARTSendCharacter+0x2c>
	UART_RBR(base)=cChar;
80805d38:	e6ef1071 	uxtb	r1, r1

	return pdTRUE;
80805d3c:	e3a00001 	mov	r0, #1
		case 3: base=UART3_BASE; break;
		default: return pdFALSE;
	}

	while((UART_LSR(base)&0x20)==0);
	UART_RBR(base)=cChar;
80805d40:	e5cc1000 	strb	r1, [ip]

	return pdTRUE;
80805d44:	e12fff1e 	bx	lr
/*----------------------------------------------------------------------------*/

portBASE_TYPE xUARTSendCharacter( unsigned long ulUARTPeripheral, signed char cChar, portTickType xDelay )
{
	unsigned long base;
	switch(ulUARTPeripheral)
80805d48:	e3a0ca0a 	mov	ip, #40960	; 0xa000
80805d4c:	e30a2014 	movw	r2, #40980	; 0xa014
80805d50:	e344c806 	movt	ip, #18438	; 0x4806
80805d54:	e3442806 	movt	r2, #18438	; 0x4806
80805d58:	eafffff3 	b	80805d2c <xUARTSendCharacter+0x2c>
	{
		case 0: base=UART0_BASE; break;
		case 1: base=UART1_BASE; break;
		case 2: base=UART2_BASE; break;
		case 3: base=UART3_BASE; break;
80805d5c:	e3a0ca0e 	mov	ip, #57344	; 0xe000
80805d60:	e30e2014 	movw	r2, #57364	; 0xe014
80805d64:	e344c806 	movt	ip, #18438	; 0x4806
80805d68:	e3442806 	movt	r2, #18438	; 0x4806
80805d6c:	eaffffee 	b	80805d2c <xUARTSendCharacter+0x2c>
	unsigned long base;
	switch(ulUARTPeripheral)
	{
		case 0: base=UART0_BASE; break;
		case 1: base=UART1_BASE; break;
		case 2: base=UART2_BASE; break;
80805d70:	e3a0c000 	mov	ip, #0
80805d74:	e3a02014 	mov	r2, #20
80805d78:	e344c802 	movt	ip, #18434	; 0x4802
80805d7c:	e3442802 	movt	r2, #18434	; 0x4802
80805d80:	eaffffe9 	b	80805d2c <xUARTSendCharacter+0x2c>
		case 3: base=UART3_BASE; break;
		default: return pdFALSE;
80805d84:	e3a00000 	mov	r0, #0

	while((UART_LSR(base)&0x20)==0);
	UART_RBR(base)=cChar;

	return pdTRUE;
}
80805d88:	e12fff1e 	bx	lr

80805d8c <xUARTReceiveCharacter>:
/*----------------------------------------------------------------------------*/

portBASE_TYPE xUARTReceiveCharacter( unsigned long ulUARTPeripheral, signed char *pcChar, portTickType xDelay )
{
	unsigned long base;
	switch(ulUARTPeripheral)
80805d8c:	e3500003 	cmp	r0, #3
80805d90:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
80805d94:	ea00001c 	b	80805e0c <xUARTReceiveCharacter+0x80>
80805d98:	80805dd0 	.word	0x80805dd0
80805d9c:	80805da8 	.word	0x80805da8
80805da0:	80805df8 	.word	0x80805df8
80805da4:	80805de4 	.word	0x80805de4
80805da8:	e3a02903 	mov	r2, #49152	; 0xc000
80805dac:	e30c3014 	movw	r3, #49172	; 0xc014
80805db0:	e3442806 	movt	r2, #18438	; 0x4806
80805db4:	e3443806 	movt	r3, #18438	; 0x4806
		case 2: base=UART2_BASE; break;
		case 3: base=UART3_BASE; break;
		default: return pdFALSE;
	}

	if((UART_LSR(base)&0x01)==0) return pdFALSE;
80805db8:	e5d30000 	ldrb	r0, [r3]
80805dbc:	e2100001 	ands	r0, r0, #1

	*pcChar=UART_RBR(base);
80805dc0:	15d23000 	ldrbne	r3, [r2]
	return pdTRUE;
80805dc4:	13a00001 	movne	r0, #1
		default: return pdFALSE;
	}

	if((UART_LSR(base)&0x01)==0) return pdFALSE;

	*pcChar=UART_RBR(base);
80805dc8:	15c13000 	strbne	r3, [r1]
	return pdTRUE;
80805dcc:	e12fff1e 	bx	lr
/*----------------------------------------------------------------------------*/

portBASE_TYPE xUARTReceiveCharacter( unsigned long ulUARTPeripheral, signed char *pcChar, portTickType xDelay )
{
	unsigned long base;
	switch(ulUARTPeripheral)
80805dd0:	e3a02a0a 	mov	r2, #40960	; 0xa000
80805dd4:	e30a3014 	movw	r3, #40980	; 0xa014
80805dd8:	e3442806 	movt	r2, #18438	; 0x4806
80805ddc:	e3443806 	movt	r3, #18438	; 0x4806
80805de0:	eafffff4 	b	80805db8 <xUARTReceiveCharacter+0x2c>
	{
		case 0: base=UART0_BASE; break;
		case 1: base=UART1_BASE; break;
		case 2: base=UART2_BASE; break;
		case 3: base=UART3_BASE; break;
80805de4:	e3a02a0e 	mov	r2, #57344	; 0xe000
80805de8:	e30e3014 	movw	r3, #57364	; 0xe014
80805dec:	e3442806 	movt	r2, #18438	; 0x4806
80805df0:	e3443806 	movt	r3, #18438	; 0x4806
80805df4:	eaffffef 	b	80805db8 <xUARTReceiveCharacter+0x2c>
	unsigned long base;
	switch(ulUARTPeripheral)
	{
		case 0: base=UART0_BASE; break;
		case 1: base=UART1_BASE; break;
		case 2: base=UART2_BASE; break;
80805df8:	e3a02000 	mov	r2, #0
80805dfc:	e3a03014 	mov	r3, #20
80805e00:	e3442802 	movt	r2, #18434	; 0x4802
80805e04:	e3443802 	movt	r3, #18434	; 0x4802
80805e08:	eaffffea 	b	80805db8 <xUARTReceiveCharacter+0x2c>
		case 3: base=UART3_BASE; break;
		default: return pdFALSE;
80805e0c:	e3a00000 	mov	r0, #0

	if((UART_LSR(base)&0x01)==0) return pdFALSE;

	*pcChar=UART_RBR(base);
	return pdTRUE;
}
80805e10:	e12fff1e 	bx	lr

80805e14 <vRTCInitialise>:
#define RTCICR				( (unsigned portBASE_TYPE * volatile )( RTC_BASE + 0x01C ) )	/* Interrupt clear Register */
/*----------------------------------------------------------------------------*/

void vRTCInitialise( void )
{
volatile unsigned long ulRTCValue = *RTCDR;
80805e14:	e3a03a07 	mov	r3, #28672	; 0x7000
#define RTCMIS				( (unsigned portBASE_TYPE * volatile )( RTC_BASE + 0x018 ) )	/* Masked interrupt status Register */
#define RTCICR				( (unsigned portBASE_TYPE * volatile )( RTC_BASE + 0x01C ) )	/* Interrupt clear Register */
/*----------------------------------------------------------------------------*/

void vRTCInitialise( void )
{
80805e18:	e24dd008 	sub	sp, sp, #8
volatile unsigned long ulRTCValue = *RTCDR;
80805e1c:	e3413001 	movt	r3, #4097	; 0x1001
80805e20:	e5932000 	ldr	r2, [r3]
80805e24:	e58d2004 	str	r2, [sp, #4]
	*RTCLR = ulRTCValue;
80805e28:	e59d2004 	ldr	r2, [sp, #4]
80805e2c:	e5832008 	str	r2, [r3, #8]
}
80805e30:	e28dd008 	add	sp, sp, #8
80805e34:	e12fff1e 	bx	lr

80805e38 <vRTCEnable>:
/*----------------------------------------------------------------------------*/

void vRTCEnable( unsigned long ulOffset )
{
	*RTCIMSC = 1;
80805e38:	e3a03a07 	mov	r3, #28672	; 0x7000
80805e3c:	e3a01001 	mov	r1, #1
80805e40:	e3413001 	movt	r3, #4097	; 0x1001
	*RTCCR = 1;
	*RTCMR = *RTCDR + ulOffset;
80805e44:	e5932000 	ldr	r2, [r3]
}
/*----------------------------------------------------------------------------*/

void vRTCEnable( unsigned long ulOffset )
{
	*RTCIMSC = 1;
80805e48:	e5831010 	str	r1, [r3, #16]
	*RTCCR = 1;
80805e4c:	e583100c 	str	r1, [r3, #12]
	*RTCMR = *RTCDR + ulOffset;
80805e50:	e0820000 	add	r0, r2, r0
80805e54:	e5830004 	str	r0, [r3, #4]
80805e58:	e12fff1e 	bx	lr

80805e5c <vRTCAcknowledgeInterrupt>:
}
/*----------------------------------------------------------------------------*/

void vRTCAcknowledgeInterrupt( unsigned long ulOffset )
{
	if ( 0 != ulOffset )
80805e5c:	e3500000 	cmp	r0, #0
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
80805e60:	e3a01a01 	mov	r1, #4096	; 0x1000
	{
		*RTCMR = *RTCDR + ulOffset;
80805e64:	13a03a07 	movne	r3, #28672	; 0x7000
80805e68:	e3441824 	movt	r1, #18468	; 0x4824
80805e6c:	13413001 	movtne	r3, #4097	; 0x1001
80805e70:	15932000 	ldrne	r2, [r3]
80805e74:	10820000 	addne	r0, r2, r0
	}
	*RTCICR = 1;
80805e78:	e3a02001 	mov	r2, #1

void vRTCAcknowledgeInterrupt( unsigned long ulOffset )
{
	if ( 0 != ulOffset )
	{
		*RTCMR = *RTCDR + ulOffset;
80805e7c:	15830004 	strne	r0, [r3, #4]
	}
	*RTCICR = 1;
80805e80:	e3a03a07 	mov	r3, #28672	; 0x7000
80805e84:	e3413001 	movt	r3, #4097	; 0x1001
80805e88:	e583201c 	str	r2, [r3, #28]
80805e8c:	e5913200 	ldr	r3, [r1, #512]	; 0x200
80805e90:	e3130001 	tst	r3, #1
80805e94:	112fff1e 	bxne	lr
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80805e98:	e3a02801 	mov	r2, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80805e9c:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80805ea0:	e2033003 	and	r3, r3, #3
80805ea4:	e1a03312 	lsl	r3, r2, r3
80805ea8:	e3833001 	orr	r3, r3, #1
80805eac:	e5813f00 	str	r3, [r1, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
80805eb0:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
80805eb4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805eb8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ebc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ec0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ec4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ec8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ecc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ed0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ed4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ed8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805edc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ee0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ee4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ee8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805eec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ef0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ef4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805ef8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805efc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f00:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f04:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f08:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f0c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f10:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f14:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f18:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f1c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f20:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f24:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f28:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80805f2c:	e320f000 	nop	{0}
80805f30:	e12fff1e 	bx	lr

80805f34 <printstring>:
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80805f34:	e3520000 	cmp	r2, #0
80805f38:	d3a03000 	movle	r3, #0
80805f3c:	c2033001 	andgt	r3, r3, #1
	return bufferstart;
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
80805f40:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80805f44:	e3530000 	cmp	r3, #0
	return bufferstart;
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
80805f48:	e1a05000 	mov	r5, r0
80805f4c:	e1a07001 	mov	r7, r1
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80805f50:	e1a06002 	mov	r6, r2
80805f54:	0a00001a 	beq	80805fc4 <printstring+0x90>
	{
		const char *end=string;
		while(*end) end++;
80805f58:	e5d11000 	ldrb	r1, [r1]
80805f5c:	e3510000 	cmp	r1, #0
80805f60:	01a04002 	moveq	r4, r2
80805f64:	0a000008 	beq	80805f8c <printstring+0x58>
80805f68:	e1a02007 	mov	r2, r7
80805f6c:	e5f23001 	ldrb	r3, [r2, #1]!
80805f70:	e3530000 	cmp	r3, #0
80805f74:	1afffffc 	bne	80805f6c <printstring+0x38>

		int length=end-string;
		for(int i=0;i<width-length;i++)
80805f78:	e0674002 	rsb	r4, r7, r2
80805f7c:	e0644006 	rsb	r4, r4, r6
80805f80:	e3540000 	cmp	r4, #0
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
80805f84:	d1a04003 	movle	r4, r3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80805f88:	da000011 	ble	80805fd4 <printstring+0xa0>
80805f8c:	e3550000 	cmp	r5, #0
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
80805f90:	13a02000 	movne	r2, #0
	return count;
}

static void printchar(char **out,int c)
{
	if(out) *(*out)++=c;
80805f94:	13a00020 	movne	r0, #32
80805f98:	0a00003d 	beq	80806094 <printstring+0x160>
80805f9c:	e5951000 	ldr	r1, [r5]
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80805fa0:	e2822001 	add	r2, r2, #1
80805fa4:	e1520004 	cmp	r2, r4
	return count;
}

static void printchar(char **out,int c)
{
	if(out) *(*out)++=c;
80805fa8:	e2813001 	add	r3, r1, #1
80805fac:	e5853000 	str	r3, [r5]
80805fb0:	e5c10000 	strb	r0, [r1]
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80805fb4:	bafffff8 	blt	80805f9c <printstring+0x68>
80805fb8:	e3540001 	cmp	r4, #1
80805fbc:	b3a04001 	movlt	r4, #1
80805fc0:	ea000000 	b	80805fc8 <printstring+0x94>
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
80805fc4:	e1a04003 	mov	r4, r3
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80805fc8:	e5d71000 	ldrb	r1, [r7]
80805fcc:	e3510000 	cmp	r1, #0
80805fd0:	0a000009 	beq	80805ffc <printstring+0xc8>
80805fd4:	e3550000 	cmp	r5, #0
80805fd8:	0a000018 	beq	80806040 <printstring+0x10c>
	return count;
}

static void printchar(char **out,int c)
{
	if(out) *(*out)++=c;
80805fdc:	e5953000 	ldr	r3, [r5]

	// Print the contents of the string.
	while(*string)
	{
		printchar(out,*string);
		count++;
80805fe0:	e2844001 	add	r4, r4, #1
	return count;
}

static void printchar(char **out,int c)
{
	if(out) *(*out)++=c;
80805fe4:	e2832001 	add	r2, r3, #1
80805fe8:	e5852000 	str	r2, [r5]
80805fec:	e5c31000 	strb	r1, [r3]
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80805ff0:	e5f71001 	ldrb	r1, [r7, #1]!
80805ff4:	e3510000 	cmp	r1, #0
80805ff8:	1afffff7 	bne	80805fdc <printstring+0xa8>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80805ffc:	e1560004 	cmp	r6, r4
80806000:	da00000c 	ble	80806038 <printstring+0x104>
80806004:	e3550000 	cmp	r5, #0
80806008:	11a03004 	movne	r3, r4
	return count;
}

static void printchar(char **out,int c)
{
	if(out) *(*out)++=c;
8080600c:	13a00020 	movne	r0, #32
80806010:	0a000015 	beq	8080606c <printstring+0x138>
80806014:	e5952000 	ldr	r2, [r5]

	// Print any remaining padding on the right, if needed.
	while(count<width)
	{
		printchar(out,' ');
		count++;
80806018:	e2833001 	add	r3, r3, #1
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
8080601c:	e1560003 	cmp	r6, r3
	return count;
}

static void printchar(char **out,int c)
{
	if(out) *(*out)++=c;
80806020:	e2821001 	add	r1, r2, #1
80806024:	e5851000 	str	r1, [r5]
80806028:	e5c20000 	strb	r0, [r2]
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
8080602c:	1afffff8 	bne	80806014 <printstring+0xe0>
		printchar(out,' ');
		count++;
	}

	return count;
}
80806030:	e1a00006 	mov	r0, r6
80806034:	e8bd87f0 	pop	{r4, r5, r6, r7, r8, r9, sl, pc}
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806038:	e1a06004 	mov	r6, r4
	{
		printchar(out,' ');
		count++;
	}

	return count;
8080603c:	eafffffb 	b	80806030 <printstring+0xfc>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806040:	ee108fb0 	mrc	15, 0, r8, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806044:	e2088003 	and	r8, r8, #3
80806048:	e6af1071 	sxtb	r1, r1
8080604c:	e3a02000 	mov	r2, #0
80806050:	e1a00008 	mov	r0, r8
80806054:	ebffff29 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806058:	e5f71001 	ldrb	r1, [r7, #1]!
	{
		printchar(out,*string);
		count++;
8080605c:	e2844001 	add	r4, r4, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806060:	e3510000 	cmp	r1, #0
80806064:	1afffff7 	bne	80806048 <printstring+0x114>
80806068:	eaffffe3 	b	80805ffc <printstring+0xc8>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
8080606c:	ee105fb0 	mrc	15, 0, r5, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806070:	e2055003 	and	r5, r5, #3

	// Print any remaining padding on the right, if needed.
	while(count<width)
	{
		printchar(out,' ');
		count++;
80806074:	e2844001 	add	r4, r4, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806078:	e3a02000 	mov	r2, #0
8080607c:	e3a01020 	mov	r1, #32
80806080:	e1a00005 	mov	r0, r5
80806084:	ebffff1d 	bl	80805d00 <xUARTSendCharacter>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806088:	e1560004 	cmp	r6, r4
8080608c:	1afffff8 	bne	80806074 <printstring+0x140>
80806090:	eaffffe6 	b	80806030 <printstring+0xfc>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806094:	ee109fb0 	mrc	15, 0, r9, cr0, cr0, {5}
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
80806098:	e1a08005 	mov	r8, r5
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
8080609c:	e2099003 	and	r9, r9, #3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
808060a0:	e2888001 	add	r8, r8, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808060a4:	e3a02000 	mov	r2, #0
808060a8:	e3a01020 	mov	r1, #32
808060ac:	e1a00009 	mov	r0, r9
808060b0:	ebffff12 	bl	80805d00 <xUARTSendCharacter>
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
808060b4:	e1580004 	cmp	r8, r4
808060b8:	bafffff8 	blt	808060a0 <printstring+0x16c>
808060bc:	eaffffbd 	b	80805fb8 <printstring+0x84>

808060c0 <print>:
	printchar(0,'\n');
	return count+1;
}

static int print(char **out,const char *format,va_list args)
{
808060c0:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
808060c4:	e1a04001 	mov	r4, r1
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
808060c8:	e5d11000 	ldrb	r1, [r1]
	printchar(0,'\n');
	return count+1;
}

static int print(char **out,const char *format,va_list args)
{
808060cc:	e24dd09c 	sub	sp, sp, #156	; 0x9c
808060d0:	e1a08000 	mov	r8, r0
808060d4:	e58d2004 	str	r2, [sp, #4]
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
808060d8:	e3510000 	cmp	r1, #0
808060dc:	0a000102 	beq	808064ec <print+0x42c>

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808060e0:	e30cbccd 	movw	fp, #52429	; 0xcccd
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
808060e4:	e3a09000 	mov	r9, #0
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808060e8:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808060ec:	e34cbccc 	movt	fp, #52428	; 0xcccc
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808060f0:	e58d3008 	str	r3, [sp, #8]
808060f4:	ea00000a 	b	80806124 <print+0x64>
	return count;
}

static void printchar(char **out,int c)
{
	if(out) *(*out)++=c;
808060f8:	e3580000 	cmp	r8, #0
808060fc:	0a000038 	beq	808061e4 <print+0x124>
80806100:	e5983000 	ldr	r3, [r8]
80806104:	e2832001 	add	r2, r3, #1
80806108:	e5882000 	str	r2, [r8]
8080610c:	e5c31000 	strb	r1, [r3]
		}
		else
		{
			printnormal:
			printchar(out,*format);
			count++;
80806110:	e2899001 	add	r9, r9, #1
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
80806114:	e5d41001 	ldrb	r1, [r4, #1]
			printnormal:
			printchar(out,*format);
			count++;
		}

		format++;
80806118:	e2844001 	add	r4, r4, #1
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
8080611c:	e3510000 	cmp	r1, #0
80806120:	0a00001e 	beq	808061a0 <print+0xe0>
	{
		if(*format=='%')
80806124:	e3510025 	cmp	r1, #37	; 0x25
80806128:	1afffff2 	bne	808060f8 <print+0x38>
		{
			format++;

			if(*format=='%') goto printnormal;
8080612c:	e5d43001 	ldrb	r3, [r4, #1]

	while(*format)
	{
		if(*format=='%')
		{
			format++;
80806130:	e2844001 	add	r4, r4, #1

			if(*format=='%') goto printnormal;
80806134:	e3530025 	cmp	r3, #37	; 0x25
80806138:	0affffee 	beq	808060f8 <print+0x38>
8080613c:	e3a00000 	mov	r0, #0
80806140:	e1a02004 	mov	r2, r4
80806144:	e1a03000 	mov	r3, r0
80806148:	e1a05000 	mov	r5, r0
8080614c:	e3a07001 	mov	r7, #1
80806150:	e1a04002 	mov	r4, r2
			bool padleft=true,padzero=false,alternate=false;

			// Parse flag characters.
			for(;;)
			{
				if(*format==0)
80806154:	e4d21001 	ldrb	r1, [r2], #1
80806158:	e3510000 	cmp	r1, #0
8080615c:	0a00000f 	beq	808061a0 <print+0xe0>
				{
					// Premature format string end.
					goto end;
				}
				else if(*format=='#')
80806160:	e3510023 	cmp	r1, #35	; 0x23
80806164:	0a000014 	beq	808061bc <print+0xfc>
				{
					// Alternate form.
					alternate=true;
					format++;
				}
				else if(*format=='-')
80806168:	e351002d 	cmp	r1, #45	; 0x2d
8080616c:	0a000014 	beq	808061c4 <print+0x104>
					// Left justify. Overrides zero padding.
					padleft=false;
					padzero=false;
					format++;
				}
				else if(*format=='0')
80806170:	e3510030 	cmp	r1, #48	; 0x30
80806174:	0a000015 	beq	808061d0 <print+0x110>
					// Zero padding.
					// Overriden by left justification, so check for that.
					if(padleft) padzero=true;
					format++;
				}
				else if(*format=='+')
80806178:	e351002b 	cmp	r1, #43	; 0x2b
8080617c:	0a000016 	beq	808061dc <print+0x11c>
				{
					// Prefix positive numbers with a plus sign. Overrides space prefix.
					positivechar='+';
					format++;
				}
				else if(*format==' ')
80806180:	e3510020 	cmp	r1, #32
80806184:	1a00001c 	bne	808061fc <print+0x13c>
80806188:	e1a04002 	mov	r4, r2
			bool padleft=true,padzero=false,alternate=false;

			// Parse flag characters.
			for(;;)
			{
				if(*format==0)
8080618c:	e4d21001 	ldrb	r1, [r2], #1
				}
				else if(*format==' ')
				{
					// Prefix positive numbers with a space.
					// Overriden by plus prefix, so check for that.
					if(!positivechar) positivechar=' ';
80806190:	e3550000 	cmp	r5, #0
80806194:	03a05020 	moveq	r5, #32
			bool padleft=true,padzero=false,alternate=false;

			// Parse flag characters.
			for(;;)
			{
				if(*format==0)
80806198:	e3510000 	cmp	r1, #0
8080619c:	1affffef 	bne	80806160 <print+0xa0>
		format++;
	}

	end: (void)0;

	if(out) **out=0;
808061a0:	e3580000 	cmp	r8, #0

	va_end(args);

	return count;
}
808061a4:	e1a00009 	mov	r0, r9
		format++;
	}

	end: (void)0;

	if(out) **out=0;
808061a8:	15983000 	ldrne	r3, [r8]
808061ac:	13a02000 	movne	r2, #0
808061b0:	15c32000 	strbne	r2, [r3]

	va_end(args);

	return count;
}
808061b4:	e28dd09c 	add	sp, sp, #156	; 0x9c
808061b8:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
					goto end;
				}
				else if(*format=='#')
				{
					// Alternate form.
					alternate=true;
808061bc:	e3a00001 	mov	r0, #1
808061c0:	eaffffe2 	b	80806150 <print+0x90>
				}
				else if(*format=='-')
				{
					// Left justify. Overrides zero padding.
					padleft=false;
					padzero=false;
808061c4:	e3a03000 	mov	r3, #0
					format++;
				}
				else if(*format=='-')
				{
					// Left justify. Overrides zero padding.
					padleft=false;
808061c8:	e1a07003 	mov	r7, r3
808061cc:	eaffffdf 	b	80806150 <print+0x90>
				}
				else if(*format=='0')
				{
					// Zero padding.
					// Overriden by left justification, so check for that.
					if(padleft) padzero=true;
808061d0:	e3570000 	cmp	r7, #0
808061d4:	13a03001 	movne	r3, #1
808061d8:	eaffffdc 	b	80806150 <print+0x90>
					format++;
				}
				else if(*format=='+')
				{
					// Prefix positive numbers with a plus sign. Overrides space prefix.
					positivechar='+';
808061dc:	e1a05001 	mov	r5, r1
808061e0:	eaffffda 	b	80806150 <print+0x90>
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808061e4:	e59d3008 	ldr	r3, [sp, #8]
808061e8:	e6af1071 	sxtb	r1, r1
808061ec:	e1a02008 	mov	r2, r8
808061f0:	e2030003 	and	r0, r3, #3
808061f4:	ebfffec1 	bl	80805d00 <xUARTSendCharacter>
808061f8:	eaffffc4 	b	80806110 <print+0x50>
					break;
				}
			}

			// Parse field width, if any.
			while(*format>='0'&&*format<='9')
808061fc:	e241c030 	sub	ip, r1, #48	; 0x30
80806200:	e3a06000 	mov	r6, #0
80806204:	e6ef207c 	uxtb	r2, ip
80806208:	e3520009 	cmp	r2, #9
8080620c:	8a000007 	bhi	80806230 <print+0x170>
			{
				width*=10;
80806210:	e1a02186 	lsl	r2, r6, #3
					break;
				}
			}

			// Parse field width, if any.
			while(*format>='0'&&*format<='9')
80806214:	e5f41001 	ldrb	r1, [r4, #1]!
			{
				width*=10;
80806218:	e0826086 	add	r6, r2, r6, lsl #1
				width+=*format-'0';
8080621c:	e08c6006 	add	r6, ip, r6
					break;
				}
			}

			// Parse field width, if any.
			while(*format>='0'&&*format<='9')
80806220:	e241c030 	sub	ip, r1, #48	; 0x30
80806224:	e6ef207c 	uxtb	r2, ip
80806228:	e3520009 	cmp	r2, #9
8080622c:	9afffff7 	bls	80806210 <print+0x150>
				width+=*format-'0';
				format++;
			}

			// Check for and parse precision.
			if(*format=='.')
80806230:	e351002e 	cmp	r1, #46	; 0x2e
80806234:	11a0a001 	movne	sl, r1
		{
			format++;

			if(*format=='%') goto printnormal;

			int width=0,precision=-1;
80806238:	13e02000 	mvnne	r2, #0
				width+=*format-'0';
				format++;
			}

			// Check for and parse precision.
			if(*format=='.')
8080623c:	0a00007d 	beq	80806438 <print+0x378>
					format++;
				}
			}

			// Ignore length modifiers. (Only "l" is handled for now.)
			if(*format=='l') format++;
80806240:	e35a006c 	cmp	sl, #108	; 0x6c
80806244:	05d4a001 	ldrbeq	sl, [r4, #1]
80806248:	02844001 	addeq	r4, r4, #1

			// Parse the conversion specifier and print appropriate output.
			if(*format=='s')
8080624c:	e35a0073 	cmp	sl, #115	; 0x73
80806250:	0a00006a 	beq	80806400 <print+0x340>
			{
				char *string=va_arg(args,char *);
				count+=printstring(out,string?string:"(null)",width,padleft);
			}
			else if(*format=='d' || *format=='i')
80806254:	e35a0069 	cmp	sl, #105	; 0x69
80806258:	135a0064 	cmpne	sl, #100	; 0x64
8080625c:	03a0c001 	moveq	ip, #1
80806260:	13a0c000 	movne	ip, #0
80806264:	1a000031 	bne	80806330 <print+0x270>
			{
				int value=va_arg(args,int);
80806268:	e59d0004 	ldr	r0, [sp, #4]
8080626c:	e5901000 	ldr	r1, [r0]
80806270:	e2800004 	add	r0, r0, #4
80806274:	e58d0004 	str	r0, [sp, #4]

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
80806278:	e3510000 	cmp	r1, #0
8080627c:	ba0000bd 	blt	80806578 <print+0x4b8>
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
80806280:	e0133fa2 	ands	r3, r3, r2, lsr #31
			{
				int value=va_arg(args,int);

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
80806284:	058d300c 	streq	r3, [sp, #12]
80806288:	01a00002 	moveq	r0, r2
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
8080628c:	0a000005 	beq	808062a8 <print+0x1e8>
				{
					zeropadwidth=width;
					if(isnegative || positivechar) zeropadwidth-=1; // Reserve space for a sign, if needed.
80806290:	e3550000 	cmp	r5, #0
			{
				int value=va_arg(args,int);

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
80806294:	13a03000 	movne	r3, #0
80806298:	158d300c 	strne	r3, [sp, #12]
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
				{
					zeropadwidth=width;
					if(isnegative || positivechar) zeropadwidth-=1; // Reserve space for a sign, if needed.
8080629c:	1a0000bd 	bne	80806598 <print+0x4d8>
808062a0:	e1a00006 	mov	r0, r6
			{
				int value=va_arg(args,int);

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
808062a4:	e58d500c 	str	r5, [sp, #12]
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
808062a8:	e3510000 	cmp	r1, #0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
808062ac:	e3a0c000 	mov	ip, #0
808062b0:	e5cdc097 	strb	ip, [sp, #151]	; 0x97

	// Generate the digits in reverse.
	if(!absvalue)
808062b4:	1a000070 	bne	8080647c <print+0x3bc>
	{
		if(!zeroisempty) *--string='0';
808062b8:	e152000c 	cmp	r2, ip

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
808062bc:	028da097 	addeq	sl, sp, #151	; 0x97

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
808062c0:	13a02030 	movne	r2, #48	; 0x30
808062c4:	128da098 	addne	sl, sp, #152	; 0x98
808062c8:	156a2002 	strbne	r2, [sl, #-2]!
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
808062cc:	e3500000 	cmp	r0, #0
808062d0:	da000009 	ble	808062fc <print+0x23c>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
808062d4:	e28d3098 	add	r3, sp, #152	; 0x98
808062d8:	e06a2003 	rsb	r2, sl, r3
808062dc:	e2422001 	sub	r2, r2, #1
808062e0:	e0622000 	rsb	r2, r2, r0
808062e4:	e3520000 	cmp	r2, #0
808062e8:	da000003 	ble	808062fc <print+0x23c>
808062ec:	e062a00a 	rsb	sl, r2, sl
808062f0:	e3a01030 	mov	r1, #48	; 0x30
808062f4:	e1a0000a 	mov	r0, sl
808062f8:	fa000d77 	blx	808098dc <memset>
				bool zeroisempty=precision==0;

				char *string=formatinteger(bufferend,absvalue,10,0,zeropadwidth,zeroisempty);

				// Handle the sign.
				if(isnegative) *--string='-';
808062fc:	e59d300c 	ldr	r3, [sp, #12]
80806300:	e3530000 	cmp	r3, #0
80806304:	0a00007a 	beq	808064f4 <print+0x434>
80806308:	e3a0302d 	mov	r3, #45	; 0x2d
8080630c:	e24aa001 	sub	sl, sl, #1
80806310:	e5ca3000 	strb	r3, [sl]

				bool zeroisempty=precision==0 && !alternate;

				char *string=formatinteger(bufferend,value,8,0,zeropadwidth,zeroisempty);
				if(alternate && value!=0) *--string='0';
				count+=printstring(out,string,width,padleft);
80806314:	e1a03007 	mov	r3, r7
80806318:	e1a02006 	mov	r2, r6
8080631c:	e1a0100a 	mov	r1, sl
80806320:	e1a00008 	mov	r0, r8
80806324:	ebffff02 	bl	80805f34 <printstring>
80806328:	e0899000 	add	r9, r9, r0
8080632c:	eaffff78 	b	80806114 <print+0x54>
				if(isnegative) *--string='-';
				else if(positivechar) *--string=positivechar;

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
80806330:	e35a0075 	cmp	sl, #117	; 0x75
80806334:	0a000072 	beq	80806504 <print+0x444>
				bool zeroisempty=precision==0;

				char *string=formatinteger(bufferend,value,10,0,zeropadwidth,zeroisempty);
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='x' || *format=='X')
80806338:	e20a10df 	and	r1, sl, #223	; 0xdf
8080633c:	e3510058 	cmp	r1, #88	; 0x58
80806340:	1a000058 	bne	808064a8 <print+0x3e8>
			{
				int value=va_arg(args,int);
80806344:	e59dc004 	ldr	ip, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0)
80806348:	e0133fa2 	ands	r3, r3, r2, lsr #31
				char *string=formatinteger(bufferend,value,10,0,zeropadwidth,zeroisempty);
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='x' || *format=='X')
			{
				int value=va_arg(args,int);
8080634c:	e28c3004 	add	r3, ip, #4
80806350:	e59c1000 	ldr	r1, [ip]
80806354:	e58d3004 	str	r3, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0)
80806358:	0a00009c 	beq	808065d0 <print+0x510>
				{
					zeropadwidth=width;
					if(alternate && value!=0) zeropadwidth-=2;
8080635c:	e3510000 	cmp	r1, #0
80806360:	03a03000 	moveq	r3, #0
80806364:	12003001 	andne	r3, r0, #1
80806368:	e3530000 	cmp	r3, #0
8080636c:	12460002 	subne	r0, r6, #2
80806370:	01a00006 	moveq	r0, r6
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806374:	e3510000 	cmp	r1, #0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806378:	e3a0c000 	mov	ip, #0
8080637c:	e5cdc097 	strb	ip, [sp, #151]	; 0x97

	// Generate the digits in reverse.
	if(!absvalue)
80806380:	1a000086 	bne	808065a0 <print+0x4e0>
	{
		if(!zeroisempty) *--string='0';
80806384:	e152000c 	cmp	r2, ip

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806388:	028d5097 	addeq	r5, sp, #151	; 0x97

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
8080638c:	13a02030 	movne	r2, #48	; 0x30
80806390:	128d5098 	addne	r5, sp, #152	; 0x98
80806394:	15652002 	strbne	r2, [r5, #-2]!
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
80806398:	e3500000 	cmp	r0, #0
8080639c:	da00000b 	ble	808063d0 <print+0x310>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
808063a0:	e28d2098 	add	r2, sp, #152	; 0x98
808063a4:	e0652002 	rsb	r2, r5, r2
808063a8:	e2422001 	sub	r2, r2, #1
808063ac:	e0622000 	rsb	r2, r2, r0
808063b0:	e3520000 	cmp	r2, #0
808063b4:	da000005 	ble	808063d0 <print+0x310>
808063b8:	e0625005 	rsb	r5, r2, r5
808063bc:	e3a01030 	mov	r1, #48	; 0x30
808063c0:	e1a00005 	mov	r0, r5
808063c4:	e58d300c 	str	r3, [sp, #12]
808063c8:	fa000d43 	blx	808098dc <memset>
808063cc:	e59d300c 	ldr	r3, [sp, #12]
				}

				bool zeroisempty=precision==0;

				char *string=formatinteger(bufferend,value,16,'A'-'X'+*format,zeropadwidth,zeroisempty);
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
808063d0:	e3530000 	cmp	r3, #0
808063d4:	13a03030 	movne	r3, #48	; 0x30
808063d8:	1545a001 	strbne	sl, [r5, #-1]
808063dc:	15453002 	strbne	r3, [r5, #-2]
808063e0:	12455002 	subne	r5, r5, #2
				count+=printstring(out,string,width,padleft);
808063e4:	e1a03007 	mov	r3, r7
808063e8:	e1a02006 	mov	r2, r6
808063ec:	e1a01005 	mov	r1, r5
808063f0:	e1a00008 	mov	r0, r8
808063f4:	ebfffece 	bl	80805f34 <printstring>
808063f8:	e0899000 	add	r9, r9, r0
808063fc:	eaffff44 	b	80806114 <print+0x54>
			if(*format=='l') format++;

			// Parse the conversion specifier and print appropriate output.
			if(*format=='s')
			{
				char *string=va_arg(args,char *);
80806400:	e59de004 	ldr	lr, [sp, #4]
				count+=printstring(out,string?string:"(null)",width,padleft);
80806404:	e309caf0 	movw	ip, #39664	; 0x9af0
80806408:	e348c080 	movt	ip, #32896	; 0x8080
8080640c:	e1a03007 	mov	r3, r7
80806410:	e1a02006 	mov	r2, r6
80806414:	e1a00008 	mov	r0, r8
			if(*format=='l') format++;

			// Parse the conversion specifier and print appropriate output.
			if(*format=='s')
			{
				char *string=va_arg(args,char *);
80806418:	e59e1000 	ldr	r1, [lr]
8080641c:	e28ee004 	add	lr, lr, #4
80806420:	e58de004 	str	lr, [sp, #4]
				count+=printstring(out,string?string:"(null)",width,padleft);
80806424:	e3510000 	cmp	r1, #0
80806428:	01a0100c 	moveq	r1, ip
8080642c:	ebfffec0 	bl	80805f34 <printstring>
80806430:	e0899000 	add	r9, r9, r0
80806434:	eaffff36 	b	80806114 <print+0x54>
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
80806438:	e5d41001 	ldrb	r1, [r4, #1]
			}

			// Check for and parse precision.
			if(*format=='.')
			{
				format++;
8080643c:	e2844001 	add	r4, r4, #1

				precision=0;
				while(*format>='0'&&*format<='9')
80806440:	e241e030 	sub	lr, r1, #48	; 0x30
80806444:	e6ef207e 	uxtb	r2, lr
80806448:	e3520009 	cmp	r2, #9
8080644c:	8a000097 	bhi	808066b0 <print+0x5f0>
80806450:	e3a02000 	mov	r2, #0
				{
					precision*=10;
80806454:	e1a0c182 	lsl	ip, r2, #3
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
80806458:	e5f41001 	ldrb	r1, [r4, #1]!
				{
					precision*=10;
8080645c:	e08c2082 	add	r2, ip, r2, lsl #1
					precision+=*format-'0';
80806460:	e08e2002 	add	r2, lr, r2
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
80806464:	e241e030 	sub	lr, r1, #48	; 0x30
80806468:	e6efc07e 	uxtb	ip, lr
8080646c:	e35c0009 	cmp	ip, #9
80806470:	9afffff7 	bls	80806454 <print+0x394>
80806474:	e1a0a001 	mov	sl, r1
80806478:	eaffff70 	b	80806240 <print+0x180>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
8080647c:	e28da097 	add	sl, sp, #151	; 0x97

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
80806480:	e0832b91 	umull	r2, r3, r1, fp
80806484:	e1a021a3 	lsr	r2, r3, #3
80806488:	e1a03182 	lsl	r3, r2, #3
8080648c:	e0833082 	add	r3, r3, r2, lsl #1
80806490:	e0633001 	rsb	r3, r3, r1
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806494:	e2521000 	subs	r1, r2, #0

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
80806498:	e2833030 	add	r3, r3, #48	; 0x30
8080649c:	e56a3001 	strb	r3, [sl, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808064a0:	1afffff6 	bne	80806480 <print+0x3c0>
808064a4:	eaffff88 	b	808062cc <print+0x20c>

				char *string=formatinteger(bufferend,value,16,'A'-'X'+*format,zeropadwidth,zeroisempty);
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='o')
808064a8:	e35a006f 	cmp	sl, #111	; 0x6f
808064ac:	0a000057 	beq	80806610 <print+0x550>

				char *string=formatinteger(bufferend,value,8,0,zeropadwidth,zeroisempty);
				if(alternate && value!=0) *--string='0';
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='c')
808064b0:	e35a0063 	cmp	sl, #99	; 0x63
808064b4:	1affff16 	bne	80806114 <print+0x54>
			{
				char str[2];
				str[0]=va_arg( args, int );
808064b8:	e59d5004 	ldr	r5, [sp, #4]
				str[1]=0;
				count+=printstring(out,str,width,padleft);
808064bc:	e1a03007 	mov	r3, r7
			}
			else if(*format=='c')
			{
				char str[2];
				str[0]=va_arg( args, int );
				str[1]=0;
808064c0:	e5cdc015 	strb	ip, [sp, #21]
				count+=printstring(out,str,width,padleft);
808064c4:	e1a02006 	mov	r2, r6
808064c8:	e28d1014 	add	r1, sp, #20
808064cc:	e1a00008 	mov	r0, r8
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='c')
			{
				char str[2];
				str[0]=va_arg( args, int );
808064d0:	e595e000 	ldr	lr, [r5]
808064d4:	e285c004 	add	ip, r5, #4
808064d8:	e58dc004 	str	ip, [sp, #4]
808064dc:	e5cde014 	strb	lr, [sp, #20]
				str[1]=0;
				count+=printstring(out,str,width,padleft);
808064e0:	ebfffe93 	bl	80805f34 <printstring>
808064e4:	e0899000 	add	r9, r9, r0
808064e8:	eaffff09 	b	80806114 <print+0x54>

static int print(char **out,const char *format,va_list args)
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;
808064ec:	e1a09001 	mov	r9, r1
808064f0:	eaffff2a 	b	808061a0 <print+0xe0>

				char *string=formatinteger(bufferend,absvalue,10,0,zeropadwidth,zeroisempty);

				// Handle the sign.
				if(isnegative) *--string='-';
				else if(positivechar) *--string=positivechar;
808064f4:	e3550000 	cmp	r5, #0
808064f8:	154a5001 	strbne	r5, [sl, #-1]
808064fc:	124aa001 	subne	sl, sl, #1
80806500:	eaffff83 	b	80806314 <print+0x254>

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
			{
				int value=va_arg(args,int);
80806504:	e59de004 	ldr	lr, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80806508:	e0133fa2 	ands	r3, r3, r2, lsr #31

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
8080650c:	e5cdc097 	strb	ip, [sp, #151]	; 0x97

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
			{
				int value=va_arg(args,int);
80806510:	e59e0000 	ldr	r0, [lr]
80806514:	e1a0100e 	mov	r1, lr

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80806518:	11a01006 	movne	r1, r6
8080651c:	01a01002 	moveq	r1, r2

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
			{
				int value=va_arg(args,int);
80806520:	e28e3004 	add	r3, lr, #4
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806524:	e3500000 	cmp	r0, #0

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
			{
				int value=va_arg(args,int);
80806528:	e58d3004 	str	r3, [sp, #4]
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
8080652c:	1a00002c 	bne	808065e4 <print+0x524>
	{
		if(!zeroisempty) *--string='0';
80806530:	e3520000 	cmp	r2, #0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806534:	028d5097 	addeq	r5, sp, #151	; 0x97

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
80806538:	13a03030 	movne	r3, #48	; 0x30
8080653c:	128d5098 	addne	r5, sp, #152	; 0x98
80806540:	15653002 	strbne	r3, [r5, #-2]!
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
80806544:	e3510000 	cmp	r1, #0
80806548:	daffffa5 	ble	808063e4 <print+0x324>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
8080654c:	e28d3098 	add	r3, sp, #152	; 0x98
80806550:	e0652003 	rsb	r2, r5, r3
80806554:	e2422001 	sub	r2, r2, #1
80806558:	e0622001 	rsb	r2, r2, r1
8080655c:	e3520000 	cmp	r2, #0
80806560:	daffff9f 	ble	808063e4 <print+0x324>
80806564:	e0625005 	rsb	r5, r2, r5
80806568:	e3a01030 	mov	r1, #48	; 0x30
8080656c:	e1a00005 	mov	r0, r5
80806570:	fa000cd9 	blx	808098dc <memset>
80806574:	eaffff9a 	b	808063e4 <print+0x324>
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
80806578:	e0133fa2 	ands	r3, r3, r2, lsr #31
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
				{
					isnegative=true;
					absvalue=-value;
8080657c:	e2611000 	rsb	r1, r1, #0
				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
				{
					isnegative=true;
80806580:	03a03001 	moveq	r3, #1
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
80806584:	01a00002 	moveq	r0, r2
				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
				{
					isnegative=true;
80806588:	058d300c 	streq	r3, [sp, #12]
8080658c:	0affff45 	beq	808062a8 <print+0x1e8>
80806590:	e3a03001 	mov	r3, #1
80806594:	e58d300c 	str	r3, [sp, #12]
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
				{
					zeropadwidth=width;
					if(isnegative || positivechar) zeropadwidth-=1; // Reserve space for a sign, if needed.
80806598:	e2460001 	sub	r0, r6, #1
8080659c:	eaffff41 	b	808062a8 <print+0x1e8>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
808065a0:	e28d5097 	add	r5, sp, #151	; 0x97
808065a4:	e24ac021 	sub	ip, sl, #33	; 0x21
	}
	else
	{
		while(absvalue)
		{
			unsigned int digit=absvalue%base;
808065a8:	e201200f 	and	r2, r1, #15

			char c;
			if(digit>=10) c=digit-10+letterbase;
808065ac:	e6efe072 	uxtb	lr, r2
			else c=digit+'0';

			*--string=c;
808065b0:	e3520009 	cmp	r2, #9
		while(absvalue)
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
808065b4:	e08e200c 	add	r2, lr, ip
808065b8:	e6ef2072 	uxtb	r2, r2
			else c=digit+'0';

			*--string=c;
808065bc:	928e2030 	addls	r2, lr, #48	; 0x30
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808065c0:	e1b01221 	lsrs	r1, r1, #4

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808065c4:	e5652001 	strb	r2, [r5, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808065c8:	1afffff6 	bne	808065a8 <print+0x4e8>
808065cc:	eaffff71 	b	80806398 <print+0x2d8>
808065d0:	e3510000 	cmp	r1, #0
808065d4:	03a03000 	moveq	r3, #0
808065d8:	12003001 	andne	r3, r0, #1
			else if(*format=='x' || *format=='X')
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0)
808065dc:	e1a00002 	mov	r0, r2
808065e0:	eaffff63 	b	80806374 <print+0x2b4>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
808065e4:	e28d5097 	add	r5, sp, #151	; 0x97

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808065e8:	e0832b90 	umull	r2, r3, r0, fp
808065ec:	e1a021a3 	lsr	r2, r3, #3
808065f0:	e1a03182 	lsl	r3, r2, #3
808065f4:	e0833082 	add	r3, r3, r2, lsl #1
808065f8:	e0633000 	rsb	r3, r3, r0
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808065fc:	e2520000 	subs	r0, r2, #0

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
80806600:	e2833030 	add	r3, r3, #48	; 0x30
80806604:	e5653001 	strb	r3, [r5, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806608:	1afffff6 	bne	808065e8 <print+0x528>
8080660c:	eaffffcc 	b	80806544 <print+0x484>
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='o')
			{
				int value=va_arg(args,int);
80806610:	e59dc004 	ldr	ip, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80806614:	e0133fa2 	ands	r3, r3, r2, lsr #31
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='o')
			{
				int value=va_arg(args,int);
80806618:	e59c3000 	ldr	r3, [ip]
8080661c:	e28c1004 	add	r1, ip, #4
80806620:	e58d1004 	str	r1, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80806624:	11a01006 	movne	r1, r6
80806628:	01a01002 	moveq	r1, r2

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
8080662c:	e3a0c000 	mov	ip, #0
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
				if(alternate && value!=0) zeropadwidth-=1;
80806630:	e3530000 	cmp	r3, #0
80806634:	03a05000 	moveq	r5, #0
80806638:	12005001 	andne	r5, r0, #1

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
8080663c:	e5cdc097 	strb	ip, [sp, #151]	; 0x97
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
				if(alternate && value!=0) zeropadwidth-=1;
80806640:	e3550000 	cmp	r5, #0
80806644:	12411001 	subne	r1, r1, #1
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806648:	e3530000 	cmp	r3, #0
8080664c:	1a00001a 	bne	808066bc <print+0x5fc>
	{
		if(!zeroisempty) *--string='0';
80806650:	e16f2f12 	clz	r2, r2
80806654:	e1a022a2 	lsr	r2, r2, #5
80806658:	e1520000 	cmp	r2, r0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
8080665c:	828da097 	addhi	sl, sp, #151	; 0x97

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
80806660:	93a03030 	movls	r3, #48	; 0x30
80806664:	928da098 	addls	sl, sp, #152	; 0x98
80806668:	956a3002 	strbls	r3, [sl, #-2]!
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
8080666c:	e3510000 	cmp	r1, #0
80806670:	da000009 	ble	8080669c <print+0x5dc>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
80806674:	e28d3098 	add	r3, sp, #152	; 0x98
80806678:	e06a2003 	rsb	r2, sl, r3
8080667c:	e2422001 	sub	r2, r2, #1
80806680:	e0622001 	rsb	r2, r2, r1
80806684:	e3520000 	cmp	r2, #0
80806688:	da000003 	ble	8080669c <print+0x5dc>
8080668c:	e062a00a 	rsb	sl, r2, sl
80806690:	e3a01030 	mov	r1, #48	; 0x30
80806694:	e1a0000a 	mov	r0, sl
80806698:	fa000c8f 	blx	808098dc <memset>
				if(alternate && value!=0) zeropadwidth-=1;

				bool zeroisempty=precision==0 && !alternate;

				char *string=formatinteger(bufferend,value,8,0,zeropadwidth,zeroisempty);
				if(alternate && value!=0) *--string='0';
8080669c:	e3550000 	cmp	r5, #0
808066a0:	13a03030 	movne	r3, #48	; 0x30
808066a4:	154a3001 	strbne	r3, [sl, #-1]
808066a8:	124aa001 	subne	sl, sl, #1
808066ac:	eaffff18 	b	80806314 <print+0x254>
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
808066b0:	e1a0a001 	mov	sl, r1
			// Check for and parse precision.
			if(*format=='.')
			{
				format++;

				precision=0;
808066b4:	e3a02000 	mov	r2, #0
808066b8:	eafffee0 	b	80806240 <print+0x180>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
808066bc:	e28da097 	add	sl, sp, #151	; 0x97

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808066c0:	e2032007 	and	r2, r3, #7
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808066c4:	e1b031a3 	lsrs	r3, r3, #3

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808066c8:	e2822030 	add	r2, r2, #48	; 0x30
808066cc:	e56a2001 	strb	r2, [sl, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808066d0:	1afffffa 	bne	808066c0 <print+0x600>
808066d4:	eaffffe4 	b	8080666c <print+0x5ac>

808066d8 <print.constprop.1>:
	int count=printstring(0,s,0,false);
	printchar(0,'\n');
	return count+1;
}

static int print(char **out,const char *format,va_list args)
808066d8:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
808066dc:	e24dd0a4 	sub	sp, sp, #164	; 0xa4
808066e0:	e58d1004 	str	r1, [sp, #4]
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
808066e4:	e5d01000 	ldrb	r1, [r0]
808066e8:	e3510000 	cmp	r1, #0
808066ec:	0a0001c1 	beq	80806df8 <print.constprop.1+0x720>
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';
808066f0:	e30c3ccd 	movw	r3, #52429	; 0xcccd
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
808066f4:	e3a07000 	mov	r7, #0
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';
808066f8:	e34c3ccc 	movt	r3, #52428	; 0xcccc
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808066fc:	e1a04000 	mov	r4, r0
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';
80806700:	e58d3008 	str	r3, [sp, #8]
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806704:	ee108fb0 	mrc	15, 0, r8, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806708:	e2083003 	and	r3, r8, #3
8080670c:	e58d300c 	str	r3, [sp, #12]
80806710:	ea000008 	b	80806738 <print.constprop.1+0x60>
80806714:	e6af1071 	sxtb	r1, r1
80806718:	e3a02000 	mov	r2, #0
8080671c:	e2080003 	and	r0, r8, #3
		}
		else
		{
			printnormal:
			printchar(out,*format);
			count++;
80806720:	e2877001 	add	r7, r7, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806724:	ebfffd75 	bl	80805d00 <xUARTSendCharacter>
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
80806728:	e5d41001 	ldrb	r1, [r4, #1]
			printnormal:
			printchar(out,*format);
			count++;
		}

		format++;
8080672c:	e2844001 	add	r4, r4, #1
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;

	while(*format)
80806730:	e3510000 	cmp	r1, #0
80806734:	0a00001e 	beq	808067b4 <print.constprop.1+0xdc>
	{
		if(*format=='%')
80806738:	e3510025 	cmp	r1, #37	; 0x25
8080673c:	1afffff4 	bne	80806714 <print.constprop.1+0x3c>
		{
			format++;

			if(*format=='%') goto printnormal;
80806740:	e5d43001 	ldrb	r3, [r4, #1]

	while(*format)
	{
		if(*format=='%')
		{
			format++;
80806744:	e2844001 	add	r4, r4, #1

			if(*format=='%') goto printnormal;
80806748:	e3530025 	cmp	r3, #37	; 0x25
8080674c:	0afffff0 	beq	80806714 <print.constprop.1+0x3c>
80806750:	e3a00000 	mov	r0, #0
80806754:	e1a03004 	mov	r3, r4
80806758:	e1a01000 	mov	r1, r0
8080675c:	e1a0a000 	mov	sl, r0
80806760:	e3a06001 	mov	r6, #1
80806764:	e1a04003 	mov	r4, r3
			bool padleft=true,padzero=false,alternate=false;

			// Parse flag characters.
			for(;;)
			{
				if(*format==0)
80806768:	e4d32001 	ldrb	r2, [r3], #1
8080676c:	e3520000 	cmp	r2, #0
80806770:	0a00000f 	beq	808067b4 <print.constprop.1+0xdc>
				{
					// Premature format string end.
					goto end;
				}
				else if(*format=='#')
80806774:	e3520023 	cmp	r2, #35	; 0x23
80806778:	0a000010 	beq	808067c0 <print.constprop.1+0xe8>
				{
					// Alternate form.
					alternate=true;
					format++;
				}
				else if(*format=='-')
8080677c:	e352002d 	cmp	r2, #45	; 0x2d
80806780:	0a000010 	beq	808067c8 <print.constprop.1+0xf0>
					// Left justify. Overrides zero padding.
					padleft=false;
					padzero=false;
					format++;
				}
				else if(*format=='0')
80806784:	e3520030 	cmp	r2, #48	; 0x30
80806788:	0a000011 	beq	808067d4 <print.constprop.1+0xfc>
					// Zero padding.
					// Overriden by left justification, so check for that.
					if(padleft) padzero=true;
					format++;
				}
				else if(*format=='+')
8080678c:	e352002b 	cmp	r2, #43	; 0x2b
80806790:	0a000012 	beq	808067e0 <print.constprop.1+0x108>
				{
					// Prefix positive numbers with a plus sign. Overrides space prefix.
					positivechar='+';
					format++;
				}
				else if(*format==' ')
80806794:	e3520020 	cmp	r2, #32
80806798:	1a000012 	bne	808067e8 <print.constprop.1+0x110>
8080679c:	e1a04003 	mov	r4, r3
			bool padleft=true,padzero=false,alternate=false;

			// Parse flag characters.
			for(;;)
			{
				if(*format==0)
808067a0:	e4d32001 	ldrb	r2, [r3], #1
				}
				else if(*format==' ')
				{
					// Prefix positive numbers with a space.
					// Overriden by plus prefix, so check for that.
					if(!positivechar) positivechar=' ';
808067a4:	e35a0000 	cmp	sl, #0
808067a8:	03a0a020 	moveq	sl, #32
			bool padleft=true,padzero=false,alternate=false;

			// Parse flag characters.
			for(;;)
			{
				if(*format==0)
808067ac:	e3520000 	cmp	r2, #0
808067b0:	1affffef 	bne	80806774 <print.constprop.1+0x9c>
	if(out) **out=0;

	va_end(args);

	return count;
}
808067b4:	e1a00007 	mov	r0, r7
808067b8:	e28dd0a4 	add	sp, sp, #164	; 0xa4
808067bc:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}
					goto end;
				}
				else if(*format=='#')
				{
					// Alternate form.
					alternate=true;
808067c0:	e3a00001 	mov	r0, #1
808067c4:	eaffffe6 	b	80806764 <print.constprop.1+0x8c>
				}
				else if(*format=='-')
				{
					// Left justify. Overrides zero padding.
					padleft=false;
					padzero=false;
808067c8:	e3a01000 	mov	r1, #0
					format++;
				}
				else if(*format=='-')
				{
					// Left justify. Overrides zero padding.
					padleft=false;
808067cc:	e1a06001 	mov	r6, r1
808067d0:	eaffffe3 	b	80806764 <print.constprop.1+0x8c>
				}
				else if(*format=='0')
				{
					// Zero padding.
					// Overriden by left justification, so check for that.
					if(padleft) padzero=true;
808067d4:	e3560000 	cmp	r6, #0
808067d8:	13a01001 	movne	r1, #1
808067dc:	eaffffe0 	b	80806764 <print.constprop.1+0x8c>
					format++;
				}
				else if(*format=='+')
				{
					// Prefix positive numbers with a plus sign. Overrides space prefix.
					positivechar='+';
808067e0:	e1a0a002 	mov	sl, r2
808067e4:	eaffffde 	b	80806764 <print.constprop.1+0x8c>
					break;
				}
			}

			// Parse field width, if any.
			while(*format>='0'&&*format<='9')
808067e8:	e242c030 	sub	ip, r2, #48	; 0x30
808067ec:	e3a09000 	mov	r9, #0
808067f0:	e6ef307c 	uxtb	r3, ip
808067f4:	e3530009 	cmp	r3, #9
808067f8:	8a000007 	bhi	8080681c <print.constprop.1+0x144>
			{
				width*=10;
808067fc:	e1a03189 	lsl	r3, r9, #3
					break;
				}
			}

			// Parse field width, if any.
			while(*format>='0'&&*format<='9')
80806800:	e5f42001 	ldrb	r2, [r4, #1]!
			{
				width*=10;
80806804:	e0839089 	add	r9, r3, r9, lsl #1
				width+=*format-'0';
80806808:	e08c9009 	add	r9, ip, r9
					break;
				}
			}

			// Parse field width, if any.
			while(*format>='0'&&*format<='9')
8080680c:	e242c030 	sub	ip, r2, #48	; 0x30
80806810:	e6ef307c 	uxtb	r3, ip
80806814:	e3530009 	cmp	r3, #9
80806818:	9afffff7 	bls	808067fc <print.constprop.1+0x124>
				width+=*format-'0';
				format++;
			}

			// Check for and parse precision.
			if(*format=='.')
8080681c:	e352002e 	cmp	r2, #46	; 0x2e
80806820:	11a05002 	movne	r5, r2
		{
			format++;

			if(*format=='%') goto printnormal;

			int width=0,precision=-1;
80806824:	13e03000 	mvnne	r3, #0
				width+=*format-'0';
				format++;
			}

			// Check for and parse precision.
			if(*format=='.')
80806828:	0a000114 	beq	80806c80 <print.constprop.1+0x5a8>
					format++;
				}
			}

			// Ignore length modifiers. (Only "l" is handled for now.)
			if(*format=='l') format++;
8080682c:	e355006c 	cmp	r5, #108	; 0x6c
80806830:	05d45001 	ldrbeq	r5, [r4, #1]
80806834:	02844001 	addeq	r4, r4, #1

			// Parse the conversion specifier and print appropriate output.
			if(*format=='s')
80806838:	e3550073 	cmp	r5, #115	; 0x73
8080683c:	0a0000d1 	beq	80806b88 <print.constprop.1+0x4b0>
			{
				char *string=va_arg(args,char *);
				count+=printstring(out,string?string:"(null)",width,padleft);
			}
			else if(*format=='d' || *format=='i')
80806840:	e3550069 	cmp	r5, #105	; 0x69
80806844:	13550064 	cmpne	r5, #100	; 0x64
80806848:	03a0e001 	moveq	lr, #1
8080684c:	13a0e000 	movne	lr, #0
80806850:	1a000065 	bne	808069ec <print.constprop.1+0x314>
			{
				int value=va_arg(args,int);
80806854:	e59d0004 	ldr	r0, [sp, #4]
80806858:	e5902000 	ldr	r2, [r0]
8080685c:	e2800004 	add	r0, r0, #4
80806860:	e58d0004 	str	r0, [sp, #4]

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
80806864:	e3520000 	cmp	r2, #0
80806868:	ba0001be 	blt	80806f68 <print.constprop.1+0x890>
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
8080686c:	e0111fa3 	ands	r1, r1, r3, lsr #31
			{
				int value=va_arg(args,int);

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
80806870:	01a05001 	moveq	r5, r1
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
80806874:	01a0c003 	moveq	ip, r3
80806878:	0a000004 	beq	80806890 <print.constprop.1+0x1b8>
				{
					zeropadwidth=width;
					if(isnegative || positivechar) zeropadwidth-=1; // Reserve space for a sign, if needed.
8080687c:	e35a0000 	cmp	sl, #0
			{
				int value=va_arg(args,int);

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
80806880:	13a05000 	movne	r5, #0
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
				{
					zeropadwidth=width;
					if(isnegative || positivechar) zeropadwidth-=1; // Reserve space for a sign, if needed.
80806884:	1a0001bd 	bne	80806f80 <print.constprop.1+0x8a8>
80806888:	e1a0c009 	mov	ip, r9
			{
				int value=va_arg(args,int);

				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
8080688c:	e1a0500a 	mov	r5, sl
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806890:	e3520000 	cmp	r2, #0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806894:	e3a01000 	mov	r1, #0
80806898:	e5cd109f 	strb	r1, [sp, #159]	; 0x9f

	// Generate the digits in reverse.
	if(!absvalue)
8080689c:	1a000108 	bne	80806cc4 <print.constprop.1+0x5ec>
	{
		if(!zeroisempty) *--string='0';
808068a0:	e1530001 	cmp	r3, r1

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
808068a4:	028db09f 	addeq	fp, sp, #159	; 0x9f

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
808068a8:	13a03030 	movne	r3, #48	; 0x30
808068ac:	128db0a0 	addne	fp, sp, #160	; 0xa0
808068b0:	156b3002 	strbne	r3, [fp, #-2]!
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
808068b4:	e35c0000 	cmp	ip, #0
808068b8:	da000009 	ble	808068e4 <print.constprop.1+0x20c>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
808068bc:	e28d30a0 	add	r3, sp, #160	; 0xa0
808068c0:	e06b2003 	rsb	r2, fp, r3
808068c4:	e2422001 	sub	r2, r2, #1
808068c8:	e062200c 	rsb	r2, r2, ip
808068cc:	e3520000 	cmp	r2, #0
808068d0:	da000003 	ble	808068e4 <print.constprop.1+0x20c>
808068d4:	e062b00b 	rsb	fp, r2, fp
808068d8:	e3a01030 	mov	r1, #48	; 0x30
808068dc:	e1a0000b 	mov	r0, fp
808068e0:	fa000bfd 	blx	808098dc <memset>
				bool zeroisempty=precision==0;

				char *string=formatinteger(bufferend,absvalue,10,0,zeropadwidth,zeroisempty);

				// Handle the sign.
				if(isnegative) *--string='-';
808068e4:	e3550000 	cmp	r5, #0
808068e8:	0a000144 	beq	80806e00 <print.constprop.1+0x728>
808068ec:	e3a0302d 	mov	r3, #45	; 0x2d
808068f0:	e24bb001 	sub	fp, fp, #1
808068f4:	e5cb3000 	strb	r3, [fp]
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
808068f8:	e3590000 	cmp	r9, #0
808068fc:	d3a05000 	movle	r5, #0
80806900:	c2065001 	andgt	r5, r6, #1
	{
		const char *end=string;
		while(*end) end++;
80806904:	e5db6000 	ldrb	r6, [fp]
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806908:	e3550000 	cmp	r5, #0
8080690c:	0a00001c 	beq	80806984 <print.constprop.1+0x2ac>
	{
		const char *end=string;
		while(*end) end++;
80806910:	e3560000 	cmp	r6, #0
80806914:	0a00022f 	beq	808071d8 <print.constprop.1+0xb00>
80806918:	e1a0300b 	mov	r3, fp
8080691c:	e5f32001 	ldrb	r2, [r3, #1]!
80806920:	e3520000 	cmp	r2, #0
80806924:	1afffffc 	bne	8080691c <print.constprop.1+0x244>

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806928:	e06b3003 	rsb	r3, fp, r3
8080692c:	e0633009 	rsb	r3, r3, r9
80806930:	e3530000 	cmp	r3, #0
80806934:	e58d3010 	str	r3, [sp, #16]
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
80806938:	d1a05002 	movle	r5, r2
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
8080693c:	da000012 	ble	8080698c <print.constprop.1+0x2b4>
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806940:	e58d4014 	str	r4, [sp, #20]
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
80806944:	e3a05000 	mov	r5, #0
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806948:	e59d4010 	ldr	r4, [sp, #16]
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
8080694c:	ee10afb0 	mrc	15, 0, sl, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806950:	e20aa003 	and	sl, sl, #3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806954:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806958:	e3a02000 	mov	r2, #0
8080695c:	e3a01020 	mov	r1, #32
80806960:	e1a0000a 	mov	r0, sl
80806964:	ebfffce5 	bl	80805d00 <xUARTSendCharacter>
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806968:	e1550004 	cmp	r5, r4
8080696c:	bafffff8 	blt	80806954 <print.constprop.1+0x27c>
80806970:	e59d3010 	ldr	r3, [sp, #16]
80806974:	e59d4014 	ldr	r4, [sp, #20]
80806978:	e3530001 	cmp	r3, #1
8080697c:	a1a05003 	movge	r5, r3
80806980:	b3a05001 	movlt	r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806984:	e3560000 	cmp	r6, #0
80806988:	0a00000a 	beq	808069b8 <print.constprop.1+0x2e0>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
8080698c:	ee10afb0 	mrc	15, 0, sl, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806990:	e1a01006 	mov	r1, r6
80806994:	e20aa003 	and	sl, sl, #3
80806998:	e6af1071 	sxtb	r1, r1
8080699c:	e3a02000 	mov	r2, #0
808069a0:	e1a0000a 	mov	r0, sl
808069a4:	ebfffcd5 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
808069a8:	e5fb1001 	ldrb	r1, [fp, #1]!
	{
		printchar(out,*string);
		count++;
808069ac:	e2855001 	add	r5, r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
808069b0:	e3510000 	cmp	r1, #0
808069b4:	1afffff7 	bne	80806998 <print.constprop.1+0x2c0>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
808069b8:	e1550009 	cmp	r5, r9
808069bc:	aa0001f6 	bge	8080719c <print.constprop.1+0xac4>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808069c0:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808069c4:	e2066003 	and	r6, r6, #3

	// Print any remaining padding on the right, if needed.
	while(count<width)
	{
		printchar(out,' ');
		count++;
808069c8:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808069cc:	e3a02000 	mov	r2, #0
808069d0:	e3a01020 	mov	r1, #32
808069d4:	e1a00006 	mov	r0, r6
808069d8:	ebfffcc8 	bl	80805d00 <xUARTSendCharacter>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
808069dc:	e1550009 	cmp	r5, r9
808069e0:	1afffff8 	bne	808069c8 <print.constprop.1+0x2f0>

				bool zeroisempty=precision==0 && !alternate;

				char *string=formatinteger(bufferend,value,8,0,zeropadwidth,zeroisempty);
				if(alternate && value!=0) *--string='0';
				count+=printstring(out,string,width,padleft);
808069e4:	e0877009 	add	r7, r7, r9
808069e8:	eaffff4e 	b	80806728 <print.constprop.1+0x50>
				if(isnegative) *--string='-';
				else if(positivechar) *--string=positivechar;

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
808069ec:	e3550075 	cmp	r5, #117	; 0x75
808069f0:	0a000106 	beq	80806e10 <print.constprop.1+0x738>
				bool zeroisempty=precision==0;

				char *string=formatinteger(bufferend,value,10,0,zeropadwidth,zeroisempty);
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='x' || *format=='X')
808069f4:	e20520df 	and	r2, r5, #223	; 0xdf
808069f8:	e3520058 	cmp	r2, #88	; 0x58
808069fc:	1a0000bc 	bne	80806cf4 <print.constprop.1+0x61c>
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0)
80806a00:	e0112fa3 	ands	r2, r1, r3, lsr #31
				char *string=formatinteger(bufferend,value,10,0,zeropadwidth,zeroisempty);
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='x' || *format=='X')
			{
				int value=va_arg(args,int);
80806a04:	e59d1004 	ldr	r1, [sp, #4]
80806a08:	e5912000 	ldr	r2, [r1]
80806a0c:	e2811004 	add	r1, r1, #4
80806a10:	e58d1004 	str	r1, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0)
80806a14:	0a00015b 	beq	80806f88 <print.constprop.1+0x8b0>
				{
					zeropadwidth=width;
					if(alternate && value!=0) zeropadwidth-=2;
80806a18:	e3520000 	cmp	r2, #0
80806a1c:	03a0a000 	moveq	sl, #0
80806a20:	1200a001 	andne	sl, r0, #1
80806a24:	e35a0000 	cmp	sl, #0
80806a28:	12491002 	subne	r1, r9, #2
80806a2c:	01a01009 	moveq	r1, r9
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806a30:	e3520000 	cmp	r2, #0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806a34:	e3a00000 	mov	r0, #0
80806a38:	e5cd009f 	strb	r0, [sp, #159]	; 0x9f

	// Generate the digits in reverse.
	if(!absvalue)
80806a3c:	1a000156 	bne	80806f9c <print.constprop.1+0x8c4>
	{
		if(!zeroisempty) *--string='0';
80806a40:	e1530000 	cmp	r3, r0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806a44:	028db09f 	addeq	fp, sp, #159	; 0x9f

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
80806a48:	13a03030 	movne	r3, #48	; 0x30
80806a4c:	128db0a0 	addne	fp, sp, #160	; 0xa0
80806a50:	156b3002 	strbne	r3, [fp, #-2]!
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
80806a54:	e3510000 	cmp	r1, #0
80806a58:	da000009 	ble	80806a84 <print.constprop.1+0x3ac>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
80806a5c:	e28d30a0 	add	r3, sp, #160	; 0xa0
80806a60:	e06b2003 	rsb	r2, fp, r3
80806a64:	e2422001 	sub	r2, r2, #1
80806a68:	e0622001 	rsb	r2, r2, r1
80806a6c:	e3520000 	cmp	r2, #0
80806a70:	da000003 	ble	80806a84 <print.constprop.1+0x3ac>
80806a74:	e062b00b 	rsb	fp, r2, fp
80806a78:	e3a01030 	mov	r1, #48	; 0x30
80806a7c:	e1a0000b 	mov	r0, fp
80806a80:	fa000b95 	blx	808098dc <memset>
				}

				bool zeroisempty=precision==0;

				char *string=formatinteger(bufferend,value,16,'A'-'X'+*format,zeropadwidth,zeroisempty);
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
80806a84:	e35a0000 	cmp	sl, #0
80806a88:	13a03030 	movne	r3, #48	; 0x30
80806a8c:	154b5001 	strbne	r5, [fp, #-1]
80806a90:	154b3002 	strbne	r3, [fp, #-2]
80806a94:	124bb002 	subne	fp, fp, #2
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806a98:	e3590000 	cmp	r9, #0
80806a9c:	d3a05000 	movle	r5, #0
80806aa0:	c2065001 	andgt	r5, r6, #1
	{
		const char *end=string;
		while(*end) end++;
80806aa4:	e5db6000 	ldrb	r6, [fp]
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806aa8:	e3550000 	cmp	r5, #0
80806aac:	0a00001c 	beq	80806b24 <print.constprop.1+0x44c>
	{
		const char *end=string;
		while(*end) end++;
80806ab0:	e3560000 	cmp	r6, #0
80806ab4:	0a0001d4 	beq	8080720c <print.constprop.1+0xb34>
80806ab8:	e1a0300b 	mov	r3, fp
80806abc:	e5f32001 	ldrb	r2, [r3, #1]!
80806ac0:	e3520000 	cmp	r2, #0
80806ac4:	1afffffc 	bne	80806abc <print.constprop.1+0x3e4>

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806ac8:	e06b3003 	rsb	r3, fp, r3
80806acc:	e0633009 	rsb	r3, r3, r9
80806ad0:	e3530000 	cmp	r3, #0
80806ad4:	e58d3010 	str	r3, [sp, #16]
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
80806ad8:	d1a05002 	movle	r5, r2
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806adc:	da000012 	ble	80806b2c <print.constprop.1+0x454>
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806ae0:	e58d4014 	str	r4, [sp, #20]
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
80806ae4:	e3a05000 	mov	r5, #0
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806ae8:	e59d4010 	ldr	r4, [sp, #16]
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806aec:	ee10afb0 	mrc	15, 0, sl, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806af0:	e20aa003 	and	sl, sl, #3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806af4:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806af8:	e3a02000 	mov	r2, #0
80806afc:	e3a01020 	mov	r1, #32
80806b00:	e1a0000a 	mov	r0, sl
80806b04:	ebfffc7d 	bl	80805d00 <xUARTSendCharacter>
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806b08:	e1550004 	cmp	r5, r4
80806b0c:	bafffff8 	blt	80806af4 <print.constprop.1+0x41c>
80806b10:	e59d3010 	ldr	r3, [sp, #16]
80806b14:	e59d4014 	ldr	r4, [sp, #20]
80806b18:	e3530001 	cmp	r3, #1
80806b1c:	a1a05003 	movge	r5, r3
80806b20:	b3a05001 	movlt	r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806b24:	e3560000 	cmp	r6, #0
80806b28:	0a00000a 	beq	80806b58 <print.constprop.1+0x480>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806b2c:	ee10afb0 	mrc	15, 0, sl, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806b30:	e1a01006 	mov	r1, r6
80806b34:	e20aa003 	and	sl, sl, #3
80806b38:	e6af1071 	sxtb	r1, r1
80806b3c:	e3a02000 	mov	r2, #0
80806b40:	e1a0000a 	mov	r0, sl
80806b44:	ebfffc6d 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806b48:	e5fb1001 	ldrb	r1, [fp, #1]!
	{
		printchar(out,*string);
		count++;
80806b4c:	e2855001 	add	r5, r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806b50:	e3510000 	cmp	r1, #0
80806b54:	1afffff7 	bne	80806b38 <print.constprop.1+0x460>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806b58:	e1550009 	cmp	r5, r9
80806b5c:	aa00018e 	bge	8080719c <print.constprop.1+0xac4>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806b60:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806b64:	e2066003 	and	r6, r6, #3

	// Print any remaining padding on the right, if needed.
	while(count<width)
	{
		printchar(out,' ');
		count++;
80806b68:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806b6c:	e3a02000 	mov	r2, #0
80806b70:	e3a01020 	mov	r1, #32
80806b74:	e1a00006 	mov	r0, r6
80806b78:	ebfffc60 	bl	80805d00 <xUARTSendCharacter>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806b7c:	e1550009 	cmp	r5, r9
80806b80:	1afffff8 	bne	80806b68 <print.constprop.1+0x490>
80806b84:	eaffff96 	b	808069e4 <print.constprop.1+0x30c>
			if(*format=='l') format++;

			// Parse the conversion specifier and print appropriate output.
			if(*format=='s')
			{
				char *string=va_arg(args,char *);
80806b88:	e59d1004 	ldr	r1, [sp, #4]
				count+=printstring(out,string?string:"(null)",width,padleft);
80806b8c:	e3093af0 	movw	r3, #39664	; 0x9af0
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806b90:	e3590000 	cmp	r9, #0
80806b94:	d3a05000 	movle	r5, #0
80806b98:	c2065001 	andgt	r5, r6, #1

			// Parse the conversion specifier and print appropriate output.
			if(*format=='s')
			{
				char *string=va_arg(args,char *);
				count+=printstring(out,string?string:"(null)",width,padleft);
80806b9c:	e3483080 	movt	r3, #32896	; 0x8080
			if(*format=='l') format++;

			// Parse the conversion specifier and print appropriate output.
			if(*format=='s')
			{
				char *string=va_arg(args,char *);
80806ba0:	e591a000 	ldr	sl, [r1]
80806ba4:	e2812004 	add	r2, r1, #4
80806ba8:	e58d2004 	str	r2, [sp, #4]
				count+=printstring(out,string?string:"(null)",width,padleft);
80806bac:	e35a0000 	cmp	sl, #0
80806bb0:	01a0a003 	moveq	sl, r3
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806bb4:	e3550000 	cmp	r5, #0
80806bb8:	0a000017 	beq	80806c1c <print.constprop.1+0x544>
	{
		const char *end=string;
		while(*end) end++;
80806bbc:	e5da1000 	ldrb	r1, [sl]
80806bc0:	e3510000 	cmp	r1, #0
80806bc4:	0a00018c 	beq	808071fc <print.constprop.1+0xb24>
80806bc8:	e1a0200a 	mov	r2, sl
80806bcc:	e5f23001 	ldrb	r3, [r2, #1]!
80806bd0:	e3530000 	cmp	r3, #0
80806bd4:	1afffffc 	bne	80806bcc <print.constprop.1+0x4f4>

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806bd8:	e06a2002 	rsb	r2, sl, r2
80806bdc:	e0625009 	rsb	r5, r2, r9
80806be0:	e3550000 	cmp	r5, #0
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
80806be4:	d1a05003 	movle	r5, r3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806be8:	da00000e 	ble	80806c28 <print.constprop.1+0x550>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806bec:	ee10bfb0 	mrc	15, 0, fp, cr0, cr0, {5}
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
80806bf0:	e3a06000 	mov	r6, #0
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806bf4:	e20bb003 	and	fp, fp, #3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806bf8:	e2866001 	add	r6, r6, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806bfc:	e3a02000 	mov	r2, #0
80806c00:	e3a01020 	mov	r1, #32
80806c04:	e1a0000b 	mov	r0, fp
80806c08:	ebfffc3c 	bl	80805d00 <xUARTSendCharacter>
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806c0c:	e1560005 	cmp	r6, r5
80806c10:	bafffff8 	blt	80806bf8 <print.constprop.1+0x520>
80806c14:	e3550001 	cmp	r5, #1
80806c18:	b3a05001 	movlt	r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806c1c:	e5da1000 	ldrb	r1, [sl]
80806c20:	e3510000 	cmp	r1, #0
80806c24:	0a000009 	beq	80806c50 <print.constprop.1+0x578>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806c28:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806c2c:	e2066003 	and	r6, r6, #3
80806c30:	e6af1071 	sxtb	r1, r1
80806c34:	e3a02000 	mov	r2, #0
80806c38:	e1a00006 	mov	r0, r6
80806c3c:	ebfffc2f 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806c40:	e5fa1001 	ldrb	r1, [sl, #1]!
	{
		printchar(out,*string);
		count++;
80806c44:	e2855001 	add	r5, r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806c48:	e3510000 	cmp	r1, #0
80806c4c:	1afffff7 	bne	80806c30 <print.constprop.1+0x558>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806c50:	e1550009 	cmp	r5, r9
80806c54:	aa000150 	bge	8080719c <print.constprop.1+0xac4>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806c58:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806c5c:	e2066003 	and	r6, r6, #3

	// Print any remaining padding on the right, if needed.
	while(count<width)
	{
		printchar(out,' ');
		count++;
80806c60:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806c64:	e3a02000 	mov	r2, #0
80806c68:	e3a01020 	mov	r1, #32
80806c6c:	e1a00006 	mov	r0, r6
80806c70:	ebfffc22 	bl	80805d00 <xUARTSendCharacter>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806c74:	e1550009 	cmp	r5, r9
80806c78:	1afffff8 	bne	80806c60 <print.constprop.1+0x588>
80806c7c:	eaffff58 	b	808069e4 <print.constprop.1+0x30c>
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
80806c80:	e5d42001 	ldrb	r2, [r4, #1]
			}

			// Check for and parse precision.
			if(*format=='.')
			{
				format++;
80806c84:	e2844001 	add	r4, r4, #1

				precision=0;
				while(*format>='0'&&*format<='9')
80806c88:	e242e030 	sub	lr, r2, #48	; 0x30
80806c8c:	e6ef307e 	uxtb	r3, lr
80806c90:	e3530009 	cmp	r3, #9
80806c94:	8a000142 	bhi	808071a4 <print.constprop.1+0xacc>
80806c98:	e3a03000 	mov	r3, #0
				{
					precision*=10;
80806c9c:	e1a0c183 	lsl	ip, r3, #3
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
80806ca0:	e5f42001 	ldrb	r2, [r4, #1]!
				{
					precision*=10;
80806ca4:	e08c3083 	add	r3, ip, r3, lsl #1
					precision+=*format-'0';
80806ca8:	e08e3003 	add	r3, lr, r3
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
80806cac:	e242e030 	sub	lr, r2, #48	; 0x30
80806cb0:	e6efc07e 	uxtb	ip, lr
80806cb4:	e35c0009 	cmp	ip, #9
80806cb8:	9afffff7 	bls	80806c9c <print.constprop.1+0x5c4>
80806cbc:	e1a05002 	mov	r5, r2
80806cc0:	eafffed9 	b	8080682c <print.constprop.1+0x154>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806cc4:	e59de008 	ldr	lr, [sp, #8]
80806cc8:	e28db09f 	add	fp, sp, #159	; 0x9f

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
80806ccc:	e0810e92 	umull	r0, r1, r2, lr
80806cd0:	e1a011a1 	lsr	r1, r1, #3
80806cd4:	e1a03181 	lsl	r3, r1, #3
80806cd8:	e0833081 	add	r3, r3, r1, lsl #1
80806cdc:	e0633002 	rsb	r3, r3, r2
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806ce0:	e2512000 	subs	r2, r1, #0

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
80806ce4:	e2833030 	add	r3, r3, #48	; 0x30
80806ce8:	e56b3001 	strb	r3, [fp, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806cec:	1afffff6 	bne	80806ccc <print.constprop.1+0x5f4>
80806cf0:	eafffeef 	b	808068b4 <print.constprop.1+0x1dc>

				char *string=formatinteger(bufferend,value,16,'A'-'X'+*format,zeropadwidth,zeroisempty);
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='o')
80806cf4:	e355006f 	cmp	r5, #111	; 0x6f
80806cf8:	0a0000c1 	beq	80807004 <print.constprop.1+0x92c>

				char *string=formatinteger(bufferend,value,8,0,zeropadwidth,zeroisempty);
				if(alternate && value!=0) *--string='0';
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='c')
80806cfc:	e3550063 	cmp	r5, #99	; 0x63
80806d00:	1afffe88 	bne	80806728 <print.constprop.1+0x50>
			{
				char str[2];
				str[0]=va_arg( args, int );
80806d04:	e59d2004 	ldr	r2, [sp, #4]
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806d08:	e3590000 	cmp	r9, #0
80806d0c:	d3a05000 	movle	r5, #0
80806d10:	c2065001 	andgt	r5, r6, #1
80806d14:	e3550000 	cmp	r5, #0
			}
			else if(*format=='c')
			{
				char str[2];
				str[0]=va_arg( args, int );
				str[1]=0;
80806d18:	e5cde01d 	strb	lr, [sp, #29]
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='c')
			{
				char str[2];
				str[0]=va_arg( args, int );
80806d1c:	e5d2a000 	ldrb	sl, [r2]
80806d20:	e2823004 	add	r3, r2, #4
80806d24:	e58d3004 	str	r3, [sp, #4]
80806d28:	e5cda01c 	strb	sl, [sp, #28]
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806d2c:	0a000017 	beq	80806d90 <print.constprop.1+0x6b8>
	{
		const char *end=string;
		while(*end) end++;
80806d30:	e35a0000 	cmp	sl, #0
80806d34:	0a000138 	beq	8080721c <print.constprop.1+0xb44>
80806d38:	e28d301c 	add	r3, sp, #28
80806d3c:	e1a02003 	mov	r2, r3
80806d40:	e5f21001 	ldrb	r1, [r2, #1]!
80806d44:	e3510000 	cmp	r1, #0
80806d48:	1afffffc 	bne	80806d40 <print.constprop.1+0x668>

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806d4c:	e0632002 	rsb	r2, r3, r2
80806d50:	e0625009 	rsb	r5, r2, r9
80806d54:	e3550000 	cmp	r5, #0
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
80806d58:	d1a05001 	movle	r5, r1
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806d5c:	da00000e 	ble	80806d9c <print.constprop.1+0x6c4>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806d60:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
80806d64:	e3a0b000 	mov	fp, #0
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806d68:	e2066003 	and	r6, r6, #3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806d6c:	e28bb001 	add	fp, fp, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806d70:	e3a02000 	mov	r2, #0
80806d74:	e3a01020 	mov	r1, #32
80806d78:	e1a00006 	mov	r0, r6
80806d7c:	ebfffbdf 	bl	80805d00 <xUARTSendCharacter>
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806d80:	e15b0005 	cmp	fp, r5
80806d84:	bafffff8 	blt	80806d6c <print.constprop.1+0x694>
80806d88:	e3550001 	cmp	r5, #1
80806d8c:	b3a05001 	movlt	r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806d90:	e35a0000 	cmp	sl, #0
80806d94:	0a00000c 	beq	80806dcc <print.constprop.1+0x6f4>
80806d98:	e28d301c 	add	r3, sp, #28
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806d9c:	ee10bfb0 	mrc	15, 0, fp, cr0, cr0, {5}
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
80806da0:	e1a06003 	mov	r6, r3
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806da4:	e20bb003 	and	fp, fp, #3
80806da8:	e1a0100a 	mov	r1, sl
80806dac:	e6af1071 	sxtb	r1, r1
80806db0:	e3a02000 	mov	r2, #0
80806db4:	e1a0000b 	mov	r0, fp
80806db8:	ebfffbd0 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806dbc:	e5f61001 	ldrb	r1, [r6, #1]!
	{
		printchar(out,*string);
		count++;
80806dc0:	e2855001 	add	r5, r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806dc4:	e3510000 	cmp	r1, #0
80806dc8:	1afffff7 	bne	80806dac <print.constprop.1+0x6d4>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806dcc:	e1550009 	cmp	r5, r9
80806dd0:	aa000006 	bge	80806df0 <print.constprop.1+0x718>
	{
		printchar(out,' ');
		count++;
80806dd4:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806dd8:	e3a02000 	mov	r2, #0
80806ddc:	e3a01020 	mov	r1, #32
80806de0:	e59d000c 	ldr	r0, [sp, #12]
80806de4:	ebfffbc5 	bl	80805d00 <xUARTSendCharacter>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806de8:	e1550009 	cmp	r5, r9
80806dec:	1afffff8 	bne	80806dd4 <print.constprop.1+0x6fc>
			else if(*format=='c')
			{
				char str[2];
				str[0]=va_arg( args, int );
				str[1]=0;
				count+=printstring(out,str,width,padleft);
80806df0:	e0877005 	add	r7, r7, r5
80806df4:	eafffe4b 	b	80806728 <print.constprop.1+0x50>

static int print(char **out,const char *format,va_list args)
{
	char buffer[128];
	char *bufferend=&buffer[sizeof(buffer)];
	int count=0;
80806df8:	e1a07001 	mov	r7, r1
80806dfc:	eafffe6c 	b	808067b4 <print.constprop.1+0xdc>

				char *string=formatinteger(bufferend,absvalue,10,0,zeropadwidth,zeroisempty);

				// Handle the sign.
				if(isnegative) *--string='-';
				else if(positivechar) *--string=positivechar;
80806e00:	e35a0000 	cmp	sl, #0
80806e04:	154ba001 	strbne	sl, [fp, #-1]
80806e08:	124bb001 	subne	fp, fp, #1
80806e0c:	eafffeb9 	b	808068f8 <print.constprop.1+0x220>

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
			{
				int value=va_arg(args,int);
80806e10:	e59d0004 	ldr	r0, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80806e14:	e0111fa3 	ands	r1, r1, r3, lsr #31

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806e18:	e5cde09f 	strb	lr, [sp, #159]	; 0x9f
			else if(*format=='u')
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80806e1c:	11a0c009 	movne	ip, r9
80806e20:	01a0c003 	moveq	ip, r3

				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='u')
			{
				int value=va_arg(args,int);
80806e24:	e5902000 	ldr	r2, [r0]
80806e28:	e2801004 	add	r1, r0, #4
80806e2c:	e58d1004 	str	r1, [sp, #4]
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806e30:	e3520000 	cmp	r2, #0
80806e34:	1a000064 	bne	80806fcc <print.constprop.1+0x8f4>
	{
		if(!zeroisempty) *--string='0';
80806e38:	e3530000 	cmp	r3, #0
80806e3c:	058d3010 	streq	r3, [sp, #16]

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80806e40:	028d509f 	addeq	r5, sp, #159	; 0x9f

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
80806e44:	13a03030 	movne	r3, #48	; 0x30
80806e48:	128d50a0 	addne	r5, sp, #160	; 0xa0
80806e4c:	15653002 	strbne	r3, [r5, #-2]!
80806e50:	158d3010 	strne	r3, [sp, #16]
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
80806e54:	e35c0000 	cmp	ip, #0
80806e58:	da0000d4 	ble	808071b0 <print.constprop.1+0xad8>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
80806e5c:	e28d30a0 	add	r3, sp, #160	; 0xa0
80806e60:	e0652003 	rsb	r2, r5, r3
80806e64:	e2422001 	sub	r2, r2, #1
80806e68:	e062200c 	rsb	r2, r2, ip
80806e6c:	e3520000 	cmp	r2, #0
80806e70:	da0000ce 	ble	808071b0 <print.constprop.1+0xad8>
80806e74:	e0625005 	rsb	r5, r2, r5
80806e78:	e3a01030 	mov	r1, #48	; 0x30
80806e7c:	e1a00005 	mov	r0, r5
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
80806e80:	e3590000 	cmp	r9, #0
80806e84:	d3a06000 	movle	r6, #0
80806e88:	c2066001 	andgt	r6, r6, #1
80806e8c:	fa000a92 	blx	808098dc <memset>
80806e90:	e3560000 	cmp	r6, #0
80806e94:	03a01030 	moveq	r1, #48	; 0x30
80806e98:	0a00001b 	beq	80806f0c <print.constprop.1+0x834>
80806e9c:	e3a03030 	mov	r3, #48	; 0x30
80806ea0:	e58d3010 	str	r3, [sp, #16]
80806ea4:	e1a03005 	mov	r3, r5
	{
		const char *end=string;
		while(*end) end++;
80806ea8:	e5f36001 	ldrb	r6, [r3, #1]!
80806eac:	e3560000 	cmp	r6, #0
80806eb0:	1afffffc 	bne	80806ea8 <print.constprop.1+0x7d0>

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806eb4:	e0653003 	rsb	r3, r5, r3
80806eb8:	e063a009 	rsb	sl, r3, r9
80806ebc:	e35a0000 	cmp	sl, #0
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806ec0:	d59d1010 	ldrle	r1, [sp, #16]
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806ec4:	da000010 	ble	80806f0c <print.constprop.1+0x834>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806ec8:	ee10bfb0 	mrc	15, 0, fp, cr0, cr0, {5}
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
80806ecc:	e3a06000 	mov	r6, #0
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806ed0:	e20bb003 	and	fp, fp, #3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806ed4:	e2866001 	add	r6, r6, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806ed8:	e3a02000 	mov	r2, #0
80806edc:	e3a01020 	mov	r1, #32
80806ee0:	e1a0000b 	mov	r0, fp
80806ee4:	ebfffb85 	bl	80805d00 <xUARTSendCharacter>
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80806ee8:	e156000a 	cmp	r6, sl
80806eec:	bafffff8 	blt	80806ed4 <print.constprop.1+0x7fc>
80806ef0:	e35a0001 	cmp	sl, #1
80806ef4:	a1a0600a 	movge	r6, sl
80806ef8:	b3a06001 	movlt	r6, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806efc:	e59d3010 	ldr	r3, [sp, #16]
80806f00:	e3530000 	cmp	r3, #0
80806f04:	0a00000a 	beq	80806f34 <print.constprop.1+0x85c>
80806f08:	e1a01003 	mov	r1, r3
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806f0c:	ee10afb0 	mrc	15, 0, sl, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806f10:	e20aa003 	and	sl, sl, #3
80806f14:	e6af1071 	sxtb	r1, r1
80806f18:	e3a02000 	mov	r2, #0
80806f1c:	e1a0000a 	mov	r0, sl
80806f20:	ebfffb76 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806f24:	e5f51001 	ldrb	r1, [r5, #1]!
	{
		printchar(out,*string);
		count++;
80806f28:	e2866001 	add	r6, r6, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80806f2c:	e3510000 	cmp	r1, #0
80806f30:	1afffff7 	bne	80806f14 <print.constprop.1+0x83c>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806f34:	e1560009 	cmp	r6, r9
80806f38:	aa0000b1 	bge	80807204 <print.constprop.1+0xb2c>
80806f3c:	e1a05006 	mov	r5, r6
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80806f40:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806f44:	e2066003 	and	r6, r6, #3

	// Print any remaining padding on the right, if needed.
	while(count<width)
	{
		printchar(out,' ');
		count++;
80806f48:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80806f4c:	e3a02000 	mov	r2, #0
80806f50:	e3a01020 	mov	r1, #32
80806f54:	e1a00006 	mov	r0, r6
80806f58:	ebfffb68 	bl	80805d00 <xUARTSendCharacter>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80806f5c:	e1550009 	cmp	r5, r9
80806f60:	1afffff8 	bne	80806f48 <print.constprop.1+0x870>
80806f64:	eafffe9e 	b	808069e4 <print.constprop.1+0x30c>
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
80806f68:	e0111fa3 	ands	r1, r1, r3, lsr #31
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
				{
					isnegative=true;
					absvalue=-value;
80806f6c:	e2622000 	rsb	r2, r2, #0
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
80806f70:	01a0c003 	moveq	ip, r3
				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
				{
					isnegative=true;
80806f74:	03a05001 	moveq	r5, #1
				}

				// If zero padding was requested and no precision was specified,
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
80806f78:	0afffe44 	beq	80806890 <print.constprop.1+0x1b8>
				// Check if the number is signed and negative.
				unsigned int absvalue=value;
				bool isnegative=false;
				if(value<0)
				{
					isnegative=true;
80806f7c:	e3a05001 	mov	r5, #1
				// set the precision to fill the available space with zeroes.
				int zeropadwidth=precision;
				if(padzero && precision<0)
				{
					zeropadwidth=width;
					if(isnegative || positivechar) zeropadwidth-=1; // Reserve space for a sign, if needed.
80806f80:	e249c001 	sub	ip, r9, #1
80806f84:	eafffe41 	b	80806890 <print.constprop.1+0x1b8>
80806f88:	e3520000 	cmp	r2, #0
80806f8c:	03a0a000 	moveq	sl, #0
80806f90:	1200a001 	andne	sl, r0, #1
			else if(*format=='x' || *format=='X')
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0)
80806f94:	e1a01003 	mov	r1, r3
80806f98:	eafffea4 	b	80806a30 <print.constprop.1+0x358>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806f9c:	e28db09f 	add	fp, sp, #159	; 0x9f
80806fa0:	e2450021 	sub	r0, r5, #33	; 0x21
	}
	else
	{
		while(absvalue)
		{
			unsigned int digit=absvalue%base;
80806fa4:	e202300f 	and	r3, r2, #15

			char c;
			if(digit>=10) c=digit-10+letterbase;
80806fa8:	e6efc073 	uxtb	ip, r3
			else c=digit+'0';

			*--string=c;
80806fac:	e3530009 	cmp	r3, #9
		while(absvalue)
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
80806fb0:	e08c3000 	add	r3, ip, r0
80806fb4:	e6ef3073 	uxtb	r3, r3
			else c=digit+'0';

			*--string=c;
80806fb8:	928c3030 	addls	r3, ip, #48	; 0x30
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806fbc:	e1b02222 	lsrs	r2, r2, #4

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
80806fc0:	e56b3001 	strb	r3, [fp, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806fc4:	1afffff6 	bne	80806fa4 <print.constprop.1+0x8cc>
80806fc8:	eafffea1 	b	80806a54 <print.constprop.1+0x37c>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
80806fcc:	e59de008 	ldr	lr, [sp, #8]
80806fd0:	e28d509f 	add	r5, sp, #159	; 0x9f
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';
80806fd4:	e0810e92 	umull	r0, r1, r2, lr
80806fd8:	e1a011a1 	lsr	r1, r1, #3
80806fdc:	e1a03181 	lsl	r3, r1, #3
80806fe0:	e0833081 	add	r3, r3, r1, lsl #1
80806fe4:	e0633002 	rsb	r3, r3, r2
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806fe8:	e2512000 	subs	r2, r1, #0
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';
80806fec:	e2833030 	add	r3, r3, #48	; 0x30
80806ff0:	e6ef3073 	uxtb	r3, r3

			*--string=c;
80806ff4:	e5653001 	strb	r3, [r5, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
80806ff8:	1afffff5 	bne	80806fd4 <print.constprop.1+0x8fc>
		{
			unsigned int digit=absvalue%base;

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';
80806ffc:	e58d3010 	str	r3, [sp, #16]
80807000:	eaffff93 	b	80806e54 <print.constprop.1+0x77c>
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='o')
			{
				int value=va_arg(args,int);
80807004:	e59dc004 	ldr	ip, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80807008:	e0111fa3 	ands	r1, r1, r3, lsr #31
				if(alternate && value!=0) { *--string=*format; *--string='0'; }
				count+=printstring(out,string,width,padleft);
			}
			else if(*format=='o')
			{
				int value=va_arg(args,int);
8080700c:	e59c2000 	ldr	r2, [ip]
80807010:	e28c1004 	add	r1, ip, #4
80807014:	e58d1004 	str	r1, [sp, #4]

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
80807018:	11a01009 	movne	r1, r9
8080701c:	01a01003 	moveq	r1, r3

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80807020:	e3a0c000 	mov	ip, #0
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
				if(alternate && value!=0) zeropadwidth-=1;
80807024:	e3520000 	cmp	r2, #0
80807028:	03a05000 	moveq	r5, #0
8080702c:	12005001 	andne	r5, r0, #1

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80807030:	e5cdc09f 	strb	ip, [sp, #159]	; 0x9f
			{
				int value=va_arg(args,int);

				int zeropadwidth=precision;
				if(padzero && precision<0) zeropadwidth=width;
				if(alternate && value!=0) zeropadwidth-=1;
80807034:	e3550000 	cmp	r5, #0
80807038:	12411001 	subne	r1, r1, #1
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
8080703c:	e3520000 	cmp	r2, #0
80807040:	1a000066 	bne	808071e0 <print.constprop.1+0xb08>
	{
		if(!zeroisempty) *--string='0';
80807044:	e16f3f13 	clz	r3, r3
80807048:	e1a032a3 	lsr	r3, r3, #5
8080704c:	e1530000 	cmp	r3, r0

static char *formatinteger(char *bufferend,unsigned int absvalue,
unsigned int base,char letterbase,int zeropadwidth,bool zeroisempty)
{
	char *string=bufferend;
	*--string=0;
80807050:	828da09f 	addhi	sl, sp, #159	; 0x9f

	// Generate the digits in reverse.
	if(!absvalue)
	{
		if(!zeroisempty) *--string='0';
80807054:	93a03030 	movls	r3, #48	; 0x30
80807058:	928da0a0 	addls	sl, sp, #160	; 0xa0
8080705c:	956a3002 	strbls	r3, [sl, #-2]!
			absvalue/=base;
		}
	}

	// Zero pad the number if requested.
	if(zeropadwidth>0)
80807060:	e3510000 	cmp	r1, #0
80807064:	da000009 	ble	80807090 <print.constprop.1+0x9b8>
	{
		int length=bufferend-string-1;
		for(int i=0;i<zeropadwidth-length;i++) *--string='0';
80807068:	e28d30a0 	add	r3, sp, #160	; 0xa0
8080706c:	e06a2003 	rsb	r2, sl, r3
80807070:	e2422001 	sub	r2, r2, #1
80807074:	e0622001 	rsb	r2, r2, r1
80807078:	e3520000 	cmp	r2, #0
8080707c:	da000003 	ble	80807090 <print.constprop.1+0x9b8>
80807080:	e062a00a 	rsb	sl, r2, sl
80807084:	e3a01030 	mov	r1, #48	; 0x30
80807088:	e1a0000a 	mov	r0, sl
8080708c:	fa000a12 	blx	808098dc <memset>
				if(alternate && value!=0) zeropadwidth-=1;

				bool zeroisempty=precision==0 && !alternate;

				char *string=formatinteger(bufferend,value,8,0,zeropadwidth,zeroisempty);
				if(alternate && value!=0) *--string='0';
80807090:	e3550000 	cmp	r5, #0
80807094:	13a03030 	movne	r3, #48	; 0x30
80807098:	154a3001 	strbne	r3, [sl, #-1]
8080709c:	124aa001 	subne	sl, sl, #1
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
808070a0:	e3590000 	cmp	r9, #0
808070a4:	d3a05000 	movle	r5, #0
808070a8:	c2065001 	andgt	r5, r6, #1
	{
		const char *end=string;
		while(*end) end++;
808070ac:	e5da6000 	ldrb	r6, [sl]
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
808070b0:	e3550000 	cmp	r5, #0
808070b4:	0a00001f 	beq	80807138 <print.constprop.1+0xa60>
	{
		const char *end=string;
		while(*end) end++;
808070b8:	e3560000 	cmp	r6, #0
808070bc:	0a000054 	beq	80807214 <print.constprop.1+0xb3c>
808070c0:	e1a0300a 	mov	r3, sl
808070c4:	e5f32001 	ldrb	r2, [r3, #1]!
808070c8:	e3520000 	cmp	r2, #0
808070cc:	1afffffc 	bne	808070c4 <print.constprop.1+0x9ec>

		int length=end-string;
		for(int i=0;i<width-length;i++)
808070d0:	e06a3003 	rsb	r3, sl, r3
808070d4:	e0635009 	rsb	r5, r3, r9
808070d8:	e3550000 	cmp	r5, #0
}
#endif

static int printstring(char **out,const char *string,int width,bool padleft)
{
	int count=0;
808070dc:	d1a05002 	movle	r5, r2
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
808070e0:	da000016 	ble	80807140 <print.constprop.1+0xa68>
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
808070e4:	e3a03000 	mov	r3, #0
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808070e8:	e58d4010 	str	r4, [sp, #16]
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808070ec:	ee10bfb0 	mrc	15, 0, fp, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808070f0:	e1a04003 	mov	r4, r3
808070f4:	e20bb003 	and	fp, fp, #3
808070f8:	e1a03008 	mov	r3, r8
808070fc:	e1a08006 	mov	r8, r6
80807100:	e1a0600b 	mov	r6, fp
80807104:	e1a0b003 	mov	fp, r3
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
80807108:	e2844001 	add	r4, r4, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
8080710c:	e3a02000 	mov	r2, #0
80807110:	e3a01020 	mov	r1, #32
80807114:	e1a00006 	mov	r0, r6
80807118:	ebfffaf8 	bl	80805d00 <xUARTSendCharacter>
	{
		const char *end=string;
		while(*end) end++;

		int length=end-string;
		for(int i=0;i<width-length;i++)
8080711c:	e1540005 	cmp	r4, r5
80807120:	bafffff8 	blt	80807108 <print.constprop.1+0xa30>
80807124:	e59d4010 	ldr	r4, [sp, #16]
80807128:	e3550001 	cmp	r5, #1
8080712c:	e1a06008 	mov	r6, r8
80807130:	b3a05001 	movlt	r5, #1
80807134:	e1a0800b 	mov	r8, fp
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80807138:	e3560000 	cmp	r6, #0
8080713c:	0a00000a 	beq	8080716c <print.constprop.1+0xa94>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80807140:	ee10bfb0 	mrc	15, 0, fp, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80807144:	e1a01006 	mov	r1, r6
80807148:	e20bb003 	and	fp, fp, #3
8080714c:	e6af1071 	sxtb	r1, r1
80807150:	e3a02000 	mov	r2, #0
80807154:	e1a0000b 	mov	r0, fp
80807158:	ebfffae8 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
8080715c:	e5fa1001 	ldrb	r1, [sl, #1]!
	{
		printchar(out,*string);
		count++;
80807160:	e2855001 	add	r5, r5, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80807164:	e3510000 	cmp	r1, #0
80807168:	1afffff7 	bne	8080714c <print.constprop.1+0xa74>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
8080716c:	e1550009 	cmp	r5, r9
80807170:	aa000009 	bge	8080719c <print.constprop.1+0xac4>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80807174:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80807178:	e2066003 	and	r6, r6, #3

	// Print any remaining padding on the right, if needed.
	while(count<width)
	{
		printchar(out,' ');
		count++;
8080717c:	e2855001 	add	r5, r5, #1
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
80807180:	e3a02000 	mov	r2, #0
80807184:	e3a01020 	mov	r1, #32
80807188:	e1a00006 	mov	r0, r6
8080718c:	ebfffadb 	bl	80805d00 <xUARTSendCharacter>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80807190:	e1550009 	cmp	r5, r9
80807194:	1afffff8 	bne	8080717c <print.constprop.1+0xaa4>
80807198:	eafffe11 	b	808069e4 <print.constprop.1+0x30c>
8080719c:	e1a09005 	mov	r9, r5
808071a0:	eafffe0f 	b	808069e4 <print.constprop.1+0x30c>
			if(*format=='.')
			{
				format++;

				precision=0;
				while(*format>='0'&&*format<='9')
808071a4:	e1a05002 	mov	r5, r2
			// Check for and parse precision.
			if(*format=='.')
			{
				format++;

				precision=0;
808071a8:	e3a03000 	mov	r3, #0
808071ac:	eafffd9e 	b	8080682c <print.constprop.1+0x154>
{
	int count=0;

	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
808071b0:	e3590000 	cmp	r9, #0
808071b4:	d3a06000 	movle	r6, #0
808071b8:	c2066001 	andgt	r6, r6, #1
808071bc:	e3560000 	cmp	r6, #0
808071c0:	0affff4d 	beq	80806efc <print.constprop.1+0x824>
	{
		const char *end=string;
		while(*end) end++;
808071c4:	e59d3010 	ldr	r3, [sp, #16]
808071c8:	e3530000 	cmp	r3, #0
808071cc:	1affff34 	bne	80806ea4 <print.constprop.1+0x7cc>
808071d0:	e1a0a009 	mov	sl, r9
808071d4:	eaffff3b 	b	80806ec8 <print.constprop.1+0x7f0>
808071d8:	e58d9010 	str	r9, [sp, #16]
808071dc:	eafffdd7 	b	80806940 <print.constprop.1+0x268>
{
	char *string=bufferend;
	*--string=0;

	// Generate the digits in reverse.
	if(!absvalue)
808071e0:	e28da09f 	add	sl, sp, #159	; 0x9f

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808071e4:	e2023007 	and	r3, r2, #7
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808071e8:	e1b021a2 	lsrs	r2, r2, #3

			char c;
			if(digit>=10) c=digit-10+letterbase;
			else c=digit+'0';

			*--string=c;
808071ec:	e2833030 	add	r3, r3, #48	; 0x30
808071f0:	e56a3001 	strb	r3, [sl, #-1]!
	{
		if(!zeroisempty) *--string='0';
	}
	else
	{
		while(absvalue)
808071f4:	1afffffa 	bne	808071e4 <print.constprop.1+0xb0c>
808071f8:	eaffff98 	b	80807060 <print.constprop.1+0x988>
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
808071fc:	e1a05009 	mov	r5, r9
80807200:	eafffe79 	b	80806bec <print.constprop.1+0x514>
		count++;
		string++;
	}

	// Print any remaining padding on the right, if needed.
	while(count<width)
80807204:	e1a09006 	mov	r9, r6
80807208:	eafffdf5 	b	808069e4 <print.constprop.1+0x30c>
	// If we need to pad on the left, calculate the length of the string and
	// print the appropriate amount of padding.
	if(width>0 && padleft)
	{
		const char *end=string;
		while(*end) end++;
8080720c:	e58d9010 	str	r9, [sp, #16]
80807210:	eafffe32 	b	80806ae0 <print.constprop.1+0x408>
80807214:	e1a05009 	mov	r5, r9
80807218:	eaffffb1 	b	808070e4 <print.constprop.1+0xa0c>
8080721c:	e1a05009 	mov	r5, r9
80807220:	eafffece 	b	80806d60 <print.constprop.1+0x688>

80807224 <printf>:
static int printstring(char **out,const char *string,int width,bool padleft);
static void printchar(char **out,int c);
int putchar(int c);

int printf(const char *format,...)
{
80807224:	e92d000f 	push	{r0, r1, r2, r3}
80807228:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
8080722c:	e24dd00c 	sub	sp, sp, #12
	va_list args;
	va_start(args,format);
80807230:	e28d3014 	add	r3, sp, #20
	return print(0,format,args);
80807234:	e1a01003 	mov	r1, r3
80807238:	e59d0010 	ldr	r0, [sp, #16]
int putchar(int c);

int printf(const char *format,...)
{
	va_list args;
	va_start(args,format);
8080723c:	e58d3004 	str	r3, [sp, #4]
	return print(0,format,args);
80807240:	ebfffd24 	bl	808066d8 <print.constprop.1>
}
80807244:	e28dd00c 	add	sp, sp, #12
80807248:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
8080724c:	e28dd010 	add	sp, sp, #16
80807250:	e12fff1e 	bx	lr

80807254 <sprintf>:

int sprintf(char *out,const char *format,...)
{
80807254:	e92d000e 	push	{r1, r2, r3}
80807258:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
8080725c:	e24dd010 	sub	sp, sp, #16
	va_list args;
	va_start(args,format);
80807260:	e28d3018 	add	r3, sp, #24
	return print(&out,format,args);
80807264:	e1a02003 	mov	r2, r3
	va_start(args,format);
	return print(0,format,args);
}

int sprintf(char *out,const char *format,...)
{
80807268:	e58d0004 	str	r0, [sp, #4]
	va_list args;
	va_start(args,format);
	return print(&out,format,args);
8080726c:	e28d0004 	add	r0, sp, #4
80807270:	e59d1014 	ldr	r1, [sp, #20]
}

int sprintf(char *out,const char *format,...)
{
	va_list args;
	va_start(args,format);
80807274:	e58d300c 	str	r3, [sp, #12]
	return print(&out,format,args);
80807278:	ebfffb90 	bl	808060c0 <print>
}
8080727c:	e28dd010 	add	sp, sp, #16
80807280:	e49de004 	pop	{lr}		; (ldr lr, [sp], #4)
80807284:	e28dd00c 	add	sp, sp, #12
80807288:	e12fff1e 	bx	lr

8080728c <puts>:

int puts(const char *s)
{
8080728c:	e92d4070 	push	{r4, r5, r6, lr}
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
80807290:	e5d01000 	ldrb	r1, [r0]
80807294:	e3510000 	cmp	r1, #0
80807298:	0a000015 	beq	808072f4 <puts+0x68>
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
8080729c:	ee106fb0 	mrc	15, 0, r6, cr0, cr0, {5}
808072a0:	e1a05000 	mov	r5, r0
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
808072a4:	e3a04000 	mov	r4, #0
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808072a8:	e2066003 	and	r6, r6, #3
808072ac:	ea000000 	b	808072b4 <puts+0x28>

	// Print the contents of the string.
	while(*string)
	{
		printchar(out,*string);
		count++;
808072b0:	e1a04003 	mov	r4, r3
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808072b4:	e6af1071 	sxtb	r1, r1
808072b8:	e3a02000 	mov	r2, #0
808072bc:	e1a00006 	mov	r0, r6
808072c0:	ebfffa8e 	bl	80805d00 <xUARTSendCharacter>
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
808072c4:	e5f51001 	ldrb	r1, [r5, #1]!
	{
		printchar(out,*string);
		count++;
808072c8:	e2843001 	add	r3, r4, #1
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
808072cc:	e3510000 	cmp	r1, #0
808072d0:	1afffff6 	bne	808072b0 <puts+0x24>
808072d4:	e2844002 	add	r4, r4, #2
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808072d8:	e3a02000 	mov	r2, #0
808072dc:	e3a0100a 	mov	r1, #10
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808072e0:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808072e4:	e2000003 	and	r0, r0, #3
808072e8:	ebfffa84 	bl	80805d00 <xUARTSendCharacter>
int puts(const char *s)
{
	int count=printstring(0,s,0,false);
	printchar(0,'\n');
	return count+1;
}
808072ec:	e1a00004 	mov	r0, r4
808072f0:	e8bd8070 	pop	{r4, r5, r6, pc}
			count++;
		}
	}

	// Print the contents of the string.
	while(*string)
808072f4:	e3a04001 	mov	r4, #1
808072f8:	eafffff6 	b	808072d8 <puts+0x4c>

808072fc <putchar>:
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
808072fc:	e6af1070 	sxtb	r1, r0
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
	return val&3;
}

int putchar(int c)
{
80807300:	e92d4010 	push	{r4, lr}
	xUARTSendCharacter(portCORE_ID(),c,0);
80807304:	e3a02000 	mov	r2, #0
extern void xUARTSendCharacter(unsigned long ulUARTPeripheral,signed char cChar,unsigned long xDelay);

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
80807308:	ee100fb0 	mrc	15, 0, r0, cr0, cr0, {5}
	return val&3;
}

int putchar(int c)
{
	xUARTSendCharacter(portCORE_ID(),c,0);
8080730c:	e2000003 	and	r0, r0, #3
80807310:	ebfffa7a 	bl	80805d00 <xUARTSendCharacter>
	return 0;
}
80807314:	e3a00000 	mov	r0, #0
80807318:	e8bd8010 	pop	{r4, pc}

8080731c <xSerialPortInitMinimal>:
extern portBASE_TYPE xUARTSendCharacter( unsigned long ulUARTPeripheral, signed char cChar, portTickType xDelay );
extern void vUARTInitialise(unsigned long ulUARTPeripheral, unsigned long ulBaud, unsigned long ulQueueSize );

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
	vUARTInitialise( configUART_PORT, ulWantedBaud, uxQueueLength );
8080731c:	e1a02001 	mov	r2, r1
extern portBASE_TYPE xUARTReceiveCharacter( unsigned long ulUARTPeripheral, signed char *pcChar, portTickType xDelay );
extern portBASE_TYPE xUARTSendCharacter( unsigned long ulUARTPeripheral, signed char cChar, portTickType xDelay );
extern void vUARTInitialise(unsigned long ulUARTPeripheral, unsigned long ulBaud, unsigned long ulQueueSize );

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
80807320:	e92d4010 	push	{r4, lr}
	vUARTInitialise( configUART_PORT, ulWantedBaud, uxQueueLength );
80807324:	e1a01000 	mov	r1, r0
80807328:	e3a00002 	mov	r0, #2
8080732c:	ebfffa72 	bl	80805cfc <vUARTInitialise>
	return (xComPortHandle) configUART_PORT;
}
80807330:	e3a00002 	mov	r0, #2
80807334:	e8bd8010 	pop	{r4, pc}

80807338 <vSerialPutString>:

void vSerialPutString( xComPortHandle pxPort, const signed char * const pcString, unsigned short usStringLength )
{
unsigned short usIndex = 0;
	for ( usIndex = 0; usIndex < usStringLength; usIndex++ )
80807338:	e3520000 	cmp	r2, #0
8080733c:	012fff1e 	bxeq	lr
80807340:	e2422001 	sub	r2, r2, #1
	vUARTInitialise( configUART_PORT, ulWantedBaud, uxQueueLength );
	return (xComPortHandle) configUART_PORT;
}

void vSerialPutString( xComPortHandle pxPort, const signed char * const pcString, unsigned short usStringLength )
{
80807344:	e92d4070 	push	{r4, r5, r6, lr}
80807348:	e6f15072 	uxtah	r5, r1, r2
8080734c:	e1a06000 	mov	r6, r0
80807350:	e2414001 	sub	r4, r1, #1
unsigned short usIndex = 0;
	for ( usIndex = 0; usIndex < usStringLength; usIndex++ )
	{
		if ( pdTRUE != xUARTSendCharacter( (unsigned long)pxPort, pcString[usIndex], portMAX_DELAY ) )
80807354:	e3e02000 	mvn	r2, #0
80807358:	e1f410d1 	ldrsb	r1, [r4, #1]!
8080735c:	e1a00006 	mov	r0, r6
80807360:	ebfffa66 	bl	80805d00 <xUARTSendCharacter>
80807364:	e3500001 	cmp	r0, #1
80807368:	18bd8070 	popne	{r4, r5, r6, pc}
}

void vSerialPutString( xComPortHandle pxPort, const signed char * const pcString, unsigned short usStringLength )
{
unsigned short usIndex = 0;
	for ( usIndex = 0; usIndex < usStringLength; usIndex++ )
8080736c:	e1540005 	cmp	r4, r5
80807370:	1afffff7 	bne	80807354 <vSerialPutString+0x1c>
80807374:	e8bd8070 	pop	{r4, r5, r6, pc}

80807378 <xSerialGetChar>:
	}
}

signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, portTickType xBlockTime )
{
	return xUARTReceiveCharacter( (unsigned long)pxPort, pcRxedChar, xBlockTime );
80807378:	eafffa83 	b	80805d8c <xUARTReceiveCharacter>

8080737c <xSerialPutChar>:
}

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, portTickType xBlockTime )
{
	return xUARTSendCharacter( (unsigned long)pxPort, cOutChar, xBlockTime );
8080737c:	eafffa5f 	b	80805d00 <xUARTSendCharacter>

80807380 <vTimer0Initialise>:
#define TIMER_2_BGLOAD		( ( unsigned long * volatile ) ( TIMER_0_1_BASE + 0x38 ) )	/* Background Load Register */
/*----------------------------------------------------------------------------*/

void vTimer0Initialise( unsigned long ulLoadValue )
{
	*TIMER_1_LOAD = ulLoadValue;
80807380:	e3a03a05 	mov	r3, #20480	; 0x5000
80807384:	e3463000 	movt	r3, #24576	; 0x6000
80807388:	e5830000 	str	r0, [r3]
8080738c:	e12fff1e 	bx	lr

80807390 <vTimer0Enable>:
}
/*----------------------------------------------------------------------------*/

void vTimer0Enable( void )
{
	*TIMER_1_CONTROL = 0xE0UL;
80807390:	e3a03a05 	mov	r3, #20480	; 0x5000
80807394:	e3a020e0 	mov	r2, #224	; 0xe0
80807398:	e3463000 	movt	r3, #24576	; 0x6000
8080739c:	e5832008 	str	r2, [r3, #8]
808073a0:	e12fff1e 	bx	lr

808073a4 <vTimer0InterruptHandler>:
/*----------------------------------------------------------------------------*/

void vTimer0InterruptHandler( void *pvParameter )
{
    extern BaseType_t xTaskIncrementTick( void );
	*TIMER_1_INTCLR = 1;
808073a4:	e3a03a05 	mov	r3, #20480	; 0x5000
808073a8:	e3a02001 	mov	r2, #1
808073ac:	e3463000 	movt	r3, #24576	; 0x6000
	*TIMER_1_CONTROL = 0xE0UL;
}
/*----------------------------------------------------------------------------*/

void vTimer0InterruptHandler( void *pvParameter )
{
808073b0:	e92d4010 	push	{r4, lr}
    extern BaseType_t xTaskIncrementTick( void );
	*TIMER_1_INTCLR = 1;
808073b4:	e583200c 	str	r2, [r3, #12]

	xTaskIncrementTick();
808073b8:	ebffedab 	bl	80802a6c <xTaskIncrementTick>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808073bc:	e3a01a01 	mov	r1, #4096	; 0x1000
808073c0:	e3441824 	movt	r1, #18468	; 0x4824
808073c4:	e5913200 	ldr	r3, [r1, #512]	; 0x200
808073c8:	e3130001 	tst	r3, #1
808073cc:	18bd8010 	popne	{r4, pc}
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808073d0:	e3a02801 	mov	r2, #65536	; 0x10000
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
808073d4:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808073d8:	e2033003 	and	r3, r3, #3
808073dc:	e1a03312 	lsl	r3, r2, r3
808073e0:	e3833001 	orr	r3, r3, #1
808073e4:	e5813f00 	str	r3, [r1, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
808073e8:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
808073ec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808073f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808073f4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808073f8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808073fc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807400:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807404:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807408:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080740c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807410:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807414:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807418:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080741c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807420:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807424:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807428:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080742c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807430:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807434:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807438:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080743c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807440:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807444:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807448:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080744c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807450:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807454:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807458:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080745c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807460:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80807464:	e320f000 	nop	{0}
80807468:	e8bd8010 	pop	{r4, pc}

8080746c <vBlockingQueueProducer>:
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueProducer, pvParameters )
{
8080746c:	e92d4070 	push	{r4, r5, r6, lr}
80807470:	e1a04000 	mov	r4, r0
80807474:	e24dd008 	sub	sp, sp, #8
unsigned short usValue = 0;
80807478:	e3a05000 	mov	r5, #0
8080747c:	e28d6008 	add	r6, sp, #8
80807480:	e16650b2 	strh	r5, [r6, #-2]!

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;

	for( ;; )
	{		
		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
80807484:	e3a03000 	mov	r3, #0
80807488:	e5942004 	ldr	r2, [r4, #4]
8080748c:	e1a01006 	mov	r1, r6
80807490:	e5940000 	ldr	r0, [r4]
80807494:	ebffe408 	bl	808004bc <xQueueGenericSend>
80807498:	e3500001 	cmp	r0, #1
		{
			sErrorEverOccurred = pdTRUE;
8080749c:	13a05001 	movne	r5, #1

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;

	for( ;; )
	{		
		if( xQueueSend( pxQueueParameters->xQueue, ( void * ) &usValue, pxQueueParameters->xBlockTime ) != pdPASS )
808074a0:	1afffff7 	bne	80807484 <vBlockingQueueProducer+0x18>
		}
		else
		{
			/* We have successfully posted a message, so increment the variable
			used to check we are still running. */
			if( sErrorEverOccurred == pdFALSE )
808074a4:	e3550000 	cmp	r5, #0
			{
				( *pxQueueParameters->psCheckVariable )++;
808074a8:	05942008 	ldreq	r2, [r4, #8]
808074ac:	01d230b0 	ldrheq	r3, [r2]
808074b0:	02833001 	addeq	r3, r3, #1
808074b4:	06ff3073 	uxtheq	r3, r3
808074b8:	01c230b0 	strheq	r3, [r2]
			}

			/* Increment the variable we are going to post next time round.  The
			consumer will expect the numbers to	follow in numerical order. */
			++usValue;
808074bc:	e1dd30b6 	ldrh	r3, [sp, #6]
808074c0:	e2833001 	add	r3, r3, #1
808074c4:	e1cd30b6 	strh	r3, [sp, #6]
808074c8:	eaffffed 	b	80807484 <vBlockingQueueProducer+0x18>

808074cc <vBlockingQueueConsumer>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
{
808074cc:	e92d4070 	push	{r4, r5, r6, lr}
unsigned short usData, usExpectedValue = 0;
xBlockingQueueParameters *pxQueueParameters;
short sErrorEverOccurred = pdFALSE;
808074d0:	e3a06000 	mov	r6, #0
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vBlockingQueueConsumer, pvParameters )
{
808074d4:	e24dd008 	sub	sp, sp, #8
808074d8:	e1a04000 	mov	r4, r0
unsigned short usData, usExpectedValue = 0;
808074dc:	e1a05006 	mov	r5, r6

	pxQueueParameters = ( xBlockingQueueParameters * ) pvParameters;

	for( ;; )
	{	
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
808074e0:	e3a03000 	mov	r3, #0
808074e4:	e5942004 	ldr	r2, [r4, #4]
808074e8:	e28d1006 	add	r1, sp, #6
808074ec:	e5940000 	ldr	r0, [r4]
808074f0:	ebffe693 	bl	80800f44 <xQueueGenericReceive>
808074f4:	e3500001 	cmp	r0, #1
808074f8:	1afffff8 	bne	808074e0 <vBlockingQueueConsumer+0x14>
		{
			if( usData != usExpectedValue )
808074fc:	e1dd30b6 	ldrh	r3, [sp, #6]
80807500:	e1550003 	cmp	r5, r3
80807504:	11a05003 	movne	r5, r3
			{
				/* Catch-up. */
				usExpectedValue = usData;

				sErrorEverOccurred = pdTRUE;
80807508:	11a06000 	movne	r6, r0

	for( ;; )
	{	
		if( xQueueReceive( pxQueueParameters->xQueue, &usData, pxQueueParameters->xBlockTime ) == pdPASS )
		{
			if( usData != usExpectedValue )
8080750c:	1afffff3 	bne	808074e0 <vBlockingQueueConsumer+0x14>
			}
			else
			{
				/* We have successfully received a message, so increment the
				variable used to check we are still running. */	
				if( sErrorEverOccurred == pdFALSE )
80807510:	e3560000 	cmp	r6, #0
					( *pxQueueParameters->psCheckVariable )++;
				}
							
				/* Increment the value we expect to remove from the queue next time
				round. */
				++usExpectedValue;
80807514:	e2855001 	add	r5, r5, #1
80807518:	e6ff5075 	uxth	r5, r5
			}
			else
			{
				/* We have successfully received a message, so increment the
				variable used to check we are still running. */	
				if( sErrorEverOccurred == pdFALSE )
8080751c:	1affffef 	bne	808074e0 <vBlockingQueueConsumer+0x14>
				{
					( *pxQueueParameters->psCheckVariable )++;
80807520:	e5942008 	ldr	r2, [r4, #8]
80807524:	e1d230b0 	ldrh	r3, [r2]
80807528:	e2833001 	add	r3, r3, #1
8080752c:	e6ff3073 	uxth	r3, r3
80807530:	e1c230b0 	strh	r3, [r2]
80807534:	eaffffe9 	b	808074e0 <vBlockingQueueConsumer+0x14>

80807538 <vStartBlockingQueueTasks>:
static volatile short sBlockingProducerCount[ blckqNUM_TASK_SETS ] = { ( unsigned short ) 0, ( unsigned short ) 0, ( unsigned short ) 0 };

/*-----------------------------------------------------------*/

void vStartBlockingQueueTasks( unsigned portBASE_TYPE uxPriority )
{
80807538:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
8080753c:	e1a0a000 	mov	sl, r0
80807540:	e24dd00c 	sub	sp, sp, #12
	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
80807544:	e3085014 	movw	r5, #32788	; 0x8014
const portTickType xDontBlock = ( portTickType ) 0;

	/* Create the first two tasks as described at the top of the file. */
	
	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807548:	e3a0000c 	mov	r0, #12
	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
8080754c:	e3485101 	movt	r5, #33025	; 0x8101
const portTickType xDontBlock = ( portTickType ) 0;

	/* Create the first two tasks as described at the top of the file. */
	
	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807550:	ebfff89a 	bl	808057c0 <pvPortMalloc>
	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );

	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;
80807554:	e3a09ffa 	mov	r9, #1000	; 0x3e8
const portTickType xDontBlock = ( portTickType ) 0;

	/* Create the first two tasks as described at the top of the file. */
	
	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807558:	e1a07000 	mov	r7, r0

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
8080755c:	e3a02000 	mov	r2, #0
80807560:	e3a01002 	mov	r1, #2
80807564:	e3a00001 	mov	r0, #1
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
80807568:	e30764cc 	movw	r6, #29900	; 0x74cc
	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
8080756c:	ebffe36a 	bl	8080031c <xQueueGenericCreate>

	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;
80807570:	e5879004 	str	r9, [r7, #4]
	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;

	/* The producer is not going to block - as soon as it posts the consumer will
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;
80807574:	e3a04000 	mov	r4, #0
	/* First create the structure used to pass parameters to the consumer tasks. */
	pxQueueParameters1 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );

	/* Create the queue used by the first two tasks to pass the incrementing number.
	Pass a pointer to the queue in the parameter structure. */
	pxQueueParameters1->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80807578:	e5870000 	str	r0, [r7]
	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
		
	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
8080757c:	e3a0000c 	mov	r0, #12
	/* The consumer is created first so gets a block time as described above. */
	pxQueueParameters1->xBlockTime = xBlockTime;

	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
80807580:	e5875008 	str	r5, [r7, #8]
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
80807584:	e3486080 	movt	r6, #32896	; 0x8080
	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
		
	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807588:	ebfff88c 	bl	808057c0 <pvPortMalloc>

	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
8080758c:	e5972000 	ldr	r2, [r7]
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;

	/* Pass in the variable that this task is going to increment so we can check
	it is still running. */
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
80807590:	e285c008 	add	ip, r5, #8
	/* Pass in the variable that this task is going to increment so we can check it
	is still running. */
	pxQueueParameters1->psCheckVariable = &( sBlockingConsumerCount[ 0 ] );
		
	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807594:	e1a0b000 	mov	fp, r0
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
80807598:	e3091af8 	movw	r1, #39672	; 0x9af8
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;

	/* Pass in the variable that this task is going to increment so we can check
	it is still running. */
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );
8080759c:	e58bc008 	str	ip, [fp, #8]


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
808075a0:	e1a03007 	mov	r3, r7
		
	/* Create the structure used to pass parameters to the producer task. */
	pxQueueParameters2 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );

	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;
808075a4:	e58b2000 	str	r2, [fp]
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
808075a8:	e1a00006 	mov	r0, r6
	/* Pass the queue to this task also, using the parameter structure. */
	pxQueueParameters2->xQueue = pxQueueParameters1->xQueue;

	/* The producer is not going to block - as soon as it posts the consumer will
	wake and remove the item so the producer should always have room to post. */
	pxQueueParameters2->xBlockTime = xDontBlock;
808075ac:	e58b4004 	str	r4, [fp, #4]
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
808075b0:	e3481080 	movt	r1, #32896	; 0x8080
808075b4:	e58da000 	str	sl, [sp]
808075b8:	e3a02b01 	mov	r2, #1024	; 0x400
808075bc:	e58d4004 	str	r4, [sp, #4]
	xTaskCreate( vBlockingQueueProducer, (const char * const) "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
808075c0:	e307846c 	movw	r8, #29804	; 0x746c
	pxQueueParameters2->psCheckVariable = &( sBlockingProducerCount[ 0 ] );


	/* Note the producer has a lower priority than the consumer when the tasks are
	spawned. */
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB1", blckqSTACK_SIZE, ( void * ) pxQueueParameters1, uxPriority, NULL );
808075c4:	ebffe8f0 	bl	8080198c <xTaskCreate>
	xTaskCreate( vBlockingQueueProducer, (const char * const) "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );
808075c8:	e3488080 	movt	r8, #32896	; 0x8080
808075cc:	e3091b00 	movw	r1, #39680	; 0x9b00
808075d0:	e1a0300b 	mov	r3, fp
808075d4:	e3481080 	movt	r1, #32896	; 0x8080
808075d8:	e3a02b01 	mov	r2, #1024	; 0x400
808075dc:	e58d4004 	str	r4, [sp, #4]
808075e0:	e58d4000 	str	r4, [sp]
808075e4:	e1a00008 	mov	r0, r8
808075e8:	ebffe8e7 	bl	8080198c <xTaskCreate>

	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
808075ec:	e3a0000c 	mov	r0, #12
808075f0:	ebfff872 	bl	808057c0 <pvPortMalloc>
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
808075f4:	e1a02004 	mov	r2, r4
	xTaskCreate( vBlockingQueueProducer, (const char * const) "QProdB2", blckqSTACK_SIZE, ( void * ) pxQueueParameters2, tskIDLE_PRIORITY, NULL );

	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
808075f8:	e1a07000 	mov	r7, r0
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
808075fc:	e3a01002 	mov	r1, #2
80807600:	e3a00001 	mov	r0, #1
80807604:	ebffe344 	bl	8080031c <xQueueGenericCreate>
	pxQueueParameters3->xBlockTime = xDontBlock;
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
80807608:	e285300a 	add	r3, r5, #10
	/* Create the second two tasks as described at the top of the file.   This uses
	the same mechanism but reverses the task priorities. */

	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
	pxQueueParameters3->xBlockTime = xDontBlock;
8080760c:	e8870011 	stm	r7, {r0, r4}
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );
80807610:	e5873008 	str	r3, [r7, #8]

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807614:	e3a0000c 	mov	r0, #12
80807618:	ebfff868 	bl	808057c0 <pvPortMalloc>
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
8080761c:	e5972000 	ldr	r2, [r7]
	pxQueueParameters4->xBlockTime = xBlockTime;
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
80807620:	e285c002 	add	ip, r5, #2
	pxQueueParameters3 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
	pxQueueParameters3->xBlockTime = xDontBlock;
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807624:	e1a0b000 	mov	fp, r0
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
	pxQueueParameters4->xBlockTime = xBlockTime;
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );

	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QProdB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
80807628:	e3091b08 	movw	r1, #39688	; 0x9b08
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
	pxQueueParameters4->xBlockTime = xBlockTime;
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );
8080762c:	e58bc008 	str	ip, [fp, #8]

	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QProdB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
80807630:	e1a03007 	mov	r3, r7
	pxQueueParameters3->xQueue = xQueueCreate( uxQueueSize1, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
	pxQueueParameters3->xBlockTime = xDontBlock;
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
80807634:	e58b2000 	str	r2, [fp]
	pxQueueParameters4->xBlockTime = xBlockTime;
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );

	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QProdB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
80807638:	e1a00006 	mov	r0, r6
	pxQueueParameters3->xBlockTime = xDontBlock;
	pxQueueParameters3->psCheckVariable = &( sBlockingProducerCount[ 1 ] );

	pxQueueParameters4 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters4->xQueue = pxQueueParameters3->xQueue;
	pxQueueParameters4->xBlockTime = xBlockTime;
8080763c:	e58b9004 	str	r9, [fp, #4]
	pxQueueParameters4->psCheckVariable = &( sBlockingConsumerCount[ 1 ] );

	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QProdB3", blckqSTACK_SIZE, ( void * ) pxQueueParameters3, tskIDLE_PRIORITY, NULL );
80807640:	e3481080 	movt	r1, #32896	; 0x8080
80807644:	e58d4004 	str	r4, [sp, #4]
80807648:	e3a02b01 	mov	r2, #1024	; 0x400
8080764c:	e58d4000 	str	r4, [sp]
80807650:	ebffe8cd 	bl	8080198c <xTaskCreate>
	xTaskCreate( vBlockingQueueProducer, (const char * const) "QConsB4", blckqSTACK_SIZE, ( void * ) pxQueueParameters4, uxPriority, NULL );
80807654:	e3091b10 	movw	r1, #39696	; 0x9b10
80807658:	e1a0300b 	mov	r3, fp
8080765c:	e58da000 	str	sl, [sp]
80807660:	e3481080 	movt	r1, #32896	; 0x8080
80807664:	e3a02b01 	mov	r2, #1024	; 0x400
80807668:	e58d4004 	str	r4, [sp, #4]
8080766c:	e1a00008 	mov	r0, r8
80807670:	ebffe8c5 	bl	8080198c <xTaskCreate>



	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807674:	e3a0000c 	mov	r0, #12
80807678:	ebfff850 	bl	808057c0 <pvPortMalloc>
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
8080767c:	e1a02004 	mov	r2, r4



	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
80807680:	e1a07000 	mov	r7, r0
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80807684:	e3a01002 	mov	r1, #2
80807688:	e3a00005 	mov	r0, #5
8080768c:	ebffe322 	bl	8080031c <xQueueGenericCreate>
	pxQueueParameters5->xBlockTime = xBlockTime;
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
80807690:	e285300c 	add	r3, r5, #12

	/* Create the last two tasks as described above.  The mechanism is again just
	the same.  This time both parameter structures are given a block time. */
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
	pxQueueParameters5->xBlockTime = xBlockTime;
80807694:	e8870201 	stm	r7, {r0, r9}
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );
80807698:	e5873008 	str	r3, [r7, #8]

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
8080769c:	e3a0000c 	mov	r0, #12
808076a0:	ebfff846 	bl	808057c0 <pvPortMalloc>
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
808076a4:	e5972000 	ldr	r2, [r7]
	pxQueueParameters5 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
	pxQueueParameters5->xBlockTime = xBlockTime;
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
808076a8:	e1a0a000 	mov	sl, r0
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
	pxQueueParameters6->xBlockTime = xBlockTime;
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );	
808076ac:	e2855004 	add	r5, r5, #4

	xTaskCreate( vBlockingQueueProducer, (const char * const) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
808076b0:	e3091b18 	movw	r1, #39704	; 0x9b18
	pxQueueParameters5->xBlockTime = xBlockTime;
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
	pxQueueParameters6->xBlockTime = xBlockTime;
808076b4:	e58a9004 	str	r9, [sl, #4]
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );	

	xTaskCreate( vBlockingQueueProducer, (const char * const) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
808076b8:	e1a03007 	mov	r3, r7
	pxQueueParameters5->xQueue = xQueueCreate( uxQueueSize5, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
	pxQueueParameters5->xBlockTime = xBlockTime;
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
808076bc:	e58a2000 	str	r2, [sl]
	pxQueueParameters6->xBlockTime = xBlockTime;
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );	

	xTaskCreate( vBlockingQueueProducer, (const char * const) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
808076c0:	e1a00008 	mov	r0, r8
	pxQueueParameters5->psCheckVariable = &( sBlockingProducerCount[ 2 ] );

	pxQueueParameters6 = ( xBlockingQueueParameters * ) pvPortMalloc( sizeof( xBlockingQueueParameters ) );
	pxQueueParameters6->xQueue = pxQueueParameters5->xQueue;
	pxQueueParameters6->xBlockTime = xBlockTime;
	pxQueueParameters6->psCheckVariable = &( sBlockingConsumerCount[ 2 ] );	
808076c4:	e58a5008 	str	r5, [sl, #8]

	xTaskCreate( vBlockingQueueProducer, (const char * const) "QProdB5", blckqSTACK_SIZE, ( void * ) pxQueueParameters5, tskIDLE_PRIORITY, NULL );
808076c8:	e3481080 	movt	r1, #32896	; 0x8080
808076cc:	e58d4004 	str	r4, [sp, #4]
808076d0:	e3a02b01 	mov	r2, #1024	; 0x400
808076d4:	e58d4000 	str	r4, [sp]
808076d8:	ebffe8ab 	bl	8080198c <xTaskCreate>
	xTaskCreate( vBlockingQueueConsumer, (const char * const) "QConsB6", blckqSTACK_SIZE, ( void * ) pxQueueParameters6, tskIDLE_PRIORITY, NULL );
808076dc:	e3091b20 	movw	r1, #39712	; 0x9b20
808076e0:	e1a00006 	mov	r0, r6
808076e4:	e58d4004 	str	r4, [sp, #4]
808076e8:	e1a0300a 	mov	r3, sl
808076ec:	e58d4000 	str	r4, [sp]
808076f0:	e3481080 	movt	r1, #32896	; 0x8080
808076f4:	e3a02b01 	mov	r2, #1024	; 0x400
808076f8:	ebffe8a3 	bl	8080198c <xTaskCreate>
}
808076fc:	e28dd00c 	add	sp, sp, #12
80807700:	e8bd8ff0 	pop	{r4, r5, r6, r7, r8, r9, sl, fp, pc}

80807704 <xAreBlockingQueuesStillRunning>:
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
80807704:	e3083014 	movw	r3, #32788	; 0x8014
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreBlockingQueuesStillRunning( void )
{
80807708:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
8080770c:	e3483101 	movt	r3, #33025	; 0x8101
80807710:	e1d300b0 	ldrh	r0, [r3]
80807714:	e1d3e1b0 	ldrh	lr, [r3, #16]
		{
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
80807718:	e1d380b0 	ldrh	r8, [r3]
8080771c:	e1d351b8 	ldrh	r5, [r3, #24]


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
80807720:	e1d3c0b8 	ldrh	ip, [r3, #8]
80807724:	e050400e 	subs	r4, r0, lr
		{
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
80807728:	e1d360b8 	ldrh	r6, [r3, #8]
8080772c:	13a04001 	movne	r4, #1
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
80807730:	e1d320b2 	ldrh	r2, [r3, #2]
80807734:	e1d301b2 	ldrh	r0, [r3, #18]
80807738:	e15c0005 	cmp	ip, r5
8080773c:	11a0e004 	movne	lr, r4
		{
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
80807740:	e1d350b2 	ldrh	r5, [r3, #2]
80807744:	e1d341ba 	ldrh	r4, [r3, #26]
80807748:	03a0e000 	moveq	lr, #0
8080774c:	e1520000 	cmp	r2, r0


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
80807750:	e1d320ba 	ldrh	r2, [r3, #10]
80807754:	11a0c00e 	movne	ip, lr
80807758:	03a0c000 	moveq	ip, #0
		{
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
8080775c:	e1d3e0ba 	ldrh	lr, [r3, #10]
80807760:	e1520004 	cmp	r2, r4
80807764:	e1d371b4 	ldrh	r7, [r3, #20]
	Loop through each check variable to and return pdFALSE if any are found not
	to have changed since the last call. */

	for( xTasks = 0; xTasks < blckqNUM_TASK_SETS; xTasks++ )
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
80807768:	e1d320b4 	ldrh	r2, [r3, #4]
8080776c:	11a0100c 	movne	r1, ip
80807770:	03a01000 	moveq	r1, #0
		{
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
80807774:	e1d3c0b4 	ldrh	ip, [r3, #4]
80807778:	e1d341bc 	ldrh	r4, [r3, #28]


		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
8080777c:	e1d300bc 	ldrh	r0, [r3, #12]
80807780:	e1520007 	cmp	r2, r7
80807784:	11a02001 	movne	r2, r1
		{
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
80807788:	e1d310bc 	ldrh	r1, [r3, #12]
8080778c:	03a02000 	moveq	r2, #0
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
		{
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
80807790:	e1c381b0 	strh	r8, [r3, #16]
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
	}

	return xReturn;
}
80807794:	e1500004 	cmp	r0, r4

		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
		{
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
80807798:	e1c361b8 	strh	r6, [r3, #24]
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
		{
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
8080779c:	e1c351b2 	strh	r5, [r3, #18]
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
	}

	return xReturn;
}
808077a0:	11a00002 	movne	r0, r2
808077a4:	03a00000 	moveq	r0, #0

		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
		{
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
808077a8:	e1c3e1ba 	strh	lr, [r3, #26]
	{
		if( sBlockingConsumerCount[ xTasks ] == sLastBlockingConsumerCount[ xTasks ]  )
		{
			xReturn = pdFALSE;
		}
		sLastBlockingConsumerCount[ xTasks ] = sBlockingConsumerCount[ xTasks ];
808077ac:	e1c3c1b4 	strh	ip, [r3, #20]

		if( sBlockingProducerCount[ xTasks ] == sLastBlockingProducerCount[ xTasks ]  )
		{
			xReturn = pdFALSE;
		}
		sLastBlockingProducerCount[ xTasks ] = sBlockingProducerCount[ xTasks ];
808077b0:	e1c311bc 	strh	r1, [r3, #28]
	}

	return xReturn;
}
808077b4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}

808077b8 <vSecondaryBlockTimeTestTask>:
	}
}
/*-----------------------------------------------------------*/

static void vSecondaryBlockTimeTestTask( void *pvParameters )
{
808077b8:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
808077bc:	e3084034 	movw	r4, #32820	; 0x8034
808077c0:	e3484101 	movt	r4, #33025	; 0x8101
808077c4:	e24dd008 	sub	sp, sp, #8
	{
		/*********************************************************************
        Test 1 and 2

		This task does does not participate in these tests. */
		vTaskSuspend( NULL );
808077c8:	e3a08000 	mov	r8, #0
		xTimeWhenBlocking = xTaskGetTickCount();

		/* We should unblock after bktTIME_TO_BLOCK having not sent
		anything to the queue. */
		xData = 0;
		xRunIndicator = bktRUN_INDICATOR;
808077cc:	e1a07004 	mov	r7, r4
808077d0:	e3a06055 	mov	r6, #85	; 0x55
	{
		/*********************************************************************
        Test 1 and 2

		This task does does not participate in these tests. */
		vTaskSuspend( NULL );
808077d4:	e3a00000 	mov	r0, #0
808077d8:	ebffea56 	bl	80802138 <vTaskSuspend>
        Test 3

		The first thing we do is attempt to read from the queue.  It should be
		full so we block.  Note the time before we block so we can check the
		wake time is as per that expected. */
		xTimeWhenBlocking = xTaskGetTickCount();
808077dc:	ebffec6c 	bl	80802994 <xTaskGetTickCount>

		/* We should unblock after bktTIME_TO_BLOCK having not sent
		anything to the queue. */
		xData = 0;
		xRunIndicator = bktRUN_INDICATOR;
		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
808077e0:	e3a03000 	mov	r3, #0
        Test 3

		The first thing we do is attempt to read from the queue.  It should be
		full so we block.  Note the time before we block so we can check the
		wake time is as per that expected. */
		xTimeWhenBlocking = xTaskGetTickCount();
808077e4:	e1a05000 	mov	r5, r0

		/* We should unblock after bktTIME_TO_BLOCK having not sent
		anything to the queue. */
		xData = 0;
		xRunIndicator = bktRUN_INDICATOR;
		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
808077e8:	e3a020af 	mov	r2, #175	; 0xaf
808077ec:	e28d1004 	add	r1, sp, #4
808077f0:	e5940004 	ldr	r0, [r4, #4]
		wake time is as per that expected. */
		xTimeWhenBlocking = xTaskGetTickCount();

		/* We should unblock after bktTIME_TO_BLOCK having not sent
		anything to the queue. */
		xData = 0;
808077f4:	e58d8004 	str	r8, [sp, #4]
		xRunIndicator = bktRUN_INDICATOR;
808077f8:	e5846000 	str	r6, [r4]
		if( xQueueSend( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_FULL )
808077fc:	ebffe32e 	bl	808004bc <xQueueGenericSend>
80807800:	e3500000 	cmp	r0, #0
		{
			xErrorOccurred = pdTRUE;
80807804:	13a03001 	movne	r3, #1
80807808:	15873008 	strne	r3, [r7, #8]
		}

		/* How long were we inside the send function? */
		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
8080780c:	ebffec60 	bl	80802994 <xTaskGetTickCount>
80807810:	e0650000 	rsb	r0, r5, r0

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
80807814:	e35000ae 	cmp	r0, #174	; 0xae
80807818:	9a000001 	bls	80807824 <vSecondaryBlockTimeTestTask+0x6c>
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as
		soon as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
8080781c:	e35000be 	cmp	r0, #190	; 0xbe
80807820:	9a000001 	bls	8080782c <vSecondaryBlockTimeTestTask+0x74>
		{
			xErrorOccurred = pdTRUE;
80807824:	e3a03001 	mov	r3, #1
80807828:	e5843008 	str	r3, [r4, #8]
		}

		/* Suspend ready for test 3. */
		xRunIndicator = bktRUN_INDICATOR;
		vTaskSuspend( NULL );
8080782c:	e3a00000 	mov	r0, #0
		{
			xErrorOccurred = pdTRUE;
		}

		/* Suspend ready for test 3. */
		xRunIndicator = bktRUN_INDICATOR;
80807830:	e5846000 	str	r6, [r4]
		vTaskSuspend( NULL );
80807834:	ebffea3f 	bl	80802138 <vTaskSuspend>

		/*********************************************************************
        Test 4

		As per test three, but with the send and receive reversed. */
		xTimeWhenBlocking = xTaskGetTickCount();
80807838:	ebffec55 	bl	80802994 <xTaskGetTickCount>

		/* We should unblock after bktTIME_TO_BLOCK having not received
		anything on the queue. */
		xRunIndicator = bktRUN_INDICATOR;
		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
8080783c:	e3a03000 	mov	r3, #0

		/*********************************************************************
        Test 4

		As per test three, but with the send and receive reversed. */
		xTimeWhenBlocking = xTaskGetTickCount();
80807840:	e1a05000 	mov	r5, r0

		/* We should unblock after bktTIME_TO_BLOCK having not received
		anything on the queue. */
		xRunIndicator = bktRUN_INDICATOR;
		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
80807844:	e3a020af 	mov	r2, #175	; 0xaf
80807848:	e28d1004 	add	r1, sp, #4
8080784c:	e5940004 	ldr	r0, [r4, #4]
		As per test three, but with the send and receive reversed. */
		xTimeWhenBlocking = xTaskGetTickCount();

		/* We should unblock after bktTIME_TO_BLOCK having not received
		anything on the queue. */
		xRunIndicator = bktRUN_INDICATOR;
80807850:	e5846000 	str	r6, [r4]
		if( xQueueReceive( xTestQueue, &xData, bktTIME_TO_BLOCK ) != errQUEUE_EMPTY )
80807854:	ebffe5ba 	bl	80800f44 <xQueueGenericReceive>
80807858:	e3500000 	cmp	r0, #0
		{
			xErrorOccurred = pdTRUE;
8080785c:	13a03001 	movne	r3, #1
80807860:	15873008 	strne	r3, [r7, #8]
		}

		xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
80807864:	ebffec4a 	bl	80802994 <xTaskGetTickCount>
80807868:	e0650000 	rsb	r0, r5, r0

		/* We should not have blocked for less time than bktTIME_TO_BLOCK. */
		if( xBlockedTime < bktTIME_TO_BLOCK )
8080786c:	e35000ae 	cmp	r0, #174	; 0xae
80807870:	9a000001 	bls	8080787c <vSecondaryBlockTimeTestTask+0xc4>
		}

		/* We should of not blocked for much longer than bktALLOWABLE_MARGIN
		either.  A margin is permitted as we would not necessarily run as soon
		as we unblocked. */
		if( xBlockedTime > ( bktTIME_TO_BLOCK + bktALLOWABLE_MARGIN ) )
80807874:	e35000be 	cmp	r0, #190	; 0xbe
80807878:	9a000001 	bls	80807884 <vSecondaryBlockTimeTestTask+0xcc>
		{
			xErrorOccurred = pdTRUE;
8080787c:	e3a03001 	mov	r3, #1
80807880:	e5843008 	str	r3, [r4, #8]
		}

		xRunIndicator = bktRUN_INDICATOR;
80807884:	e5846000 	str	r6, [r4]

		xSecondaryCycles++;
80807888:	e594300c 	ldr	r3, [r4, #12]
8080788c:	e2833001 	add	r3, r3, #1
80807890:	e584300c 	str	r3, [r4, #12]
	}
80807894:	eaffffce 	b	808077d4 <vSecondaryBlockTimeTestTask+0x1c>

80807898 <vPrimaryBlockTimeTestTask>:
	xTaskCreate( vSecondaryBlockTimeTestTask, (const char * const)"BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
}
/*-----------------------------------------------------------*/

static void vPrimaryBlockTimeTestTask( void *pvParameters )
{
80807898:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
8080789c:	e3084034 	movw	r4, #32820	; 0x8034
808078a0:	e3484101 	movt	r4, #33025	; 0x8101
808078a4:	e24dd00c 	sub	sp, sp, #12

			xTimeWhenBlocking = xTaskGetTickCount();

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
808078a8:	e1a07004 	mov	r7, r4
808078ac:	e1a0a004 	mov	sl, r4
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
808078b0:	e3a09000 	mov	r9, #0
		{
			/* The queue is empty. Attempt to read from the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
808078b4:	e3a0800a 	mov	r8, #10

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
			{
				xErrorOccurred = pdTRUE;
808078b8:	e3a06001 	mov	r6, #1
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
808078bc:	e3a02000 	mov	r2, #0
808078c0:	e58d9000 	str	r9, [sp]
		{
			/* The queue is empty. Attempt to read from the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
808078c4:	e1a0b218 	lsl	fp, r8, r2

			xTimeWhenBlocking = xTaskGetTickCount();
808078c8:	ebffec31 	bl	80802994 <xTaskGetTickCount>

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
808078cc:	e1a0200b 	mov	r2, fp
808078d0:	e3a03000 	mov	r3, #0
		{
			/* The queue is empty. Attempt to read from the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;

			xTimeWhenBlocking = xTaskGetTickCount();
808078d4:	e1a05000 	mov	r5, r0

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueReceive( xTestQueue, &xData, xTimeToBlock ) != errQUEUE_EMPTY )
808078d8:	e28d1004 	add	r1, sp, #4
808078dc:	e5940004 	ldr	r0, [r4, #4]
808078e0:	ebffe597 	bl	80800f44 <xQueueGenericReceive>
808078e4:	e3500000 	cmp	r0, #0
			{
				xErrorOccurred = pdTRUE;
808078e8:	15876008 	strne	r6, [r7, #8]
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
808078ec:	ebffec28 	bl	80802994 <xTaskGetTickCount>
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
808078f0:	e59d2000 	ldr	r2, [sp]
			{
				xErrorOccurred = pdTRUE;
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
808078f4:	e0650000 	rsb	r0, r5, r0

			if( xBlockedTime < xTimeToBlock )
808078f8:	e15b0000 	cmp	fp, r0
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
808078fc:	e28b300f 	add	r3, fp, #15
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;

			if( xBlockedTime < xTimeToBlock )
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
80807900:	85846008 	strhi	r6, [r4, #8]
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
80807904:	e1500003 	cmp	r0, r3
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807908:	e2822001 	add	r2, r2, #1
			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
8080790c:	85846008 	strhi	r6, [r4, #8]
	{
		/*********************************************************************
        Test 1

        Simple block time wakeup test on queue receives. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807910:	e3520004 	cmp	r2, #4
80807914:	e58d2000 	str	r2, [sp]
80807918:	daffffe9 	ble	808078c4 <vPrimaryBlockTimeTestTask+0x2c>
        Test 2

        Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
8080791c:	e58d9000 	str	r9, [sp]
		{
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
80807920:	e3a03000 	mov	r3, #0
80807924:	e1a0100d 	mov	r1, sp
80807928:	e1a02003 	mov	r2, r3
8080792c:	e5940004 	ldr	r0, [r4, #4]
80807930:	ebffe2e1 	bl	808004bc <xQueueGenericSend>
        Test 2

        Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807934:	e59d3000 	ldr	r3, [sp]
		{
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
80807938:	e3500001 	cmp	r0, #1
			{
				xErrorOccurred = pdTRUE;
8080793c:	15876008 	strne	r6, [r7, #8]
        Test 2

        Simple block time wakeup test on queue sends.

		First fill the queue.  It should be empty so all sends should pass. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807940:	e2833001 	add	r3, r3, #1
80807944:	e3530004 	cmp	r3, #4
80807948:	e58d3000 	str	r3, [sp]
8080794c:	dafffff3 	ble	80807920 <vPrimaryBlockTimeTestTask+0x88>
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807950:	e3a02000 	mov	r2, #0
80807954:	e58d9000 	str	r9, [sp]
		{
			/* The queue is full. Attempt to write to the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;
80807958:	e1a0b218 	lsl	fp, r8, r2

			xTimeWhenBlocking = xTaskGetTickCount();
8080795c:	ebffec0c 	bl	80802994 <xTaskGetTickCount>

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
80807960:	e1a0200b 	mov	r2, fp
80807964:	e3a03000 	mov	r3, #0
		{
			/* The queue is full. Attempt to write to the queue using a block
			time.  When we wake, ensure the delta in time is as expected. */
			xTimeToBlock = bktPRIMARY_BLOCK_TIME << xItem;

			xTimeWhenBlocking = xTaskGetTickCount();
80807968:	e1a05000 	mov	r5, r0

			/* We should unblock after xTimeToBlock having not received
			anything on the queue. */
			if( xQueueSend( xTestQueue, &xItem, xTimeToBlock ) != errQUEUE_FULL )
8080796c:	e1a0100d 	mov	r1, sp
80807970:	e5940004 	ldr	r0, [r4, #4]
80807974:	ebffe2d0 	bl	808004bc <xQueueGenericSend>
80807978:	e3500000 	cmp	r0, #0
			{
				xErrorOccurred = pdTRUE;
8080797c:	15876008 	strne	r6, [r7, #8]
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
80807980:	ebffec03 	bl	80802994 <xTaskGetTickCount>
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807984:	e59d2000 	ldr	r2, [sp]
			{
				xErrorOccurred = pdTRUE;
			}

			/* How long were we blocked for? */
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;
80807988:	e0650000 	rsb	r0, r5, r0

			if( xBlockedTime < xTimeToBlock )
8080798c:	e15b0000 	cmp	fp, r0
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
80807990:	e28b300f 	add	r3, fp, #15
			xBlockedTime = xTaskGetTickCount() - xTimeWhenBlocking;

			if( xBlockedTime < xTimeToBlock )
			{
				/* Should not have blocked for less than we requested. */
				xErrorOccurred = pdTRUE;
80807994:	85846008 	strhi	r6, [r4, #8]
			}

			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
80807998:	e1500003 	cmp	r0, r3
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
8080799c:	e2822001 	add	r2, r2, #1
			if( xBlockedTime > ( xTimeToBlock + bktALLOWABLE_MARGIN ) )
			{
				/* Should not have blocked for longer than we requested,
				although we would not necessarily run as soon as we were
				unblocked so a margin is allowed. */
				xErrorOccurred = pdTRUE;
808079a0:	85846008 	strhi	r6, [r4, #8]
			#if configUSE_PREEMPTION == 0
				taskYIELD();
			#endif
		}

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
808079a4:	e3520004 	cmp	r2, #4
808079a8:	e58d2000 	str	r2, [sp]
808079ac:	daffffe9 	ble	80807958 <vPrimaryBlockTimeTestTask+0xc0>
		the remains of its block time.

		Wake the other task so it blocks attempting to post to the already
		full queue. */
		xRunIndicator = 0;
		vTaskResume( xSecondary );
808079b0:	e5940010 	ldr	r0, [r4, #16]
		recognise that its block time has not expired and return to block for
		the remains of its block time.

		Wake the other task so it blocks attempting to post to the already
		full queue. */
		xRunIndicator = 0;
808079b4:	e5849000 	str	r9, [r4]
		vTaskResume( xSecondary );
808079b8:	ebffeb1b 	bl	8080262c <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
808079bc:	e5943000 	ldr	r3, [r4]
808079c0:	e3530055 	cmp	r3, #85	; 0x55
808079c4:	0a00007f 	beq	80807bc8 <vPrimaryBlockTimeTestTask+0x330>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
808079c8:	e3a00014 	mov	r0, #20
808079cc:	ebffeda1 	bl	80803058 <vTaskDelay>
		full queue. */
		xRunIndicator = 0;
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
808079d0:	e5943000 	ldr	r3, [r4]
808079d4:	e3530055 	cmp	r3, #85	; 0x55
808079d8:	1afffffa 	bne	808079c8 <vPrimaryBlockTimeTestTask+0x130>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
808079dc:	e3a00014 	mov	r0, #20
808079e0:	ebffed9c 	bl	80803058 <vTaskDelay>
		xRunIndicator = 0;
808079e4:	e58a9000 	str	r9, [sl]

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
808079e8:	e58d9000 	str	r9, [sp]
		{
			/* Now when we make space on the queue the other task should wake
			but not execute as this task has higher priority. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
808079ec:	e3a03000 	mov	r3, #0
808079f0:	e28d1004 	add	r1, sp, #4
808079f4:	e1a02003 	mov	r2, r3
808079f8:	e5940004 	ldr	r0, [r4, #4]
808079fc:	ebffe550 	bl	80800f44 <xQueueGenericReceive>
			}

			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
80807a00:	e3a03000 	mov	r3, #0

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
		{
			/* Now when we make space on the queue the other task should wake
			but not execute as this task has higher priority. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
80807a04:	e3500001 	cmp	r0, #1
			}

			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
80807a08:	e1a02003 	mov	r2, r3
80807a0c:	e1a0100d 	mov	r1, sp
80807a10:	e5940004 	ldr	r0, [r4, #4]
		{
			/* Now when we make space on the queue the other task should wake
			but not execute as this task has higher priority. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
80807a14:	15876008 	strne	r6, [r7, #8]
			}

			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
80807a18:	ebffe2a7 	bl	808004bc <xQueueGenericSend>
80807a1c:	e3500001 	cmp	r0, #1
				xErrorOccurred = pdTRUE;
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
80807a20:	e3a01009 	mov	r1, #9
			/* Now fill the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			full ourselves, and the other task have set xRunIndicator. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
80807a24:	15876008 	strne	r6, [r7, #8]
			}

			if( xRunIndicator == bktRUN_INDICATOR )
80807a28:	e5943000 	ldr	r3, [r4]
				xErrorOccurred = pdTRUE;
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
80807a2c:	e5940010 	ldr	r0, [r4, #16]
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
			}

			if( xRunIndicator == bktRUN_INDICATOR )
80807a30:	e3530055 	cmp	r3, #85	; 0x55
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
80807a34:	05876008 	streq	r6, [r7, #8]
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
80807a38:	ebffe93c 	bl	80801f30 <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
80807a3c:	e5943000 	ldr	r3, [r4]
				queue function. */
				xErrorOccurred = pdTRUE;
			}

			/* Set the priority back down. */
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
80807a40:	e3a01006 	mov	r1, #6
80807a44:	e5940010 	ldr	r0, [r4, #16]
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
80807a48:	e3530055 	cmp	r3, #85	; 0x55
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
80807a4c:	05876008 	streq	r6, [r7, #8]
			}

			/* Set the priority back down. */
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
80807a50:	ebffe936 	bl	80801f30 <vTaskPrioritySet>
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807a54:	e59d3000 	ldr	r3, [sp]
80807a58:	e2833001 	add	r3, r3, #1
80807a5c:	e3530004 	cmp	r3, #4
80807a60:	e58d3000 	str	r3, [sp]
80807a64:	daffffe0 	ble	808079ec <vPrimaryBlockTimeTestTask+0x154>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
80807a68:	e59a3000 	ldr	r3, [sl]
80807a6c:	e3530055 	cmp	r3, #85	; 0x55
80807a70:	0a000004 	beq	80807a88 <vPrimaryBlockTimeTestTask+0x1f0>
		{
			vTaskDelay( bktSHORT_WAIT );
80807a74:	e3a00014 	mov	r0, #20
80807a78:	ebffed76 	bl	80803058 <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
80807a7c:	e5943000 	ldr	r3, [r4]
80807a80:	e3530055 	cmp	r3, #85	; 0x55
80807a84:	1afffffa 	bne	80807a74 <vPrimaryBlockTimeTestTask+0x1dc>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
80807a88:	e3a00014 	mov	r0, #20
80807a8c:	ebffed71 	bl	80803058 <vTaskDelay>
		xRunIndicator = 0;
80807a90:	e58a9000 	str	r9, [sl]

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807a94:	e58d9000 	str	r9, [sp]
		{
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
80807a98:	e3a03000 	mov	r3, #0
80807a9c:	e28d1004 	add	r1, sp, #4
80807aa0:	e1a02003 	mov	r2, r3
80807aa4:	e5940004 	ldr	r0, [r4, #4]
80807aa8:	ebffe525 	bl	80800f44 <xQueueGenericReceive>

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807aac:	e59d3000 	ldr	r3, [sp]
		{
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
80807ab0:	e3500001 	cmp	r0, #1
			{
				xErrorOccurred = pdTRUE;
80807ab4:	15876008 	strne	r6, [r7, #8]

		As per test 3 - but with the send and receive the other way around.
		The other task blocks attempting to read from the queue.

		Empty the queue.  We should find that it is full. */
		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807ab8:	e2833001 	add	r3, r3, #1
80807abc:	e3530004 	cmp	r3, #4
80807ac0:	e58d3000 	str	r3, [sp]
80807ac4:	dafffff3 	ble	80807a98 <vPrimaryBlockTimeTestTask+0x200>
			}
		}

		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );
80807ac8:	e5940010 	ldr	r0, [r4, #16]
80807acc:	ebffead6 	bl	8080262c <vTaskResume>

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
80807ad0:	e5943000 	ldr	r3, [r4]
80807ad4:	e3530055 	cmp	r3, #85	; 0x55
80807ad8:	0a000035 	beq	80807bb4 <vPrimaryBlockTimeTestTask+0x31c>
		{
			vTaskDelay( bktSHORT_WAIT );
80807adc:	e3a00014 	mov	r0, #20
80807ae0:	ebffed5c 	bl	80803058 <vTaskDelay>
		/* Wake the other task so it blocks attempting to read from  the
		already	empty queue. */
		vTaskResume( xSecondary );

		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
80807ae4:	e5943000 	ldr	r3, [r4]
80807ae8:	e3530055 	cmp	r3, #85	; 0x55
80807aec:	1afffffa 	bne	80807adc <vPrimaryBlockTimeTestTask+0x244>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
80807af0:	e3a00014 	mov	r0, #20
80807af4:	ebffed57 	bl	80803058 <vTaskDelay>
		xRunIndicator = 0;
80807af8:	e58a9000 	str	r9, [sl]

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807afc:	e58d9000 	str	r9, [sp]
		{
			/* Now when we place an item on the queue the other task should
			wake but not execute as this task has higher priority. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
80807b00:	e3a03000 	mov	r3, #0
80807b04:	e1a0100d 	mov	r1, sp
80807b08:	e1a02003 	mov	r2, r3
80807b0c:	e5940004 	ldr	r0, [r4, #4]
80807b10:	ebffe269 	bl	808004bc <xQueueGenericSend>
			}

			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
80807b14:	e3a03000 	mov	r3, #0

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
		{
			/* Now when we place an item on the queue the other task should
			wake but not execute as this task has higher priority. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
80807b18:	e3500001 	cmp	r0, #1
			}

			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
80807b1c:	e1a02003 	mov	r2, r3
80807b20:	e28d1004 	add	r1, sp, #4
80807b24:	e5940004 	ldr	r0, [r4, #4]
		{
			/* Now when we place an item on the queue the other task should
			wake but not execute as this task has higher priority. */
			if( xQueueSend( xTestQueue, &xItem, bktDONT_BLOCK ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
80807b28:	15876008 	strne	r6, [r7, #8]
			}

			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
80807b2c:	ebffe504 	bl	80800f44 <xQueueGenericReceive>
80807b30:	e3500001 	cmp	r0, #1
				xErrorOccurred = pdTRUE;
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
80807b34:	e3a01009 	mov	r1, #9
			/* Now empty the queue again before the other task gets a chance to
			execute.  If the other task had executed we would find the queue
			empty ourselves, and the other task would be suspended. */
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
80807b38:	15876008 	strne	r6, [r7, #8]
			}

			if( xRunIndicator == bktRUN_INDICATOR )
80807b3c:	e5943000 	ldr	r3, [r4]
				xErrorOccurred = pdTRUE;
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
80807b40:	e5940010 	ldr	r0, [r4, #16]
			if( xQueueReceive( xTestQueue, &xData, bktDONT_BLOCK ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
			}

			if( xRunIndicator == bktRUN_INDICATOR )
80807b44:	e3530055 	cmp	r3, #85	; 0x55
			{
				/* The other task should not have executed. */
				xErrorOccurred = pdTRUE;
80807b48:	05876008 	streq	r6, [r7, #8]
			}

			/* Raise the priority of the other task so it executes and blocks
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );
80807b4c:	ebffe8f7 	bl	80801f30 <vTaskPrioritySet>

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
80807b50:	e5943000 	ldr	r3, [r4]
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
			}
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
80807b54:	e3a01006 	mov	r1, #6
80807b58:	e5940010 	ldr	r0, [r4, #16]
			on the queue again. */
			vTaskPrioritySet( xSecondary, bktPRIMARY_PRIORITY + 2 );

			/* The other task should now have re-blocked without exiting the
			queue function. */
			if( xRunIndicator == bktRUN_INDICATOR )
80807b5c:	e3530055 	cmp	r3, #85	; 0x55
			{
				/* The other task should not have executed outside of the
				queue function. */
				xErrorOccurred = pdTRUE;
80807b60:	05876008 	streq	r6, [r7, #8]
			}
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
80807b64:	ebffe8f1 	bl	80801f30 <vTaskPrioritySet>
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
		xRunIndicator = 0;

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807b68:	e59d3000 	ldr	r3, [sp]
80807b6c:	e2833001 	add	r3, r3, #1
80807b70:	e3530004 	cmp	r3, #4
80807b74:	e58d3000 	str	r3, [sp]
80807b78:	daffffe0 	ble	80807b00 <vPrimaryBlockTimeTestTask+0x268>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
80807b7c:	e59a3000 	ldr	r3, [sl]
80807b80:	e3530055 	cmp	r3, #85	; 0x55
80807b84:	0a000004 	beq	80807b9c <vPrimaryBlockTimeTestTask+0x304>
		{
			vTaskDelay( bktSHORT_WAIT );
80807b88:	e3a00014 	mov	r0, #20
80807b8c:	ebffed31 	bl	80803058 <vTaskDelay>
			vTaskPrioritySet( xSecondary, bktSECONDARY_PRIORITY );
		}

		/* Let the other task timeout.  When it unblockes it will check that it
		unblocked at the correct time, then suspend itself. */
		while( xRunIndicator != bktRUN_INDICATOR )
80807b90:	e5943000 	ldr	r3, [r4]
80807b94:	e3530055 	cmp	r3, #85	; 0x55
80807b98:	1afffffa 	bne	80807b88 <vPrimaryBlockTimeTestTask+0x2f0>
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
80807b9c:	e3a00014 	mov	r0, #20
80807ba0:	ebffed2c 	bl	80803058 <vTaskDelay>

		xPrimaryCycles++;
80807ba4:	e5943014 	ldr	r3, [r4, #20]
80807ba8:	e2833001 	add	r3, r3, #1
80807bac:	e5843014 	str	r3, [r4, #20]
	}
80807bb0:	eaffff41 	b	808078bc <vPrimaryBlockTimeTestTask+0x24>
		/* We need to wait a little to ensure the other task executes. */
		while( xRunIndicator != bktRUN_INDICATOR )
		{
			vTaskDelay( bktSHORT_WAIT );
		}
		vTaskDelay( bktSHORT_WAIT );
80807bb4:	e3a00014 	mov	r0, #20
80807bb8:	ebffed26 	bl	80803058 <vTaskDelay>
		xRunIndicator = 0;
80807bbc:	e5879000 	str	r9, [r7]

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807bc0:	e58d9000 	str	r9, [sp]
80807bc4:	eaffffcd 	b	80807b00 <vPrimaryBlockTimeTestTask+0x268>
		{
			/* The other task has not yet executed. */
			vTaskDelay( bktSHORT_WAIT );
		}
		/* Make sure the other task is blocked on the queue. */
		vTaskDelay( bktSHORT_WAIT );
80807bc8:	e3a00014 	mov	r0, #20
80807bcc:	ebffed21 	bl	80803058 <vTaskDelay>
		xRunIndicator = 0;
80807bd0:	e5879000 	str	r9, [r7]

		for( xItem = 0; xItem < bktQUEUE_LENGTH; xItem++ )
80807bd4:	e58d9000 	str	r9, [sp]
80807bd8:	eaffff83 	b	808079ec <vPrimaryBlockTimeTestTask+0x154>

80807bdc <vCreateBlockTimeTasks>:
static void vSecondaryBlockTimeTestTask( void *pvParameters );

/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
80807bdc:	e92d4030 	push	{r4, r5, lr}
	/* Create the queue on which the two tasks block. */
    xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
80807be0:	e3084034 	movw	r4, #32820	; 0x8034
static void vSecondaryBlockTimeTestTask( void *pvParameters );

/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
80807be4:	e24dd00c 	sub	sp, sp, #12
	/* Create the queue on which the two tasks block. */
    xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
80807be8:	e3a02000 	mov	r2, #0
80807bec:	e3484101 	movt	r4, #33025	; 0x8101
80807bf0:	e3a01004 	mov	r1, #4
80807bf4:	e3a00005 	mov	r0, #5
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );

	/* Create the two test tasks. */
	xTaskCreate( vPrimaryBlockTimeTestTask, (const char * const)"BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
80807bf8:	e1a05002 	mov	r5, r2
/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
	/* Create the queue on which the two tasks block. */
    xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
80807bfc:	ebffe1c6 	bl	8080031c <xQueueGenericCreate>
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );

	/* Create the two test tasks. */
	xTaskCreate( vPrimaryBlockTimeTestTask, (const char * const)"BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
80807c00:	e3a02007 	mov	r2, #7
/*-----------------------------------------------------------*/

void vCreateBlockTimeTasks( void )
{
	/* Create the queue on which the two tasks block. */
    xTestQueue = xQueueCreate( bktQUEUE_LENGTH, sizeof( portBASE_TYPE ) );
80807c04:	e5840004 	str	r0, [r4, #4]
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is
	defined to be less than 1. */
	vQueueAddToRegistry( xTestQueue, ( signed char * ) "Block_Time_Queue" );

	/* Create the two test tasks. */
	xTaskCreate( vPrimaryBlockTimeTestTask, (const char * const)"BTest1", configMINIMAL_STACK_SIZE, NULL, bktPRIMARY_PRIORITY, NULL );
80807c08:	e3091b28 	movw	r1, #39720	; 0x9b28
80807c0c:	e3070898 	movw	r0, #30872	; 0x7898
80807c10:	e1a03005 	mov	r3, r5
80807c14:	e58d2000 	str	r2, [sp]
80807c18:	e58d5004 	str	r5, [sp, #4]
80807c1c:	e3481080 	movt	r1, #32896	; 0x8080
80807c20:	e3a02b01 	mov	r2, #1024	; 0x400
80807c24:	e3480080 	movt	r0, #32896	; 0x8080
80807c28:	ebffe757 	bl	8080198c <xTaskCreate>
	xTaskCreate( vSecondaryBlockTimeTestTask, (const char * const)"BTest2", configMINIMAL_STACK_SIZE, NULL, bktSECONDARY_PRIORITY, &xSecondary );
80807c2c:	e2844010 	add	r4, r4, #16
80807c30:	e3a02006 	mov	r2, #6
80807c34:	e3091b30 	movw	r1, #39728	; 0x9b30
80807c38:	e30707b8 	movw	r0, #30648	; 0x77b8
80807c3c:	e58d2000 	str	r2, [sp]
80807c40:	e1a03005 	mov	r3, r5
80807c44:	e58d4004 	str	r4, [sp, #4]
80807c48:	e3481080 	movt	r1, #32896	; 0x8080
80807c4c:	e3a02b01 	mov	r2, #1024	; 0x400
80807c50:	e3480080 	movt	r0, #32896	; 0x8080
80807c54:	ebffe74c 	bl	8080198c <xTaskCreate>
}
80807c58:	e28dd00c 	add	sp, sp, #12
80807c5c:	e8bd8030 	pop	{r4, r5, pc}

80807c60 <xAreBlockTimeTestTasksStillRunning>:
static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
portBASE_TYPE xReturn = pdPASS;

	/* Have both tasks performed at least one cycle since this function was
	last called? */
	if( xPrimaryCycles == xLastPrimaryCycleCount )
80807c60:	e3083034 	movw	r3, #32820	; 0x8034
80807c64:	e3483101 	movt	r3, #33025	; 0x8101
80807c68:	e5932014 	ldr	r2, [r3, #20]
	{
		xReturn = pdFAIL;
	}

	if( xSecondaryCycles == xLastSecondaryCycleCount )
80807c6c:	e593101c 	ldr	r1, [r3, #28]
80807c70:	e593c00c 	ldr	ip, [r3, #12]
static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
portBASE_TYPE xReturn = pdPASS;

	/* Have both tasks performed at least one cycle since this function was
	last called? */
	if( xPrimaryCycles == xLastPrimaryCycleCount )
80807c74:	e5930018 	ldr	r0, [r3, #24]
	{
		xReturn = pdFAIL;
	}

	if( xSecondaryCycles == xLastSecondaryCycleCount )
80807c78:	e15c0001 	cmp	ip, r1
	{
		xReturn = pdFAIL;
80807c7c:	03a00000 	moveq	r0, #0
	if( xPrimaryCycles == xLastPrimaryCycleCount )
	{
		xReturn = pdFAIL;
	}

	if( xSecondaryCycles == xLastSecondaryCycleCount )
80807c80:	0a000001 	beq	80807c8c <xAreBlockTimeTestTasksStillRunning+0x2c>
/*-----------------------------------------------------------*/

portBASE_TYPE xAreBlockTimeTestTasksStillRunning( void )
{
static portBASE_TYPE xLastPrimaryCycleCount = 0, xLastSecondaryCycleCount = 0;
portBASE_TYPE xReturn = pdPASS;
80807c84:	e0520000 	subs	r0, r2, r0
80807c88:	13a00001 	movne	r0, #1
	if( xSecondaryCycles == xLastSecondaryCycleCount )
	{
		xReturn = pdFAIL;
	}

	if( xErrorOccurred == pdTRUE )
80807c8c:	e593c008 	ldr	ip, [r3, #8]
	{
		xReturn = pdFAIL;
	}

	xLastSecondaryCycleCount = xSecondaryCycles;
80807c90:	e593100c 	ldr	r1, [r3, #12]
	xLastPrimaryCycleCount = xPrimaryCycles;
80807c94:	e5932014 	ldr	r2, [r3, #20]
	if( xSecondaryCycles == xLastSecondaryCycleCount )
	{
		xReturn = pdFAIL;
	}

	if( xErrorOccurred == pdTRUE )
80807c98:	e35c0001 	cmp	ip, #1

	xLastSecondaryCycleCount = xSecondaryCycles;
	xLastPrimaryCycleCount = xPrimaryCycles;

	return xReturn;
}
80807c9c:	03a00000 	moveq	r0, #0
	if( xErrorOccurred == pdTRUE )
	{
		xReturn = pdFAIL;
	}

	xLastSecondaryCycleCount = xSecondaryCycles;
80807ca0:	e583101c 	str	r1, [r3, #28]
	xLastPrimaryCycleCount = xPrimaryCycles;
80807ca4:	e5832018 	str	r2, [r3, #24]

	return xReturn;
}
80807ca8:	e12fff1e 	bx	lr

80807cac <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
80807cac:	e92d4070 	push	{r4, r5, r6, lr}
80807cb0:	e3085054 	movw	r5, #32852	; 0x8054
80807cb4:	e24dd008 	sub	sp, sp, #8
signed char cExpectedByte, cByteRxed;
portBASE_TYPE xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
80807cb8:	e3a06000 	mov	r6, #0
80807cbc:	e3485101 	movt	r5, #33025	; 0x8101

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
80807cc0:	e3a04041 	mov	r4, #65	; 0x41
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
80807cc4:	e30f2fff 	movw	r2, #65535	; 0xffff
80807cc8:	e28d1007 	add	r1, sp, #7
80807ccc:	e5950000 	ldr	r0, [r5]
80807cd0:	ebfffda8 	bl	80807378 <xSerialGetChar>
80807cd4:	e3500000 	cmp	r0, #0
80807cd8:	e2842001 	add	r2, r4, #1
80807cdc:	e6ef3072 	uxtb	r3, r2
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
80807ce0:	e6af4074 	sxtb	r4, r4
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
80807ce4:	0a000002 	beq	80807cf4 <vComRxTask+0x48>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
80807ce8:	e1dd20d7 	ldrsb	r2, [sp, #7]
80807cec:	e1540002 	cmp	r4, r2
80807cf0:	1a000007 	bne	80807d14 <vComRxTask+0x68>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
80807cf4:	e3530059 	cmp	r3, #89	; 0x59
80807cf8:	e6ef4073 	uxtb	r4, r3
80807cfc:	1afffff0 	bne	80807cc4 <vComRxTask+0x18>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
80807d00:	e3560001 	cmp	r6, #1
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
80807d04:	d5953004 	ldrle	r3, [r5, #4]
80807d08:	d2833001 	addle	r3, r3, #1
80807d0c:	d5853004 	strle	r3, [r5, #4]
80807d10:	eaffffea 	b	80807cc0 <vComRxTask+0x14>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
80807d14:	e3520058 	cmp	r2, #88	; 0x58
80807d18:	0a000006 	beq	80807d38 <vComRxTask+0x8c>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
80807d1c:	e30f2fff 	movw	r2, #65535	; 0xffff
80807d20:	e28d1007 	add	r1, sp, #7
80807d24:	e5950000 	ldr	r0, [r5]
80807d28:	ebfffd92 	bl	80807378 <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
80807d2c:	e1dd30d7 	ldrsb	r3, [sp, #7]
80807d30:	e3530058 	cmp	r3, #88	; 0x58
80807d34:	1afffff8 	bne	80807d1c <vComRxTask+0x70>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
80807d38:	e2866001 	add	r6, r6, #1
80807d3c:	eaffffdf 	b	80807cc0 <vComRxTask+0x14>

80807d40 <vComTxTask>:
	xTaskCreate( vComRxTask, (const char * const) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
80807d40:	e92d4070 	push	{r4, r5, r6, lr}
80807d44:	e3085054 	movw	r5, #32852	; 0x8054
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
80807d48:	e30861b5 	movw	r6, #33205	; 0x81b5
80807d4c:	e3485101 	movt	r5, #33025	; 0x8101
80807d50:	e3416b4e 	movt	r6, #6990	; 0x1b4e

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
80807d54:	e3a04041 	mov	r4, #65	; 0x41
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
80807d58:	e6af1074 	sxtb	r1, r4
80807d5c:	e2844001 	add	r4, r4, #1
80807d60:	e6ef4074 	uxtb	r4, r4
80807d64:	e3a02000 	mov	r2, #0
80807d68:	e5950000 	ldr	r0, [r5]
80807d6c:	ebfffd82 	bl	8080737c <xSerialPutChar>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
80807d70:	e3540059 	cmp	r4, #89	; 0x59
80807d74:	e6ef4074 	uxtb	r4, r4
80807d78:	1afffff6 	bne	80807d58 <vComTxTask+0x18>
//		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
80807d7c:	ebffeb04 	bl	80802994 <xTaskGetTickCount>
80807d80:	e2800003 	add	r0, r0, #3

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
80807d84:	e0832690 	umull	r2, r3, r0, r6
80807d88:	e1a03223 	lsr	r3, r3, #4
80807d8c:	e1a02183 	lsl	r2, r3, #3
80807d90:	e0823083 	add	r3, r2, r3, lsl #1
80807d94:	e0633203 	rsb	r3, r3, r3, lsl #4
80807d98:	e0633000 	rsb	r3, r3, r0

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
80807d9c:	e3530031 	cmp	r3, #49	; 0x31
		}

		vTaskDelay( xTimeToWait );
80807da0:	81a00003 	movhi	r0, r3
80807da4:	93a00032 	movls	r0, #50	; 0x32
80807da8:	ebffecaa 	bl	80803058 <vTaskDelay>
	}
80807dac:	eaffffe8 	b	80807d54 <vComTxTask+0x14>

80807db0 <vAltStartComTestTasks>:
static volatile unsigned portBASE_TYPE uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
80807db0:	e1a03001 	mov	r3, r1
80807db4:	e92d4030 	push	{r4, r5, lr}
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
	xPort = xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
80807db8:	e3a01018 	mov	r1, #24
static volatile unsigned portBASE_TYPE uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
80807dbc:	e24dd00c 	sub	sp, sp, #12
80807dc0:	e1a05000 	mov	r5, r0
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
	xPort = xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
80807dc4:	e1a00003 	mov	r0, r3
80807dc8:	ebfffd53 	bl	8080731c <xSerialPortInitMinimal>
80807dcc:	e3083054 	movw	r3, #32852	; 0x8054

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, (const char * const) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHandle * ) NULL );
80807dd0:	e3a04000 	mov	r4, #0

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
	xPort = xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
80807dd4:	e3483101 	movt	r3, #33025	; 0x8101

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, (const char * const) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHandle * ) NULL );
80807dd8:	e2452001 	sub	r2, r5, #1

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
	xPort = xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
80807ddc:	e5830000 	str	r0, [r3]

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, (const char * const) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHandle * ) NULL );
80807de0:	e3091b38 	movw	r1, #39736	; 0x9b38
80807de4:	e3070d40 	movw	r0, #32064	; 0x7d40
80807de8:	e88d0014 	stm	sp, {r2, r4}
80807dec:	e1a03004 	mov	r3, r4
80807df0:	e3481080 	movt	r1, #32896	; 0x8080
80807df4:	e3a02b01 	mov	r2, #1024	; 0x400
80807df8:	e3480080 	movt	r0, #32896	; 0x8080
80807dfc:	ebffe6e2 	bl	8080198c <xTaskCreate>
	xTaskCreate( vComRxTask, (const char * const) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
80807e00:	e3091b40 	movw	r1, #39744	; 0x9b40
80807e04:	e3070cac 	movw	r0, #31916	; 0x7cac
80807e08:	e58d4004 	str	r4, [sp, #4]
80807e0c:	e1a03004 	mov	r3, r4
80807e10:	e58d5000 	str	r5, [sp]
80807e14:	e3481080 	movt	r1, #32896	; 0x8080
80807e18:	e3a02b01 	mov	r2, #1024	; 0x400
80807e1c:	e3480080 	movt	r0, #32896	; 0x8080
80807e20:	ebffe6d9 	bl	8080198c <xTaskCreate>
}
80807e24:	e28dd00c 	add	sp, sp, #12
80807e28:	e8bd8030 	pop	{r4, r5, pc}

80807e2c <xAreComTestTasksStillRunning>:
portBASE_TYPE xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
80807e2c:	e3083054 	movw	r3, #32852	; 0x8054
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
80807e30:	e3a02000 	mov	r2, #0
portBASE_TYPE xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
80807e34:	e3483101 	movt	r3, #33025	; 0x8101
80807e38:	e5930004 	ldr	r0, [r3, #4]
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
80807e3c:	e5832004 	str	r2, [r3, #4]

	return xReturn;
}
80807e40:	e0500002 	subs	r0, r0, r2
80807e44:	13a00001 	movne	r0, #1
80807e48:	e12fff1e 	bx	lr

80807e4c <prvCountingSemaphoreTask>:
	/* The semaphore to be used was passed as the parameter. */
	pxParameter = ( xCountSemStruct * ) pvParameters;

	/* Did we expect to find the semaphore already at its max count value, or
	at zero? */
	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
80807e4c:	e5903004 	ldr	r3, [r0, #4]
	}
}
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
80807e50:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
80807e54:	e1a04000 	mov	r4, r0
	/* The semaphore to be used was passed as the parameter. */
	pxParameter = ( xCountSemStruct * ) pvParameters;

	/* Did we expect to find the semaphore already at its max count value, or
	at zero? */
	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
80807e58:	e35300aa 	cmp	r3, #170	; 0xaa
80807e5c:	0a000042 	beq	80807f6c <prvCountingSemaphoreTask+0x120>
80807e60:	e308605c 	movw	r6, #32860	; 0x805c
80807e64:	e3486101 	movt	r6, #33025	; 0x8101
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
	}

	/* Now we expect the semaphore count to be 0, so this time there is an
	error if we can take the semaphore. */
	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
80807e68:	e3a03000 	mov	r3, #0
80807e6c:	e5940000 	ldr	r0, [r4]
80807e70:	e1a02003 	mov	r2, r3
80807e74:	e1a01003 	mov	r1, r3
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreGive( xSemaphore ) != pdPASS )
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
80807e78:	e3a07001 	mov	r7, #1
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
	}

	/* Now we expect the semaphore count to be 0, so this time there is an
	error if we can take the semaphore. */
	if( xSemaphoreTake( pxParameter->xSemaphore, 0 ) == pdPASS )
80807e7c:	ebffe430 	bl	80800f44 <xQueueGenericReceive>
80807e80:	e3500001 	cmp	r0, #1
	{
		xErrorDetected = pdTRUE;
80807e84:	05860000 	streq	r0, [r6]
	}

	for( ;; )
	{
		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
80807e88:	e5948000 	ldr	r8, [r4]
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
80807e8c:	e3a03000 	mov	r3, #0
80807e90:	e1a02003 	mov	r2, r3
80807e94:	e1a01003 	mov	r1, r3
	}
}
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
80807e98:	e3a050c8 	mov	r5, #200	; 0xc8
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
80807e9c:	e1a00008 	mov	r0, r8
80807ea0:	ebffe427 	bl	80800f44 <xQueueGenericReceive>
80807ea4:	e3500001 	cmp	r0, #1
	{
		xErrorDetected = pdTRUE;
80807ea8:	05860000 	streq	r0, [r6]
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreGive( xSemaphore ) != pdPASS )
80807eac:	e3a03000 	mov	r3, #0
80807eb0:	e1a00008 	mov	r0, r8
80807eb4:	e1a02003 	mov	r2, r3
80807eb8:	e1a01003 	mov	r1, r3
80807ebc:	ebffe17e 	bl	808004bc <xQueueGenericSend>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
		}

		( *puxLoopCounter )++;
80807ec0:	e5943008 	ldr	r3, [r4, #8]
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreGive( xSemaphore ) != pdPASS )
80807ec4:	e3500001 	cmp	r0, #1
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
80807ec8:	15867000 	strne	r7, [r6]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
80807ecc:	e2555001 	subs	r5, r5, #1
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
		}

		( *puxLoopCounter )++;
80807ed0:	e2833001 	add	r3, r3, #1
80807ed4:	e5843008 	str	r3, [r4, #8]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'give' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
80807ed8:	1afffff3 	bne	80807eac <prvCountingSemaphoreTask+0x60>
		taskYIELD();
	#endif

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807edc:	e1a03005 	mov	r3, r5
80807ee0:	e1a02005 	mov	r2, r5
80807ee4:	e1a01005 	mov	r1, r5
80807ee8:	e1a00008 	mov	r0, r8
80807eec:	ebffe172 	bl	808004bc <xQueueGenericSend>
	}

	for( ;; )
	{
		prvIncrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
80807ef0:	e5948000 	ldr	r8, [r4]
		taskYIELD();
	#endif

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807ef4:	e3500001 	cmp	r0, #1
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807ef8:	e3a03000 	mov	r3, #0

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
	{
		xErrorDetected = pdTRUE;
80807efc:	05860000 	streq	r0, [r6]
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807f00:	e1a02003 	mov	r2, r3
80807f04:	e1a01003 	mov	r1, r3
80807f08:	e1a00008 	mov	r0, r8
	}
}
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
80807f0c:	e3a050c8 	mov	r5, #200	; 0xc8
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807f10:	ebffe169 	bl	808004bc <xQueueGenericSend>
80807f14:	e3500001 	cmp	r0, #1
	{
		xErrorDetected = pdTRUE;
80807f18:	05860000 	streq	r0, [r6]
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
80807f1c:	e3a03000 	mov	r3, #0
80807f20:	e1a00008 	mov	r0, r8
80807f24:	e1a02003 	mov	r2, r3
80807f28:	e1a01003 	mov	r1, r3
80807f2c:	ebffe404 	bl	80800f44 <xQueueGenericReceive>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
		}

		( *puxLoopCounter )++;
80807f30:	e5943008 	ldr	r3, [r4, #8]
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
80807f34:	e3500001 	cmp	r0, #1
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
80807f38:	15867000 	strne	r7, [r6]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
80807f3c:	e2555001 	subs	r5, r5, #1
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
		}

		( *puxLoopCounter )++;
80807f40:	e2833001 	add	r3, r3, #1
80807f44:	e5843008 	str	r3, [r4, #8]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
80807f48:	1afffff3 	bne	80807f1c <prvCountingSemaphoreTask+0xd0>
		taskYIELD();
	#endif

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
80807f4c:	e1a00008 	mov	r0, r8
80807f50:	e1a03005 	mov	r3, r5
80807f54:	e1a02005 	mov	r2, r5
80807f58:	e1a01005 	mov	r1, r5
80807f5c:	ebffe3f8 	bl	80800f44 <xQueueGenericReceive>
80807f60:	e3500001 	cmp	r0, #1
	{
		xErrorDetected = pdTRUE;
80807f64:	05860000 	streq	r0, [r6]
80807f68:	eaffffc6 	b	80807e88 <prvCountingSemaphoreTask+0x3c>

	/* Did we expect to find the semaphore already at its max count value, or
	at zero? */
	if( pxParameter->uxExpectedStartCount == countSTART_AT_MAX_COUNT )
	{
		prvDecrementSemaphoreCount( pxParameter->xSemaphore, &( pxParameter->uxLoopCounter ) );
80807f6c:	e5907000 	ldr	r7, [r0]
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807f70:	e3a03000 	mov	r3, #0
80807f74:	e1a02003 	mov	r2, r3
80807f78:	e1a01003 	mov	r1, r3
	{
		xErrorDetected = pdTRUE;
80807f7c:	e308605c 	movw	r6, #32860	; 0x805c
	}
}
/*-----------------------------------------------------------*/

static void prvCountingSemaphoreTask( void *pvParameters )
{
80807f80:	e3a050c8 	mov	r5, #200	; 0xc8
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807f84:	e1a00007 	mov	r0, r7
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
80807f88:	e3a08001 	mov	r8, #1
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807f8c:	ebffe14a 	bl	808004bc <xQueueGenericSend>
	{
		xErrorDetected = pdTRUE;
80807f90:	e3486101 	movt	r6, #33025	; 0x8101
{
unsigned portBASE_TYPE ux;

	/* If the semaphore count is at its maximum then we should not be able to
	'give' the semaphore. */
	if( xSemaphoreGive( xSemaphore ) == pdPASS )
80807f94:	e3500001 	cmp	r0, #1
	{
		xErrorDetected = pdTRUE;
80807f98:	05860000 	streq	r0, [r6]
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
80807f9c:	e3a03000 	mov	r3, #0
80807fa0:	e1a00007 	mov	r0, r7
80807fa4:	e1a02003 	mov	r2, r3
80807fa8:	e1a01003 	mov	r1, r3
80807fac:	ebffe3e4 	bl	80800f44 <xQueueGenericReceive>
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
		}

		( *puxLoopCounter )++;
80807fb0:	e5943008 	ldr	r3, [r4, #8]
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
	{
		if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) != pdPASS )
80807fb4:	e3500001 	cmp	r0, #1
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
80807fb8:	15868000 	strne	r8, [r6]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
80807fbc:	e2555001 	subs	r5, r5, #1
		{
			/* We expected to be able to take the semaphore. */
			xErrorDetected = pdTRUE;
		}

		( *puxLoopCounter )++;
80807fc0:	e2833001 	add	r3, r3, #1
80807fc4:	e5843008 	str	r3, [r4, #8]
	{
		xErrorDetected = pdTRUE;
	}

	/* We should be able to 'take' the semaphore countMAX_COUNT_VALUE times. */
	for( ux = 0; ux < countMAX_COUNT_VALUE; ux++ )
80807fc8:	1afffff3 	bne	80807f9c <prvCountingSemaphoreTask+0x150>
		taskYIELD();
	#endif

	/* If the semaphore count is zero then we should not be able to	'take' 
	the semaphore. */
	if( xSemaphoreTake( xSemaphore, countDONT_BLOCK ) == pdPASS )
80807fcc:	e1a00007 	mov	r0, r7
80807fd0:	e1a03005 	mov	r3, r5
80807fd4:	e1a02005 	mov	r2, r5
80807fd8:	e1a01005 	mov	r1, r5
80807fdc:	ebffe3d8 	bl	80800f44 <xQueueGenericReceive>
80807fe0:	e3500001 	cmp	r0, #1
	{
		xErrorDetected = pdTRUE;
80807fe4:	05860000 	streq	r0, [r6]
80807fe8:	eaffff9e 	b	80807e68 <prvCountingSemaphoreTask+0x1c>

80807fec <vStartCountingSemaphoreTasks>:
void vStartCountingSemaphoreTasks( void )
{
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
80807fec:	e3a010c8 	mov	r1, #200	; 0xc8
static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];

/*-----------------------------------------------------------*/

void vStartCountingSemaphoreTasks( void )
{
80807ff0:	e92d4030 	push	{r4, r5, lr}
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
80807ff4:	e1a00001 	mov	r0, r1
static volatile xCountSemStruct xParameters[ countNUM_TEST_TASKS ];

/*-----------------------------------------------------------*/

void vStartCountingSemaphoreTasks( void )
{
80807ff8:	e24dd00c 	sub	sp, sp, #12
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
80807ffc:	e308405c 	movw	r4, #32860	; 0x805c
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
	xParameters[ 0 ].uxLoopCounter = 0;
80808000:	e3a05000 	mov	r5, #0
void vStartCountingSemaphoreTasks( void )
{
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
80808004:	ebffe0f1 	bl	808003d0 <xQueueCreateCountingSemaphore>
80808008:	e3484101 	movt	r4, #33025	; 0x8101
8080800c:	e1a02000 	mov	r2, r0
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
80808010:	e3a030aa 	mov	r3, #170	; 0xaa
void vStartCountingSemaphoreTasks( void )
{
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
80808014:	e5842004 	str	r2, [r4, #4]
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
	xParameters[ 0 ].uxLoopCounter = 0;

	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
80808018:	e3a000c8 	mov	r0, #200	; 0xc8
{
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
8080801c:	e5843008 	str	r3, [r4, #8]
	xParameters[ 0 ].uxLoopCounter = 0;

	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
80808020:	e1a01005 	mov	r1, r5
	/* Create the semaphores that we are going to use for the test/demo.  The
	first should be created such that it starts at its maximum count value,
	the second should be created such that it starts with a count value of zero. */
	xParameters[ 0 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, countMAX_COUNT_VALUE );
	xParameters[ 0 ].uxExpectedStartCount = countSTART_AT_MAX_COUNT;
	xParameters[ 0 ].uxLoopCounter = 0;
80808024:	e584500c 	str	r5, [r4, #12]

	xParameters[ 1 ].xSemaphore = xSemaphoreCreateCounting( countMAX_COUNT_VALUE, 0 );
80808028:	ebffe0e8 	bl	808003d0 <xQueueCreateCountingSemaphore>
8080802c:	e5840010 	str	r0, [r4, #16]
	xParameters[ 1 ].uxExpectedStartCount = 0;
80808030:	e5845014 	str	r5, [r4, #20]
	xParameters[ 1 ].uxLoopCounter = 0;
80808034:	e5845018 	str	r5, [r4, #24]
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 0 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_1" );
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 1 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_2" );


	/* Were the semaphores created? */
	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
80808038:	e5943004 	ldr	r3, [r4, #4]
8080803c:	e1530005 	cmp	r3, r5
80808040:	0a000016 	beq	808080a0 <vStartCountingSemaphoreTasks+0xb4>
	{
		/* Create the demo tasks, passing in the semaphore to use as the parameter. */
		xTaskCreate( prvCountingSemaphoreTask, ( const char * const) "CNT1", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 0 ] ), tskIDLE_PRIORITY, NULL );
80808044:	e3a04000 	mov	r4, #0
80808048:	e3091b48 	movw	r1, #39752	; 0x9b48
8080804c:	e3070e4c 	movw	r0, #32332	; 0x7e4c
80808050:	e3083060 	movw	r3, #32864	; 0x8060
80808054:	e3481080 	movt	r1, #32896	; 0x8080
80808058:	e3483101 	movt	r3, #33025	; 0x8101
8080805c:	e3a02b01 	mov	r2, #1024	; 0x400
80808060:	e58d4004 	str	r4, [sp, #4]
80808064:	e58d4000 	str	r4, [sp]
80808068:	e3480080 	movt	r0, #32896	; 0x8080
8080806c:	ebffe646 	bl	8080198c <xTaskCreate>
		xTaskCreate( prvCountingSemaphoreTask, ( const char * const ) "CNT2", configMINIMAL_STACK_SIZE, ( void * ) &( xParameters[ 1 ] ), tskIDLE_PRIORITY, NULL );
80808070:	e3091b50 	movw	r1, #39760	; 0x9b50
80808074:	e3070e4c 	movw	r0, #32332	; 0x7e4c
80808078:	e308306c 	movw	r3, #32876	; 0x806c
8080807c:	e58d4004 	str	r4, [sp, #4]
80808080:	e3481080 	movt	r1, #32896	; 0x8080
80808084:	e58d4000 	str	r4, [sp]
80808088:	e3480080 	movt	r0, #32896	; 0x8080
8080808c:	e3483101 	movt	r3, #33025	; 0x8101
80808090:	e3a02b01 	mov	r2, #1024	; 0x400
80808094:	ebffe63c 	bl	8080198c <xTaskCreate>
	}
}
80808098:	e28dd00c 	add	sp, sp, #12
8080809c:	e8bd8030 	pop	{r4, r5, pc}
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 0 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_1" );
	vQueueAddToRegistry( ( xQueueHandle ) xParameters[ 1 ].xSemaphore, ( signed portCHAR * ) "Counting_Sem_2" );


	/* Were the semaphores created? */
	if( ( xParameters[ 0 ].xSemaphore != NULL ) || ( xParameters[ 1 ].xSemaphore != NULL ) )
808080a0:	e5943010 	ldr	r3, [r4, #16]
808080a4:	e1530005 	cmp	r3, r5
808080a8:	1affffe5 	bne	80808044 <vStartCountingSemaphoreTasks+0x58>
808080ac:	eafffff9 	b	80808098 <vStartCountingSemaphoreTasks+0xac>

808080b0 <xAreCountingSemaphoreTasksStillRunning>:
static unsigned portBASE_TYPE uxLastCount0 = 0, uxLastCount1 = 0;
portBASE_TYPE xReturn = pdPASS;

	/* Return fail if any 'give' or 'take' did not result in the expected
	behaviour. */
	if( xErrorDetected != pdFALSE )
808080b0:	e308305c 	movw	r3, #32860	; 0x805c
808080b4:	e3483101 	movt	r3, #33025	; 0x8101
808080b8:	e5930000 	ldr	r0, [r3]
	{
		xReturn = pdFAIL;
	}

	/* Return fail if either task is not still incrementing its loop counter. */
	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
808080bc:	e593201c 	ldr	r2, [r3, #28]
808080c0:	e593100c 	ldr	r1, [r3, #12]
808080c4:	e1510002 	cmp	r1, r2
	{
		xReturn = pdFAIL;
	}
	else
	{
		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
808080c8:	1593200c 	ldrne	r2, [r3, #12]
/*-----------------------------------------------------------*/

portBASE_TYPE xAreCountingSemaphoreTasksStillRunning( void )
{
static unsigned portBASE_TYPE uxLastCount0 = 0, uxLastCount1 = 0;
portBASE_TYPE xReturn = pdPASS;
808080cc:	116f0f10 	clzne	r0, r0
	else
	{
		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
	}

	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
808080d0:	e5931018 	ldr	r1, [r3, #24]
	}

	/* Return fail if either task is not still incrementing its loop counter. */
	if( uxLastCount0 == xParameters[ 0 ].uxLoopCounter )
	{
		xReturn = pdFAIL;
808080d4:	03a00000 	moveq	r0, #0
/*-----------------------------------------------------------*/

portBASE_TYPE xAreCountingSemaphoreTasksStillRunning( void )
{
static unsigned portBASE_TYPE uxLastCount0 = 0, uxLastCount1 = 0;
portBASE_TYPE xReturn = pdPASS;
808080d8:	11a002a0 	lsrne	r0, r0, #5
	{
		xReturn = pdFAIL;
	}
	else
	{
		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
808080dc:	1583201c 	strne	r2, [r3, #28]
	}

	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
808080e0:	e308205c 	movw	r2, #32860	; 0x805c
808080e4:	e5933020 	ldr	r3, [r3, #32]
808080e8:	e3482101 	movt	r2, #33025	; 0x8101
808080ec:	e1510003 	cmp	r1, r3
	{
		xReturn = pdFAIL;
	}
	else
	{
		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
808080f0:	15923018 	ldrne	r3, [r2, #24]
		uxLastCount0 = xParameters[ 0 ].uxLoopCounter;
	}

	if( uxLastCount1 == xParameters[ 1 ].uxLoopCounter )
	{
		xReturn = pdFAIL;
808080f4:	03a00000 	moveq	r0, #0
	}
	else
	{
		uxLastCount1 = xParameters[ 1 ].uxLoopCounter;
808080f8:	15823020 	strne	r3, [r2, #32]
	}

	return xReturn;
}
808080fc:	e12fff1e 	bx	lr

80808100 <vQueueReceiveWhenSuspendedTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueReceiveWhenSuspendedTask, pvParameters )
{
80808100:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
80808104:	e3088080 	movw	r8, #32896	; 0x8080
80808108:	e3085124 	movw	r5, #33060	; 0x8124
8080810c:	e3488101 	movt	r8, #33025	; 0x8101
80808110:	e3485101 	movt	r5, #33025	; 0x8101
			outer call. */
			vTaskSuspendAll();
			{
				vTaskSuspendAll();
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
80808114:	e1a07008 	mov	r7, r8
				}
				if( xTaskResumeAll() )
				{
					xSuspendedQueueReceiveError = pdTRUE;
80808118:	e3a06001 	mov	r6, #1
			/* Suspending the scheduler here is fairly pointless and 
			undesirable for a normal application.  It is done here purely
			to test the scheduler.  The inner xTaskResumeAll() should
			never return pdTRUE as the scheduler is still locked by the
			outer call. */
			vTaskSuspendAll();
8080811c:	ebffea16 	bl	8080297c <vTaskSuspendAll>
			{
				vTaskSuspendAll();
80808120:	ebffea15 	bl	8080297c <vTaskSuspendAll>
				{
					xGotValue = xQueueReceive( xSuspendedTestQueue, ( void * ) &ulReceivedValue, priNO_BLOCK );
80808124:	e3a03000 	mov	r3, #0
80808128:	e3081080 	movw	r1, #32896	; 0x8080
8080812c:	e1a02003 	mov	r2, r3
80808130:	e3481101 	movt	r1, #33025	; 0x8101
80808134:	e5950000 	ldr	r0, [r5]
80808138:	ebffe381 	bl	80800f44 <xQueueGenericReceive>
8080813c:	e1a04000 	mov	r4, r0
				}
				if( xTaskResumeAll() )
80808140:	ebffeab5 	bl	80802c1c <xTaskResumeAll>
80808144:	e3500000 	cmp	r0, #0
				{
					xSuspendedQueueReceiveError = pdTRUE;
80808148:	15876004 	strne	r6, [r7, #4]
				}
			}
			xTaskResumeAll();
8080814c:	ebffeab2 	bl	80802c1c <xTaskResumeAll>
			{
				taskYIELD();
			}
			#endif

		} while( xGotValue == pdFALSE );
80808150:	e3540000 	cmp	r4, #0
80808154:	0afffff0 	beq	8080811c <vQueueReceiveWhenSuspendedTask+0x1c>

		if( ulReceivedValue != ulExpectedValue )
80808158:	e5983008 	ldr	r3, [r8, #8]
8080815c:	e5982000 	ldr	r2, [r8]
80808160:	e1520003 	cmp	r2, r3
		{
			xSuspendedQueueReceiveError = pdTRUE;
		}

		++ulExpectedValue;
80808164:	e2833001 	add	r3, r3, #1

		} while( xGotValue == pdFALSE );

		if( ulReceivedValue != ulExpectedValue )
		{
			xSuspendedQueueReceiveError = pdTRUE;
80808168:	13a02001 	movne	r2, #1
		}

		++ulExpectedValue;
8080816c:	e5883008 	str	r3, [r8, #8]

		} while( xGotValue == pdFALSE );

		if( ulReceivedValue != ulExpectedValue )
		{
			xSuspendedQueueReceiveError = pdTRUE;
80808170:	15872004 	strne	r2, [r7, #4]
		}

		++ulExpectedValue;
	}
80808174:	eaffffe7 	b	80808118 <vQueueReceiveWhenSuspendedTask+0x18>

80808178 <vQueueSendWhenSuspendedTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vQueueSendWhenSuspendedTask, pvParameters )
{
80808178:	e92d4010 	push	{r4, lr}
8080817c:	e3084080 	movw	r4, #32896	; 0x8080
80808180:	e3085124 	movw	r5, #33060	; 0x8124
80808184:	e3484101 	movt	r4, #33025	; 0x8101
80808188:	e3485101 	movt	r5, #33025	; 0x8101
	for( ;; )
	{
		vTaskSuspendAll();
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
8080818c:	e1a06004 	mov	r6, r4
	/* Just to stop warning messages. */
	( void ) pvParameters;

	for( ;; )
	{
		vTaskSuspendAll();
80808190:	ebffe9f9 	bl	8080297c <vTaskSuspendAll>
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
80808194:	e3a03000 	mov	r3, #0
80808198:	e308108c 	movw	r1, #32908	; 0x808c
8080819c:	e1a02003 	mov	r2, r3
808081a0:	e3481101 	movt	r1, #33025	; 0x8101
808081a4:	e5950000 	ldr	r0, [r5]
808081a8:	ebffe0c3 	bl	808004bc <xQueueGenericSend>
			{
				xSuspendedQueueSendError = pdTRUE;
808081ac:	e3a03001 	mov	r3, #1
	for( ;; )
	{
		vTaskSuspendAll();
		{
			/* We must not block while the scheduler is suspended! */
			if( xQueueSend( xSuspendedTestQueue, ( void * ) &ulValueToSend, priNO_BLOCK ) != pdTRUE )
808081b0:	e3500001 	cmp	r0, #1
			{
				xSuspendedQueueSendError = pdTRUE;
808081b4:	15863010 	strne	r3, [r6, #16]
			}
		}
		xTaskResumeAll();
808081b8:	ebffea97 	bl	80802c1c <xTaskResumeAll>

		vTaskDelay( priSLEEP_TIME );
808081bc:	e3a00080 	mov	r0, #128	; 0x80
808081c0:	ebffeba4 	bl	80803058 <vTaskDelay>

		++ulValueToSend;
808081c4:	e594300c 	ldr	r3, [r4, #12]
808081c8:	e2833001 	add	r3, r3, #1
808081cc:	e584300c 	str	r3, [r4, #12]
	}
808081d0:	eaffffee 	b	80808190 <vQueueSendWhenSuspendedTask+0x18>

808081d4 <vLimitedIncrementTask>:
/*
 * Just loops around incrementing the shared variable until the limit has been
 * reached.  Once the limit has been reached it suspends itself. 
 */
static portTASK_FUNCTION( vLimitedIncrementTask, pvParameters )
{
808081d4:	e92d4010 	push	{r4, lr}
808081d8:	e1a04000 	mov	r4, r0
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;

	/* This will run before the control task, so the first thing it does is
	suspend - the control task will resume it when ready. */
	vTaskSuspend( NULL );
808081dc:	e3a00000 	mov	r0, #0
808081e0:	ebffe7d4 	bl	80802138 <vTaskSuspend>
808081e4:	e5943000 	ldr	r3, [r4]

	for( ;; )
	{
		/* Just count up to a value then suspend. */
		( *pulCounter )++;	
808081e8:	e2833001 	add	r3, r3, #1
		
		if( *pulCounter >= priMAX_COUNT )
808081ec:	e35300fe 	cmp	r3, #254	; 0xfe
808081f0:	9afffffc 	bls	808081e8 <vLimitedIncrementTask+0x14>
808081f4:	e5843000 	str	r3, [r4]
		{
			vTaskSuspend( NULL );
808081f8:	e3a00000 	mov	r0, #0
808081fc:	ebffe7cd 	bl	80802138 <vTaskSuspend>
80808200:	eafffff7 	b	808081e4 <vLimitedIncrementTask+0x10>

80808204 <vCounterControlTask>:

/*
 * Controller task as described above.
 */
static portTASK_FUNCTION( vCounterControlTask, pvParameters )
{
80808204:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
80808208:	e3085080 	movw	r5, #32896	; 0x8080
unsigned long ulLastCounter;
short sLoops;
short sError = pdFALSE;
8080820c:	e3a06000 	mov	r6, #0
80808210:	e3485101 	movt	r5, #33025	; 0x8101
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( unsigned long ) 0;
80808214:	e1a08006 	mov	r8, r6


		/* Second section: */

		/* Suspend the continuous counter task so it stops accessing the shared variable. */
		vTaskSuspend( xContinousIncrementHandle );
80808218:	e1a09005 	mov	r9, r5
	( void ) pvParameters;

	for( ;; )
	{
		/* Start with the counter at zero. */
		ulCounter = ( unsigned long ) 0;
8080821c:	e3a04005 	mov	r4, #5
80808220:	e5858014 	str	r8, [r5, #20]
		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption. */
			vTaskSuspend( xContinousIncrementHandle );
80808224:	e5950018 	ldr	r0, [r5, #24]
80808228:	e2444001 	sub	r4, r4, #1
8080822c:	ebffe7c1 	bl	80802138 <vTaskSuspend>
				ulLastCounter = ulCounter;
			vTaskResume( xContinousIncrementHandle );
80808230:	e5950018 	ldr	r0, [r5, #24]
80808234:	e6ff4074 	uxth	r4, r4
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
		{
			/* Suspend the continuous count task so we can take a mirror of the
			shared variable without risk of corruption. */
			vTaskSuspend( xContinousIncrementHandle );
				ulLastCounter = ulCounter;
80808238:	e5957014 	ldr	r7, [r5, #20]
			vTaskResume( xContinousIncrementHandle );
8080823c:	ebffe8fa 	bl	8080262c <vTaskResume>
			
			/* Now delay to ensure the other task has processor time. */
			vTaskDelay( priSLEEP_TIME );
80808240:	e3a00080 	mov	r0, #128	; 0x80
80808244:	ebffeb83 	bl	80803058 <vTaskDelay>

			/* Check the shared variable again.  This time to ensure mutual 
			exclusion the whole scheduler will be locked.  This is just for
			demo purposes! */
			vTaskSuspendAll();
80808248:	ebffe9cb 	bl	8080297c <vTaskSuspendAll>
			{
				if( ulLastCounter == ulCounter )
8080824c:	e5953014 	ldr	r3, [r5, #20]
				{
					/* The shared variable has not changed.  There is a problem
					with the continuous count task so flag an error. */
					sError = pdTRUE;
80808250:	e1570003 	cmp	r7, r3
80808254:	03a06001 	moveq	r6, #1
				}
			}
			xTaskResumeAll();
80808258:	ebffea6f 	bl	80802c1c <xTaskResumeAll>
		ulCounter = ( unsigned long ) 0;

		/* First section : */

		/* Check the continuous count task is running. */
		for( sLoops = 0; sLoops < priLOOPS; sLoops++ )
8080825c:	e3540000 	cmp	r4, #0
80808260:	1affffef 	bne	80808224 <vCounterControlTask+0x20>


		/* Second section: */

		/* Suspend the continuous counter task so it stops accessing the shared variable. */
		vTaskSuspend( xContinousIncrementHandle );
80808264:	e5950018 	ldr	r0, [r5, #24]
80808268:	ebffe7b2 	bl	80802138 <vTaskSuspend>
		ulCounter = ( unsigned long ) 0;

		/* Resume the limited count task which has a higher priority than us.
		We should therefore not return from this call until the limited count
		task has suspended itself with a known value in the counter variable. */
		vTaskResume( xLimitedIncrementHandle );
8080826c:	e595001c 	ldr	r0, [r5, #28]

		/* Suspend the continuous counter task so it stops accessing the shared variable. */
		vTaskSuspend( xContinousIncrementHandle );

		/* Reset the variable. */
		ulCounter = ( unsigned long ) 0;
80808270:	e5854014 	str	r4, [r5, #20]

		/* Resume the limited count task which has a higher priority than us.
		We should therefore not return from this call until the limited count
		task has suspended itself with a known value in the counter variable. */
		vTaskResume( xLimitedIncrementHandle );
80808274:	ebffe8ec 	bl	8080262c <vTaskResume>

		/* Does the counter variable have the expected value? */
		if( ulCounter != priMAX_COUNT )
80808278:	e5953014 	ldr	r3, [r5, #20]
8080827c:	e35300ff 	cmp	r3, #255	; 0xff
80808280:	0a000003 	beq	80808294 <vCounterControlTask+0x90>
80808284:	e3a06001 	mov	r6, #1
				usCheckVariable++;
			portEXIT_CRITICAL();
		}

		/* Resume the continuous count task and do it all again. */
		vTaskResume( xContinousIncrementHandle );
80808288:	e5950018 	ldr	r0, [r5, #24]
8080828c:	ebffe8e6 	bl	8080262c <vTaskResume>
	}
80808290:	eaffffe1 	b	8080821c <vCounterControlTask+0x18>
		if( ulCounter != priMAX_COUNT )
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80808294:	e3560000 	cmp	r6, #0
80808298:	1afffff9 	bne	80808284 <vCounterControlTask+0x80>
		{
			/* If no errors have occurred then increment the check variable. */
			portENTER_CRITICAL();
8080829c:	ebffef97 	bl	80804100 <vTaskEnterCritical>
				usCheckVariable++;
808082a0:	e1d932b0 	ldrh	r3, [r9, #32]
808082a4:	e2833001 	add	r3, r3, #1
808082a8:	e6ff3073 	uxth	r3, r3
808082ac:	e1c932b0 	strh	r3, [r9, #32]
			portEXIT_CRITICAL();
808082b0:	ebffef9e 	bl	80804130 <vTaskExitCritical>
808082b4:	eafffff3 	b	80808288 <vCounterControlTask+0x84>

808082b8 <vContinuousIncrementTask>:
/*
 * Just keep counting the shared variable up.  The control task will suspend
 * this task when it wants.
 */
static portTASK_FUNCTION( vContinuousIncrementTask, pvParameters )
{
808082b8:	e92d4070 	push	{r4, r5, r6, lr}
808082bc:	e1a04000 	mov	r4, r0
	the task. */
	pulCounter = ( unsigned long * ) pvParameters;

	/* Query our priority so we can raise it when exclusive access to the 
	shared variable is required. */
	uxOurPriority = uxTaskPriorityGet( NULL );
808082c0:	e3a00000 	mov	r0, #0
808082c4:	ebffe6f1 	bl	80801e90 <uxTaskPriorityGet>
808082c8:	e1a05000 	mov	r5, r0
808082cc:	e2806001 	add	r6, r0, #1

	for( ;; )
	{
		/* Raise our priority above the controller task to ensure a context
		switch does not occur while we are accessing this variable. */
		vTaskPrioritySet( NULL, uxOurPriority + 1 );
808082d0:	e1a01006 	mov	r1, r6
808082d4:	e3a00000 	mov	r0, #0
808082d8:	ebffe714 	bl	80801f30 <vTaskPrioritySet>
			( *pulCounter )++;		
808082dc:	e5943000 	ldr	r3, [r4]
		vTaskPrioritySet( NULL, uxOurPriority );
808082e0:	e1a01005 	mov	r1, r5
808082e4:	e3a00000 	mov	r0, #0
	for( ;; )
	{
		/* Raise our priority above the controller task to ensure a context
		switch does not occur while we are accessing this variable. */
		vTaskPrioritySet( NULL, uxOurPriority + 1 );
			( *pulCounter )++;		
808082e8:	e2833001 	add	r3, r3, #1
808082ec:	e5843000 	str	r3, [r4]
		vTaskPrioritySet( NULL, uxOurPriority );
808082f0:	ebffe70e 	bl	80801f30 <vTaskPrioritySet>
808082f4:	eafffff5 	b	808082d0 <vContinuousIncrementTask+0x18>

808082f8 <vStartDynamicPriorityTasks>:
/*
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
808082f8:	e92d4070 	push	{r4, r5, r6, lr}
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
808082fc:	e3a02000 	mov	r2, #0
/*
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
80808300:	e24dd008 	sub	sp, sp, #8
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
80808304:	e3a01004 	mov	r1, #4
80808308:	e3a00001 	mov	r0, #1
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( const char * const) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
8080830c:	e3085080 	movw	r5, #32896	; 0x8080
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
80808310:	ebffe001 	bl	8080031c <xQueueGenericCreate>
80808314:	e3083124 	movw	r3, #33060	; 0x8124
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( const char * const) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
80808318:	e3485101 	movt	r5, #33025	; 0x8101
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
8080831c:	e3483101 	movt	r3, #33025	; 0x8101
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( const char * const) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
80808320:	e3a04000 	mov	r4, #0
 * Start the three tasks as described at the top of the file.
 * Note that the limited count task is given a higher priority.
 */
void vStartDynamicPriorityTasks( void )
{
	xSuspendedTestQueue = xQueueCreate( priSUSPENDED_QUEUE_LENGTH, sizeof( unsigned long ) );
80808324:	e5830000 	str	r0, [r3]
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( const char * const) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
80808328:	e2856014 	add	r6, r5, #20
8080832c:	e2852018 	add	r2, r5, #24
80808330:	e3091b58 	movw	r1, #39768	; 0x9b58
80808334:	e30802b8 	movw	r0, #33464	; 0x82b8
80808338:	e1a03006 	mov	r3, r6
8080833c:	e58d2004 	str	r2, [sp, #4]
80808340:	e3481080 	movt	r1, #32896	; 0x8080
80808344:	e58d4000 	str	r4, [sp]
80808348:	e3a02b01 	mov	r2, #1024	; 0x400
8080834c:	e3480080 	movt	r0, #32896	; 0x8080
	xTaskCreate( vLimitedIncrementTask, ( const char * const ) "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
80808350:	e285501c 	add	r5, r5, #28
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xSuspendedTestQueue, ( signed char * ) "Suspended_Test_Queue" );

	xTaskCreate( vContinuousIncrementTask, ( const char * const) "CNT_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY, &xContinousIncrementHandle );
80808354:	ebffe58c 	bl	8080198c <xTaskCreate>
	xTaskCreate( vLimitedIncrementTask, ( const char * const ) "LIM_INC", priSTACK_SIZE, ( void * ) &ulCounter, tskIDLE_PRIORITY + 1, &xLimitedIncrementHandle );
80808358:	e3a02001 	mov	r2, #1
8080835c:	e3091b60 	movw	r1, #39776	; 0x9b60
80808360:	e30801d4 	movw	r0, #33236	; 0x81d4
80808364:	e1a03006 	mov	r3, r6
80808368:	e88d0024 	stm	sp, {r2, r5}
8080836c:	e3481080 	movt	r1, #32896	; 0x8080
80808370:	e3a02b01 	mov	r2, #1024	; 0x400
80808374:	e3480080 	movt	r0, #32896	; 0x8080
80808378:	ebffe583 	bl	8080198c <xTaskCreate>
	xTaskCreate( vCounterControlTask, ( const char * const ) "C_CTRL", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
8080837c:	e3091b68 	movw	r1, #39784	; 0x9b68
80808380:	e3080204 	movw	r0, #33284	; 0x8204
80808384:	e1a03004 	mov	r3, r4
80808388:	e58d4004 	str	r4, [sp, #4]
8080838c:	e58d4000 	str	r4, [sp]
80808390:	e3481080 	movt	r1, #32896	; 0x8080
80808394:	e3a02b01 	mov	r2, #1024	; 0x400
80808398:	e3480080 	movt	r0, #32896	; 0x8080
8080839c:	ebffe57a 	bl	8080198c <xTaskCreate>
	xTaskCreate( vQueueSendWhenSuspendedTask, ( const char * const ) "SUSP_TX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
808083a0:	e3091b70 	movw	r1, #39792	; 0x9b70
808083a4:	e3080178 	movw	r0, #33144	; 0x8178
808083a8:	e1a03004 	mov	r3, r4
808083ac:	e58d4004 	str	r4, [sp, #4]
808083b0:	e58d4000 	str	r4, [sp]
808083b4:	e3481080 	movt	r1, #32896	; 0x8080
808083b8:	e3a02b01 	mov	r2, #1024	; 0x400
808083bc:	e3480080 	movt	r0, #32896	; 0x8080
808083c0:	ebffe571 	bl	8080198c <xTaskCreate>
	xTaskCreate( vQueueReceiveWhenSuspendedTask, ( const char * const ) "SUSP_RX", priSTACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
808083c4:	e3091b78 	movw	r1, #39800	; 0x9b78
808083c8:	e3080100 	movw	r0, #33024	; 0x8100
808083cc:	e58d4004 	str	r4, [sp, #4]
808083d0:	e1a03004 	mov	r3, r4
808083d4:	e58d4000 	str	r4, [sp]
808083d8:	e3481080 	movt	r1, #32896	; 0x8080
808083dc:	e3a02b01 	mov	r2, #1024	; 0x400
808083e0:	e3480080 	movt	r0, #32896	; 0x8080
808083e4:	ebffe568 	bl	8080198c <xTaskCreate>
}
808083e8:	e28dd008 	add	sp, sp, #8
808083ec:	e8bd8070 	pop	{r4, r5, r6, pc}

808083f0 <xAreDynamicPriorityTasksStillRunning>:
portBASE_TYPE xReturn = pdTRUE;

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
808083f0:	e3083080 	movw	r3, #32896	; 0x8080
808083f4:	e3483101 	movt	r3, #33025	; 0x8101
808083f8:	e1d322b0 	ldrh	r2, [r3, #32]
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueSendError == pdTRUE )
808083fc:	e5931010 	ldr	r1, [r3, #16]
portBASE_TYPE xReturn = pdTRUE;

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
80808400:	e1d302b2 	ldrh	r0, [r3, #34]	; 0x22
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueSendError == pdTRUE )
80808404:	e3510001 	cmp	r1, #1
portBASE_TYPE xReturn = pdTRUE;

	/* Check the tasks are still running by ensuring the check variable
	is still incrementing. */

	if( usCheckVariable == usLastTaskCheck )
80808408:	e6ff2072 	uxth	r2, r2
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueSendError == pdTRUE )
	{
		xReturn = pdFALSE;
8080840c:	03a00000 	moveq	r0, #0
	{
		/* The check has not incremented so an error exists. */
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueSendError == pdTRUE )
80808410:	0a000001 	beq	8080841c <xAreDynamicPriorityTasksStillRunning+0x2c>
portBASE_TYPE xAreDynamicPriorityTasksStillRunning( void )
{
/* Keep a history of the check variables so we know if it has been incremented 
since the last call. */
static unsigned short usLastTaskCheck = ( unsigned short ) 0;
portBASE_TYPE xReturn = pdTRUE;
80808414:	e0520000 	subs	r0, r2, r0
80808418:	13a00001 	movne	r0, #1
	if( xSuspendedQueueSendError == pdTRUE )
	{
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueReceiveError == pdTRUE )
8080841c:	e5931004 	ldr	r1, [r3, #4]
	{
		xReturn = pdFALSE;
	}

	usLastTaskCheck = usCheckVariable;
80808420:	e1d322b0 	ldrh	r2, [r3, #32]
	if( xSuspendedQueueSendError == pdTRUE )
	{
		xReturn = pdFALSE;
	}

	if( xSuspendedQueueReceiveError == pdTRUE )
80808424:	e3510001 	cmp	r1, #1
		xReturn = pdFALSE;
	}

	usLastTaskCheck = usCheckVariable;
	return xReturn;
}
80808428:	03a00000 	moveq	r0, #0
	if( xSuspendedQueueReceiveError == pdTRUE )
	{
		xReturn = pdFALSE;
	}

	usLastTaskCheck = usCheckVariable;
8080842c:	e1c322b2 	strh	r2, [r3, #34]	; 0x22
	return xReturn;
}
80808430:	e12fff1e 	bx	lr

80808434 <prvMediumPriorityMutexTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityMutexTask( void *pvParameters )
{
80808434:	e92d4010 	push	{r4, lr}
80808438:	e30840a4 	movw	r4, #32932	; 0x80a4
8080843c:	e3484101 	movt	r4, #33025	; 0x8101

	for( ;; )
	{
		/* The medium priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
80808440:	e3a00000 	mov	r0, #0
80808444:	ebffe73b 	bl	80802138 <vTaskSuspend>

		/* When this task unsuspends all it does is increment the guarded
		variable, this is so the low priority task knows that it has
		executed. */
		ulGuardedVariable++;
80808448:	e5943000 	ldr	r3, [r4]
8080844c:	e2833001 	add	r3, r3, #1
80808450:	e5843000 	str	r3, [r4]
80808454:	eafffff9 	b	80808440 <prvMediumPriorityMutexTask+0xc>

80808458 <prvHighPriorityMutexTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvHighPriorityMutexTask( void *pvParameters )
{
80808458:	e92d4070 	push	{r4, r5, r6, lr}
8080845c:	e30850a4 	movw	r5, #32932	; 0x80a4
80808460:	e1a04000 	mov	r4, r0
80808464:	e3485101 	movt	r5, #33025	; 0x8101
		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
80808468:	e3a06001 	mov	r6, #1

	for( ;; )
	{
		/* The high priority task starts by suspending itself.  The low
		priority task will unsuspend this task when required. */
		vTaskSuspend( NULL );
8080846c:	e3a00000 	mov	r0, #0
80808470:	ebffe730 	bl	80802138 <vTaskSuspend>

		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
80808474:	e3a03000 	mov	r3, #0
80808478:	e3e02000 	mvn	r2, #0
8080847c:	e1a01003 	mov	r1, r3
80808480:	e1a00004 	mov	r0, r4
80808484:	ebffe2ae 	bl	80800f44 <xQueueGenericReceive>
			xErrorDetected = pdTRUE;
		}

		/* When we eventually obtain the mutex we just give it back then
		return to suspend ready for the next test. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
80808488:	e3a03000 	mov	r3, #0
		vTaskSuspend( NULL );

		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
8080848c:	e3500001 	cmp	r0, #1
			xErrorDetected = pdTRUE;
		}

		/* When we eventually obtain the mutex we just give it back then
		return to suspend ready for the next test. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
80808490:	e1a02003 	mov	r2, r3
80808494:	e1a01003 	mov	r1, r3
80808498:	e1a00004 	mov	r0, r4
		/* When this task unsuspends all it does is attempt to obtain
		the mutex.  It should find the mutex is not available so a
		block time is specified. */
		if( xSemaphoreTake( xMutex, portMAX_DELAY ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
8080849c:	15856004 	strne	r6, [r5, #4]
		}

		/* When we eventually obtain the mutex we just give it back then
		return to suspend ready for the next test. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
808084a0:	ebffe005 	bl	808004bc <xQueueGenericSend>
808084a4:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
808084a8:	15856004 	strne	r6, [r5, #4]
808084ac:	eaffffee 	b	8080846c <prvHighPriorityMutexTask+0x14>

808084b0 <prvLowPriorityMutexTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvLowPriorityMutexTask( void *pvParameters )
{
808084b0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
808084b4:	e30840a4 	movw	r4, #32932	; 0x80a4
808084b8:	e3484101 	movt	r4, #33025	; 0x8101
808084bc:	e1a07000 	mov	r7, r0
	#endif

	for( ;; )
	{
		/* Take the mutex.  It should be available now. */
		if( xSemaphoreTake( xMutex, genqNO_BLOCK ) != pdPASS )
808084c0:	e3a08000 	mov	r8, #0
		{
			xErrorDetected = pdTRUE;
		}

		/* Set our guarded variable to a known start value. */
		ulGuardedVariable = 0;
808084c4:	e1a06004 	mov	r6, r4
	for( ;; )
	{
		/* Take the mutex.  It should be available now. */
		if( xSemaphoreTake( xMutex, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
808084c8:	e3a05001 	mov	r5, #1
	#endif

	for( ;; )
	{
		/* Take the mutex.  It should be available now. */
		if( xSemaphoreTake( xMutex, genqNO_BLOCK ) != pdPASS )
808084cc:	e3a03000 	mov	r3, #0
808084d0:	e1a00007 	mov	r0, r7
808084d4:	e1a02003 	mov	r2, r3
808084d8:	e1a01003 	mov	r1, r3
808084dc:	ebffe298 	bl	80800f44 <xQueueGenericReceive>
808084e0:	e3500001 	cmp	r0, #1
		/* Set our guarded variable to a known start value. */
		ulGuardedVariable = 0;

		/* Our priority should be as per that assigned when the task was
		created. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
808084e4:	e3a00000 	mov	r0, #0
	for( ;; )
	{
		/* Take the mutex.  It should be available now. */
		if( xSemaphoreTake( xMutex, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
808084e8:	15845004 	strne	r5, [r4, #4]
		}

		/* Set our guarded variable to a known start value. */
		ulGuardedVariable = 0;
808084ec:	e5848000 	str	r8, [r4]

		/* Our priority should be as per that assigned when the task was
		created. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
808084f0:	ebffe666 	bl	80801e90 <uxTaskPriorityGet>
808084f4:	e3500000 	cmp	r0, #0
			xErrorDetected = pdTRUE;
		}

		/* Now unsuspend the high priority task.  This will attempt to take the
		mutex, and block when it finds it cannot obtain it. */
		vTaskResume( xHighPriorityMutexTask );
808084f8:	e5940008 	ldr	r0, [r4, #8]

		/* Our priority should be as per that assigned when the task was
		created. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_LOW_PRIORITY )
		{
			xErrorDetected = pdTRUE;
808084fc:	15865004 	strne	r5, [r6, #4]
		}

		/* Now unsuspend the high priority task.  This will attempt to take the
		mutex, and block when it finds it cannot obtain it. */
		vTaskResume( xHighPriorityMutexTask );
80808500:	ebffe849 	bl	8080262c <vTaskResume>

		/* We should now have inherited the prioritoy of the high priority task,
		as by now it will have attempted to get the mutex. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
80808504:	e3a00000 	mov	r0, #0
80808508:	ebffe660 	bl	80801e90 <uxTaskPriorityGet>
		}

		/* We can attempt to set our priority to the test priority - between the
		idle priority and the medium/high test priorities, but our actual
		prioroity should remain at the high priority. */
		vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
8080850c:	e3a01001 	mov	r1, #1
		mutex, and block when it finds it cannot obtain it. */
		vTaskResume( xHighPriorityMutexTask );

		/* We should now have inherited the prioritoy of the high priority task,
		as by now it will have attempted to get the mutex. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
80808510:	e3500003 	cmp	r0, #3
		}

		/* We can attempt to set our priority to the test priority - between the
		idle priority and the medium/high test priorities, but our actual
		prioroity should remain at the high priority. */
		vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
80808514:	e3a00000 	mov	r0, #0

		/* We should now have inherited the prioritoy of the high priority task,
		as by now it will have attempted to get the mutex. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
		{
			xErrorDetected = pdTRUE;
80808518:	15865004 	strne	r5, [r6, #4]
		}

		/* We can attempt to set our priority to the test priority - between the
		idle priority and the medium/high test priorities, but our actual
		prioroity should remain at the high priority. */
		vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
8080851c:	ebffe683 	bl	80801f30 <vTaskPrioritySet>
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
80808520:	e3a00000 	mov	r0, #0
80808524:	ebffe659 	bl	80801e90 <uxTaskPriorityGet>
80808528:	e3500003 	cmp	r0, #3
			xErrorDetected = pdTRUE;
		}

		/* Now unsuspend the medium priority task.  This should not run as our
		inherited priority is above that of the medium priority task. */
		vTaskResume( xMediumPriorityMutexTask );
8080852c:	e594000c 	ldr	r0, [r4, #12]
		idle priority and the medium/high test priorities, but our actual
		prioroity should remain at the high priority. */
		vTaskPrioritySet( NULL, genqMUTEX_TEST_PRIORITY );
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_HIGH_PRIORITY )
		{
			xErrorDetected = pdTRUE;
80808530:	15845004 	strne	r5, [r4, #4]
		}

		/* Now unsuspend the medium priority task.  This should not run as our
		inherited priority is above that of the medium priority task. */
		vTaskResume( xMediumPriorityMutexTask );
80808534:	ebffe83c 	bl	8080262c <vTaskResume>

		/* If the did run then it will have incremented our guarded variable. */
		if( ulGuardedVariable != 0 )
80808538:	e5943000 	ldr	r3, [r4]
		/* When we give back the semaphore our priority should be disinherited
		back to the priority to which we attempted to set ourselves.  This means
		that when the high priority task next blocks, the medium priority task
		should execute and increment the guarded variable.   When we next run
		both the high and medium priority tasks will have been suspended again. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
8080853c:	e1a00007 	mov	r0, r7
		/* Now unsuspend the medium priority task.  This should not run as our
		inherited priority is above that of the medium priority task. */
		vTaskResume( xMediumPriorityMutexTask );

		/* If the did run then it will have incremented our guarded variable. */
		if( ulGuardedVariable != 0 )
80808540:	e3530000 	cmp	r3, #0
		/* When we give back the semaphore our priority should be disinherited
		back to the priority to which we attempted to set ourselves.  This means
		that when the high priority task next blocks, the medium priority task
		should execute and increment the guarded variable.   When we next run
		both the high and medium priority tasks will have been suspended again. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
80808544:	e3a03000 	mov	r3, #0
80808548:	e1a02003 	mov	r2, r3
8080854c:	e1a01003 	mov	r1, r3
		vTaskResume( xMediumPriorityMutexTask );

		/* If the did run then it will have incremented our guarded variable. */
		if( ulGuardedVariable != 0 )
		{
			xErrorDetected = pdTRUE;
80808550:	15865004 	strne	r5, [r6, #4]
		/* When we give back the semaphore our priority should be disinherited
		back to the priority to which we attempted to set ourselves.  This means
		that when the high priority task next blocks, the medium priority task
		should execute and increment the guarded variable.   When we next run
		both the high and medium priority tasks will have been suspended again. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
80808554:	ebffdfd8 	bl	808004bc <xQueueGenericSend>
		{
			xErrorDetected = pdTRUE;
		}

		/* Check that the guarded variable did indeed increment... */
		if( ulGuardedVariable != 1 )
80808558:	e5943000 	ldr	r3, [r4]
		/* When we give back the semaphore our priority should be disinherited
		back to the priority to which we attempted to set ourselves.  This means
		that when the high priority task next blocks, the medium priority task
		should execute and increment the guarded variable.   When we next run
		both the high and medium priority tasks will have been suspended again. */
		if( xSemaphoreGive( xMutex ) != pdPASS )
8080855c:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
80808560:	15845004 	strne	r5, [r4, #4]
			xErrorDetected = pdTRUE;
		}

		/* ... and that our priority has been disinherited to
		genqMUTEX_TEST_PRIORITY. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
80808564:	e3a00000 	mov	r0, #0
		{
			xErrorDetected = pdTRUE;
		}

		/* Check that the guarded variable did indeed increment... */
		if( ulGuardedVariable != 1 )
80808568:	e3530001 	cmp	r3, #1
		{
			xErrorDetected = pdTRUE;
8080856c:	15865004 	strne	r5, [r6, #4]
		}

		/* ... and that our priority has been disinherited to
		genqMUTEX_TEST_PRIORITY. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
80808570:	ebffe646 	bl	80801e90 <uxTaskPriorityGet>
			xErrorDetected = pdTRUE;
		}

		/* Set our priority back to our original priority ready for the next
		loop around this test. */
		vTaskPrioritySet( NULL, genqMUTEX_LOW_PRIORITY );
80808574:	e3a01000 	mov	r1, #0
			xErrorDetected = pdTRUE;
		}

		/* ... and that our priority has been disinherited to
		genqMUTEX_TEST_PRIORITY. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
80808578:	e3500001 	cmp	r0, #1
			xErrorDetected = pdTRUE;
		}

		/* Set our priority back to our original priority ready for the next
		loop around this test. */
		vTaskPrioritySet( NULL, genqMUTEX_LOW_PRIORITY );
8080857c:	e1a00001 	mov	r0, r1

		/* ... and that our priority has been disinherited to
		genqMUTEX_TEST_PRIORITY. */
		if( uxTaskPriorityGet( NULL ) != genqMUTEX_TEST_PRIORITY )
		{
			xErrorDetected = pdTRUE;
80808580:	15845004 	strne	r5, [r4, #4]
		}

		/* Set our priority back to our original priority ready for the next
		loop around this test. */
		vTaskPrioritySet( NULL, genqMUTEX_LOW_PRIORITY );
80808584:	ebffe669 	bl	80801f30 <vTaskPrioritySet>

		/* Just to show we are still running. */
		ulLoopCounter2++;
80808588:	e5943010 	ldr	r3, [r4, #16]
8080858c:	e2833001 	add	r3, r3, #1
80808590:	e5843010 	str	r3, [r4, #16]

		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif		
	}
80808594:	eaffffcc 	b	808084cc <prvLowPriorityMutexTask+0x1c>

80808598 <prvSendFrontAndBackTest>:
	xTaskCreate( prvHighPriorityMutexTask, ( const char * const )"MuHigh", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_HIGH_PRIORITY, &xHighPriorityMutexTask );
}
/*-----------------------------------------------------------*/

static void prvSendFrontAndBackTest( void *pvParameters )
{
80808598:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
8080859c:	e30850a4 	movw	r5, #32932	; 0x80a4
808085a0:	e3485101 	movt	r5, #33025	; 0x8101
808085a4:	e24dd00c 	sub	sp, sp, #12
808085a8:	e1a04000 	mov	r4, r0
	{
		/* The queue is empty, so sending an item to the back of the queue
		should have the same efect as sending it to the front of the queue.

		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
808085ac:	e1a07005 	mov	r7, r5
808085b0:	e3a06001 	mov	r6, #1
808085b4:	e3a08000 	mov	r8, #0
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
808085b8:	e3a0a002 	mov	sl, #2
			taskYIELD();
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
808085bc:	e3a0900a 	mov	r9, #10
	{
		/* The queue is empty, so sending an item to the back of the queue
		should have the same efect as sending it to the front of the queue.

		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
808085c0:	e30810b8 	movw	r1, #32952	; 0x80b8
808085c4:	e3a03001 	mov	r3, #1
808085c8:	e3a02000 	mov	r2, #0
808085cc:	e3481101 	movt	r1, #33025	; 0x8101
808085d0:	e1a00004 	mov	r0, r4
808085d4:	ebffdfb8 	bl	808004bc <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
808085d8:	e1a00004 	mov	r0, r4
808085dc:	ebffe467 	bl	80801780 <uxQueueMessagesWaiting>
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
808085e0:	e3a03000 	mov	r3, #0
		should have the same efect as sending it to the front of the queue.

		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
808085e4:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
808085e8:	e1a0100d 	mov	r1, sp
808085ec:	e1a02003 	mov	r2, r3
808085f0:	e1a00004 	mov	r0, r4
		First send to the front and check everything is as expected. */
		xQueueSendToFront( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
		{
			xErrorDetected = pdTRUE;
808085f4:	15876004 	strne	r6, [r7, #4]
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
808085f8:	ebffe251 	bl	80800f44 <xQueueGenericReceive>
			xErrorDetected = pdTRUE;
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
808085fc:	e5952014 	ldr	r2, [r5, #20]
		if( uxQueueMessagesWaiting( xQueue ) != 1 )
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
80808600:	e3500001 	cmp	r0, #1
			xErrorDetected = pdTRUE;
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
80808604:	e59d3000 	ldr	r3, [sp]
			xErrorDetected = pdTRUE;
		}

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808608:	e1a00004 	mov	r0, r4
			xErrorDetected = pdTRUE;
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
8080860c:	15856004 	strne	r6, [r5, #4]
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
80808610:	e1520003 	cmp	r2, r3
		{
			xErrorDetected = pdTRUE;
80808614:	15876004 	strne	r6, [r7, #4]
		}

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808618:	ebffe458 	bl	80801780 <uxQueueMessagesWaiting>
		{
			xErrorDetected = pdTRUE;
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
8080861c:	e3a03000 	mov	r3, #0
80808620:	e30810b8 	movw	r1, #32952	; 0x80b8
			xErrorDetected = pdTRUE;
		}

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808624:	e3500000 	cmp	r0, #0
		{
			xErrorDetected = pdTRUE;
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
80808628:	e1a02003 	mov	r2, r3
8080862c:	e3481101 	movt	r1, #33025	; 0x8101
80808630:	e1a00004 	mov	r0, r4

		/* Then do the same, sending the data to the back, checking everything
		is as expected. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
		{
			xErrorDetected = pdTRUE;
80808634:	15856004 	strne	r6, [r5, #4]
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );
80808638:	ebffdf9f 	bl	808004bc <xQueueGenericSend>

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
8080863c:	e1a00004 	mov	r0, r4
80808640:	ebffe44e 	bl	80801780 <uxQueueMessagesWaiting>
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
80808644:	e3a03000 	mov	r3, #0
			xErrorDetected = pdTRUE;
		}

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808648:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
8080864c:	e1a02003 	mov	r2, r3
80808650:	e1a0100d 	mov	r1, sp
80808654:	e1a00004 	mov	r0, r4

		xQueueSendToBack( xQueue, ( void * ) &ulLoopCounter, genqNO_BLOCK );

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
		{
			xErrorDetected = pdTRUE;
80808658:	15876004 	strne	r6, [r7, #4]
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
8080865c:	ebffe238 	bl	80800f44 <xQueueGenericReceive>
80808660:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808664:	e1a00004 	mov	r0, r4
			xErrorDetected = pdTRUE;
		}

		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
80808668:	15856004 	strne	r6, [r5, #4]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
8080866c:	ebffe443 	bl	80801780 <uxQueueMessagesWaiting>
			xErrorDetected = pdTRUE;
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
80808670:	e59d3000 	ldr	r3, [sp]
		if( xQueueReceive( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808674:	e3500000 	cmp	r0, #0
			xErrorDetected = pdTRUE;
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
80808678:	e5952014 	ldr	r2, [r5, #20]
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
		{
			xErrorDetected = pdTRUE;
8080867c:	15856004 	strne	r6, [r5, #4]
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
80808680:	e58da000 	str	sl, [sp]
			xErrorDetected = pdTRUE;
		}

		/* The data we sent to the queue should equal the data we just received
		from the queue. */
		if( ulLoopCounter != ulData )
80808684:	e1520003 	cmp	r2, r3
		{
			xErrorDetected = pdTRUE;
80808688:	15876004 	strne	r6, [r7, #4]


		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
		{
			xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK );
8080868c:	e3a03000 	mov	r3, #0
80808690:	e1a0100d 	mov	r1, sp
80808694:	e1a02003 	mov	r2, r3
80808698:	e1a00004 	mov	r0, r4
8080869c:	ebffdf86 	bl	808004bc <xQueueGenericSend>
		#endif



		/* Place 2, 3, 4 into the queue, adding items to the back of the queue. */
		for( ulData = 2; ulData < 5; ulData++ )
808086a0:	e59d3000 	ldr	r3, [sp]
808086a4:	e2833001 	add	r3, r3, #1
808086a8:	e3530004 	cmp	r3, #4
808086ac:	e58d3000 	str	r3, [sp]
808086b0:	9afffff5 	bls	8080868c <prvSendFrontAndBackTest+0xf4>
			xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK );
		}

		/* Now the order in the queue should be 2, 3, 4, with 2 being the first
		thing to be read out.  Now add 1 then 0 to the front of the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 3 )
808086b4:	e1a00004 	mov	r0, r4
808086b8:	ebffe430 	bl	80801780 <uxQueueMessagesWaiting>
		{
			xErrorDetected = pdTRUE;
		}
		ulData = 1;
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
808086bc:	e3a03001 	mov	r3, #1
			xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK );
		}

		/* Now the order in the queue should be 2, 3, 4, with 2 being the first
		thing to be read out.  Now add 1 then 0 to the front of the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 3 )
808086c0:	e3500003 	cmp	r0, #3
		{
			xErrorDetected = pdTRUE;
		}
		ulData = 1;
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
808086c4:	e3a02000 	mov	r2, #0
808086c8:	e1a0100d 	mov	r1, sp
808086cc:	e1a00004 	mov	r0, r4

		/* Now the order in the queue should be 2, 3, 4, with 2 being the first
		thing to be read out.  Now add 1 then 0 to the front of the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 3 )
		{
			xErrorDetected = pdTRUE;
808086d0:	15856004 	strne	r6, [r5, #4]
		}
		ulData = 1;
808086d4:	e58d6000 	str	r6, [sp]
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
808086d8:	ebffdf77 	bl	808004bc <xQueueGenericSend>
		ulData = 0;
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
808086dc:	e3a03001 	mov	r3, #1
808086e0:	e3a02000 	mov	r2, #0
808086e4:	e1a0100d 	mov	r1, sp
808086e8:	e1a00004 	mov	r0, r4
		{
			xErrorDetected = pdTRUE;
		}
		ulData = 1;
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
		ulData = 0;
808086ec:	e58d8000 	str	r8, [sp]
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );
808086f0:	ebffdf71 	bl	808004bc <xQueueGenericSend>

		/* Now the queue should be full, and when we read the data out we
		should receive 0, 1, 2, 3, 4. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
808086f4:	e1a00004 	mov	r0, r4
808086f8:	ebffe420 	bl	80801780 <uxQueueMessagesWaiting>
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
808086fc:	e3a03001 	mov	r3, #1
		ulData = 0;
		xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK );

		/* Now the queue should be full, and when we read the data out we
		should receive 0, 1, 2, 3, 4. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
80808700:	e3500005 	cmp	r0, #5
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808704:	e3a02000 	mov	r2, #0
80808708:	e1a0100d 	mov	r1, sp
8080870c:	e1a00004 	mov	r0, r4

		/* Now the queue should be full, and when we read the data out we
		should receive 0, 1, 2, 3, 4. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
		{
			xErrorDetected = pdTRUE;
80808710:	15856004 	strne	r6, [r5, #4]
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808714:	ebffdf68 	bl	808004bc <xQueueGenericSend>
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808718:	e3a03000 	mov	r3, #0
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
8080871c:	e3500000 	cmp	r0, #0
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808720:	e1a0100d 	mov	r1, sp
80808724:	e1a02003 	mov	r2, r3
80808728:	e1a00004 	mov	r0, r4
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
		{
			xErrorDetected = pdTRUE;
8080872c:	15856004 	strne	r6, [r5, #4]
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808730:	ebffdf61 	bl	808004bc <xQueueGenericSend>
80808734:	e3500000 	cmp	r0, #0
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
80808738:	058d0000 	streq	r0, [sp]
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
		{
			xErrorDetected = pdTRUE;
8080873c:	15856004 	strne	r6, [r5, #4]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
80808740:	158d8000 	strne	r8, [sp]
		{
			/* Try peeking the data first. */
			if( xQueuePeek( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
80808744:	e3a03001 	mov	r3, #1
80808748:	e3a02000 	mov	r2, #0
8080874c:	e28d1004 	add	r1, sp, #4
80808750:	e1a00004 	mov	r0, r4
80808754:	ebffe1fa 	bl	80800f44 <xQueueGenericReceive>
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
80808758:	e59dc004 	ldr	ip, [sp, #4]
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
8080875c:	e3a03000 	mov	r3, #0
			if( xQueuePeek( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
80808760:	e59db000 	ldr	fp, [sp]

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
		{
			/* Try peeking the data first. */
			if( xQueuePeek( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
80808764:	e3500001 	cmp	r0, #1
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
80808768:	e1a02003 	mov	r2, r3
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
		{
			/* Try peeking the data first. */
			if( xQueuePeek( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
			{
				xErrorDetected = pdTRUE;
8080876c:	15856004 	strne	r6, [r5, #4]
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
80808770:	e28d1004 	add	r1, sp, #4
			}
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
80808774:	e1e0e00c 	mvn	lr, ip
			if( xQueuePeek( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
80808778:	e15b000c 	cmp	fp, ip
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
8080877c:	e1a00004 	mov	r0, r4
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
			{
				xErrorDetected = pdTRUE;
80808780:	15856004 	strne	r6, [r5, #4]
			}
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
80808784:	e58de004 	str	lr, [sp, #4]
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
80808788:	ebffe1ed 	bl	80800f44 <xQueueGenericReceive>
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
8080878c:	e59d2000 	ldr	r2, [sp]
			

			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
80808790:	e3500001 	cmp	r0, #1
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
80808794:	e59d1004 	ldr	r1, [sp, #4]
			/* Now try receiving the data for real.  The value should be the
			same.  Clobber the value first so we know we really received it. */
			ulData2 = ~ulData2;
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
			{
				xErrorDetected = pdTRUE;
80808798:	15856004 	strne	r6, [r5, #4]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
8080879c:	e2823001 	add	r3, r2, #1
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
808087a0:	e1520001 	cmp	r2, r1
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
808087a4:	e58d3000 	str	r3, [sp]
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
			{
				xErrorDetected = pdTRUE;
808087a8:	15856004 	strne	r6, [r5, #4]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 0; ulData < genqQUEUE_LENGTH; ulData++ )
808087ac:	e3530004 	cmp	r3, #4
808087b0:	9affffe3 	bls	80808744 <prvSendFrontAndBackTest+0x1ac>
				xErrorDetected = pdTRUE;
			}
		}

		/* The queue should now be empty again. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
808087b4:	e1a00004 	mov	r0, r4
808087b8:	ebffe3f0 	bl	80801780 <uxQueueMessagesWaiting>
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
808087bc:	e3a03000 	mov	r3, #0
				xErrorDetected = pdTRUE;
			}
		}

		/* The queue should now be empty again. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
808087c0:	e3500000 	cmp	r0, #0
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
808087c4:	e1a02003 	mov	r2, r3
808087c8:	e1a0100d 	mov	r1, sp
808087cc:	e1a00004 	mov	r0, r4
		}

		/* The queue should now be empty again. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
		{
			xErrorDetected = pdTRUE;
808087d0:	15856004 	strne	r6, [r5, #4]
			taskYIELD();
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
808087d4:	e58d9000 	str	r9, [sp]
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
808087d8:	ebffdf37 	bl	808004bc <xQueueGenericSend>
		{
			xErrorDetected = pdTRUE;
		}
		ulData = 11;
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
808087dc:	e3a03000 	mov	r3, #0
		#endif


		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
808087e0:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
		}
		ulData = 11;
808087e4:	e3a0c00b 	mov	ip, #11
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
808087e8:	e1a02003 	mov	r2, r3
808087ec:	e1a0100d 	mov	r1, sp
808087f0:	e1a00004 	mov	r0, r4

		/* Our queue is empty once more, add 10, 11 to the back. */
		ulData = 10;
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
808087f4:	15856004 	strne	r6, [r5, #4]
		}
		ulData = 11;
808087f8:	e58dc000 	str	ip, [sp]
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
808087fc:	ebffdf2e 	bl	808004bc <xQueueGenericSend>
80808800:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 2 )
80808804:	e1a00004 	mov	r0, r4
			xErrorDetected = pdTRUE;
		}
		ulData = 11;
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
80808808:	15856004 	strne	r6, [r5, #4]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 2 )
8080880c:	ebffe3db 	bl	80801780 <uxQueueMessagesWaiting>
			xErrorDetected = pdTRUE;
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
80808810:	e3a03009 	mov	r3, #9
		if( xQueueSend( xQueue, &ulData, genqNO_BLOCK ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 2 )
80808814:	e3500002 	cmp	r0, #2
		{
			xErrorDetected = pdTRUE;
80808818:	15856004 	strne	r6, [r5, #4]
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
8080881c:	e58d3000 	str	r3, [sp]
		{
			if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
80808820:	e3a03001 	mov	r3, #1
80808824:	e3a02000 	mov	r2, #0
80808828:	e1a0100d 	mov	r1, sp
8080882c:	e1a00004 	mov	r0, r4
80808830:	ebffdf21 	bl	808004bc <xQueueGenericSend>
			xErrorDetected = pdTRUE;
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
80808834:	e59d3000 	ldr	r3, [sp]
		{
			if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != pdPASS )
80808838:	e3500001 	cmp	r0, #1
			{
				xErrorDetected = pdTRUE;
8080883c:	15856004 	strne	r6, [r5, #4]
			xErrorDetected = pdTRUE;
		}

		/* Now we should have 10, 11 in the queue.  Add 7, 8, 9 to the
		front. */
		for( ulData = 9; ulData >= 7; ulData-- )
80808840:	e2433001 	sub	r3, r3, #1
80808844:	e3530006 	cmp	r3, #6
80808848:	e58d3000 	str	r3, [sp]
8080884c:	8afffff3 	bhi	80808820 <prvSendFrontAndBackTest+0x288>
			}
		}

		/* Now check that the queue is full, and that receiving data provides
		the expected sequence of 7, 8, 9, 10, 11. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
80808850:	e1a00004 	mov	r0, r4
80808854:	ebffe3c9 	bl	80801780 <uxQueueMessagesWaiting>
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808858:	e3a03001 	mov	r3, #1
			}
		}

		/* Now check that the queue is full, and that receiving data provides
		the expected sequence of 7, 8, 9, 10, 11. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
8080885c:	e3500005 	cmp	r0, #5
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808860:	e3a02000 	mov	r2, #0
80808864:	e1a0100d 	mov	r1, sp
80808868:	e1a00004 	mov	r0, r4

		/* Now check that the queue is full, and that receiving data provides
		the expected sequence of 7, 8, 9, 10, 11. */
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
		{
			xErrorDetected = pdTRUE;
8080886c:	15856004 	strne	r6, [r5, #4]
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808870:	ebffdf11 	bl	808004bc <xQueueGenericSend>
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808874:	e3a03000 	mov	r3, #0
		if( uxQueueMessagesWaiting( xQueue ) != 5 )
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808878:	e3500000 	cmp	r0, #0
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
8080887c:	e1a02003 	mov	r2, r3
80808880:	e1a0100d 	mov	r1, sp
80808884:	e1a00004 	mov	r0, r4
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
		{
			xErrorDetected = pdTRUE;
80808888:	15856004 	strne	r6, [r5, #4]
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
8080888c:	ebffdf0a 	bl	808004bc <xQueueGenericSend>
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
80808890:	e3a03007 	mov	r3, #7
		if( xQueueSendToFront( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
		{
			xErrorDetected = pdTRUE;
		}

		if( xQueueSendToBack( xQueue, ( void * ) &ulData, genqNO_BLOCK ) != errQUEUE_FULL )
80808894:	e3500000 	cmp	r0, #0
		{
			xErrorDetected = pdTRUE;
80808898:	15856004 	strne	r6, [r5, #4]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
8080889c:	e58d3000 	str	r3, [sp]
		{
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
808088a0:	e3a03000 	mov	r3, #0
808088a4:	e28d1004 	add	r1, sp, #4
808088a8:	e1a02003 	mov	r2, r3
808088ac:	e1a00004 	mov	r0, r4
808088b0:	ebffe1a3 	bl	80800f44 <xQueueGenericReceive>
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
808088b4:	e59d2000 	ldr	r2, [sp]
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
		{
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
808088b8:	e3500001 	cmp	r0, #1
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
808088bc:	e59d1004 	ldr	r1, [sp, #4]
		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
		{
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
			{
				xErrorDetected = pdTRUE;
808088c0:	15856004 	strne	r6, [r5, #4]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
808088c4:	e2823001 	add	r3, r2, #1
			if( xQueueReceive( xQueue, &ulData2, genqNO_BLOCK ) != pdPASS )
			{
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
808088c8:	e1520001 	cmp	r2, r1
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
808088cc:	e58d3000 	str	r3, [sp]
				xErrorDetected = pdTRUE;
			}

			if( ulData != ulData2 )
			{
				xErrorDetected = pdTRUE;
808088d0:	15856004 	strne	r6, [r5, #4]
		#if configUSE_PREEMPTION == 0
			taskYIELD();
		#endif

		/* Check the data we read out is in the expected order. */
		for( ulData = 7; ulData < ( 7 + genqQUEUE_LENGTH ); ulData++ )
808088d4:	e353000b 	cmp	r3, #11
808088d8:	9afffff0 	bls	808088a0 <prvSendFrontAndBackTest+0x308>
			{
				xErrorDetected = pdTRUE;
			}
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
808088dc:	e1a00004 	mov	r0, r4
808088e0:	ebffe3a6 	bl	80801780 <uxQueueMessagesWaiting>
		{
			xErrorDetected = pdTRUE;
		}

		ulLoopCounter++;
808088e4:	e5953014 	ldr	r3, [r5, #20]
			{
				xErrorDetected = pdTRUE;
			}
		}

		if( uxQueueMessagesWaiting( xQueue ) != 0 )
808088e8:	e3500000 	cmp	r0, #0
		{
			xErrorDetected = pdTRUE;
808088ec:	15856004 	strne	r6, [r5, #4]
		}

		ulLoopCounter++;
808088f0:	e2833001 	add	r3, r3, #1
808088f4:	e5853014 	str	r3, [r5, #20]
	}
808088f8:	eaffff30 	b	808085c0 <prvSendFrontAndBackTest+0x28>

808088fc <vStartGenericQueueTasks>:
static xTaskHandle xHighPriorityMutexTask, xMediumPriorityMutexTask;

/*-----------------------------------------------------------*/

void vStartGenericQueueTasks( unsigned portBASE_TYPE uxPriority )
{
808088fc:	e92d4070 	push	{r4, r5, r6, lr}
xQueueHandle xQueue;
xSemaphoreHandle xMutex;

	/* Create the queue that we are going to use for the
	prvSendFrontAndBackTest demo. */
	xQueue = xQueueCreate( genqQUEUE_LENGTH, sizeof( unsigned portLONG ) );
80808900:	e3a02000 	mov	r2, #0
static xTaskHandle xHighPriorityMutexTask, xMediumPriorityMutexTask;

/*-----------------------------------------------------------*/

void vStartGenericQueueTasks( unsigned portBASE_TYPE uxPriority )
{
80808904:	e24dd008 	sub	sp, sp, #8
80808908:	e1a04000 	mov	r4, r0
xQueueHandle xQueue;
xSemaphoreHandle xMutex;

	/* Create the queue that we are going to use for the
	prvSendFrontAndBackTest demo. */
	xQueue = xQueueCreate( genqQUEUE_LENGTH, sizeof( unsigned portLONG ) );
8080890c:	e3a01004 	mov	r1, #4
80808910:	e3a00005 	mov	r0, #5
80808914:	ebffde80 	bl	8080031c <xQueueGenericCreate>
	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "Gen_Queue_Test" );

	/* Create the demo task and pass it the queue just created.  We are
	passing the queue handle by value so it does not matter that it is
	declared on the stack here. */
	xTaskCreate( prvSendFrontAndBackTest, ( const char * const )"GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );
80808918:	e3a05000 	mov	r5, #0
8080891c:	e1a03000 	mov	r3, r0
80808920:	e3091b80 	movw	r1, #39808	; 0x9b80
80808924:	e3080598 	movw	r0, #34200	; 0x8598
80808928:	e58d4000 	str	r4, [sp]
8080892c:	e3481080 	movt	r1, #32896	; 0x8080
80808930:	e3a02b01 	mov	r2, #1024	; 0x400
80808934:	e58d5004 	str	r5, [sp, #4]
80808938:	e3480080 	movt	r0, #32896	; 0x8080

	/* Create the mutex demo tasks and pass it the mutex just created.  We are
	passing the mutex handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityMutexTask, ( const char * const )"MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
	xTaskCreate( prvMediumPriorityMutexTask, ( const char * const )"MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
8080893c:	e30840a4 	movw	r4, #32932	; 0x80a4
	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "Gen_Queue_Test" );

	/* Create the demo task and pass it the queue just created.  We are
	passing the queue handle by value so it does not matter that it is
	declared on the stack here. */
	xTaskCreate( prvSendFrontAndBackTest, ( const char * const )"GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );
80808940:	ebffe411 	bl	8080198c <xTaskCreate>

	/* Create the mutex used by the prvMutexTest task. */
	xMutex = xSemaphoreCreateMutex();
80808944:	e3a00001 	mov	r0, #1

	/* Create the mutex demo tasks and pass it the mutex just created.  We are
	passing the mutex handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityMutexTask, ( const char * const )"MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
	xTaskCreate( prvMediumPriorityMutexTask, ( const char * const )"MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
80808948:	e3484101 	movt	r4, #33025	; 0x8101
	passing the queue handle by value so it does not matter that it is
	declared on the stack here. */
	xTaskCreate( prvSendFrontAndBackTest, ( const char * const )"GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );

	/* Create the mutex used by the prvMutexTest task. */
	xMutex = xSemaphoreCreateMutex();
8080894c:	ebffe082 	bl	80800b5c <xQueueCreateMutex>
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Gen_Queue_Mutex" );

	/* Create the mutex demo tasks and pass it the mutex just created.  We are
	passing the mutex handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityMutexTask, ( const char * const )"MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
80808950:	e3091b88 	movw	r1, #39816	; 0x9b88
	passing the queue handle by value so it does not matter that it is
	declared on the stack here. */
	xTaskCreate( prvSendFrontAndBackTest, ( const char * const )"GenQ", configMINIMAL_STACK_SIZE, ( void * ) xQueue, uxPriority, NULL );

	/* Create the mutex used by the prvMutexTest task. */
	xMutex = xSemaphoreCreateMutex();
80808954:	e1a06000 	mov	r6, r0
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Gen_Queue_Mutex" );

	/* Create the mutex demo tasks and pass it the mutex just created.  We are
	passing the mutex handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityMutexTask, ( const char * const )"MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
80808958:	e30804b0 	movw	r0, #33968	; 0x84b0
8080895c:	e1a03006 	mov	r3, r6
80808960:	e58d5004 	str	r5, [sp, #4]
80808964:	e3481080 	movt	r1, #32896	; 0x8080
80808968:	e58d5000 	str	r5, [sp]
8080896c:	e3a02b01 	mov	r2, #1024	; 0x400
80808970:	e3480080 	movt	r0, #32896	; 0x8080
80808974:	ebffe404 	bl	8080198c <xTaskCreate>
	xTaskCreate( prvMediumPriorityMutexTask, ( const char * const )"MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
80808978:	e284c00c 	add	ip, r4, #12
8080897c:	e3a02002 	mov	r2, #2
80808980:	e3091b90 	movw	r1, #39824	; 0x9b90
80808984:	e3080434 	movw	r0, #33844	; 0x8434
80808988:	e88d1004 	stm	sp, {r2, ip}
8080898c:	e1a03005 	mov	r3, r5
80808990:	e3481080 	movt	r1, #32896	; 0x8080
80808994:	e3a02b01 	mov	r2, #1024	; 0x400
80808998:	e3480080 	movt	r0, #32896	; 0x8080
	xTaskCreate( prvHighPriorityMutexTask, ( const char * const )"MuHigh", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_HIGH_PRIORITY, &xHighPriorityMutexTask );
8080899c:	e2844008 	add	r4, r4, #8

	/* Create the mutex demo tasks and pass it the mutex just created.  We are
	passing the mutex handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityMutexTask, ( const char * const )"MuLow", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_LOW_PRIORITY, NULL );
	xTaskCreate( prvMediumPriorityMutexTask, ( const char * const )"MuMed", configMINIMAL_STACK_SIZE, NULL, genqMUTEX_MEDIUM_PRIORITY, &xMediumPriorityMutexTask );
808089a0:	ebffe3f9 	bl	8080198c <xTaskCreate>
	xTaskCreate( prvHighPriorityMutexTask, ( const char * const )"MuHigh", configMINIMAL_STACK_SIZE, ( void * ) xMutex, genqMUTEX_HIGH_PRIORITY, &xHighPriorityMutexTask );
808089a4:	e3a02003 	mov	r2, #3
808089a8:	e3091b98 	movw	r1, #39832	; 0x9b98
808089ac:	e3080458 	movw	r0, #33880	; 0x8458
808089b0:	e58d2000 	str	r2, [sp]
808089b4:	e58d4004 	str	r4, [sp, #4]
808089b8:	e1a03006 	mov	r3, r6
808089bc:	e3481080 	movt	r1, #32896	; 0x8080
808089c0:	e3a02b01 	mov	r2, #1024	; 0x400
808089c4:	e3480080 	movt	r0, #32896	; 0x8080
808089c8:	ebffe3ef 	bl	8080198c <xTaskCreate>
}
808089cc:	e28dd008 	add	sp, sp, #8
808089d0:	e8bd8070 	pop	{r4, r5, r6, pc}

808089d4 <xAreGenericQueueTasksStillRunning>:
{
static unsigned portLONG ulLastLoopCounter = 0, ulLastLoopCounter2 = 0;

	/* If the demo task is still running then we expect the loopcounters to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
808089d4:	e30830a4 	movw	r3, #32932	; 0x80a4
808089d8:	e3483101 	movt	r3, #33025	; 0x8101
808089dc:	e5932014 	ldr	r2, [r3, #20]
808089e0:	e5931018 	ldr	r1, [r3, #24]
	{
		xErrorDetected = pdTRUE;
	}

	if( ulLastLoopCounter2 == ulLoopCounter2 )
808089e4:	e593001c 	ldr	r0, [r3, #28]
{
static unsigned portLONG ulLastLoopCounter = 0, ulLastLoopCounter2 = 0;

	/* If the demo task is still running then we expect the loopcounters to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
808089e8:	e1510002 	cmp	r1, r2
	{
		xErrorDetected = pdTRUE;
	}

	if( ulLastLoopCounter2 == ulLoopCounter2 )
808089ec:	e5931010 	ldr	r1, [r3, #16]

	/* If the demo task is still running then we expect the loopcounters to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
	{
		xErrorDetected = pdTRUE;
808089f0:	03a02001 	moveq	r2, #1
808089f4:	05832004 	streq	r2, [r3, #4]
	}

	if( ulLastLoopCounter2 == ulLoopCounter2 )
808089f8:	e30820a4 	movw	r2, #32932	; 0x80a4
808089fc:	e1500001 	cmp	r0, r1
80808a00:	e3482101 	movt	r2, #33025	; 0x8101
80808a04:	15920004 	ldrne	r0, [r2, #4]
	{
		xErrorDetected = pdTRUE;
80808a08:	03a01001 	moveq	r1, #1
80808a0c:	05821004 	streq	r1, [r2, #4]
80808a10:	03a00000 	moveq	r0, #0
	}

	ulLastLoopCounter = ulLoopCounter;
80808a14:	e5931014 	ldr	r1, [r3, #20]
	ulLastLoopCounter2 = ulLoopCounter2;	
80808a18:	e5932010 	ldr	r2, [r3, #16]
80808a1c:	116f0f10 	clzne	r0, r0
80808a20:	11a002a0 	lsrne	r0, r0, #5
	if( ulLastLoopCounter2 == ulLoopCounter2 )
	{
		xErrorDetected = pdTRUE;
	}

	ulLastLoopCounter = ulLoopCounter;
80808a24:	e5831018 	str	r1, [r3, #24]
	ulLastLoopCounter2 = ulLoopCounter2;	
80808a28:	e583201c 	str	r2, [r3, #28]

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return !xErrorDetected;
}
80808a2c:	e12fff1e 	bx	lr

80808a30 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
80808a30:	e92d40f0 	push	{r4, r5, r6, r7, lr}
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
80808a34:	e3026493 	movw	r6, #9363	; 0x2493
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80808a38:	e307571b 	movw	r5, #30491	; 0x771b
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
80808a3c:	e24dd00c 	sub	sp, sp, #12
80808a40:	e1a04000 	mov	r4, r0
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
		lValue /= intgCONST4;
80808a44:	e3496249 	movt	r6, #37449	; 0x9249
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80808a48:	e34f5ffe 	movt	r5, #65534	; 0xfffe
static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
80808a4c:	e3a03000 	mov	r3, #0
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
80808a50:	e3a0707b 	mov	r7, #123	; 0x7b
80808a54:	e58d7004 	str	r7, [sp, #4]
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80808a58:	e2232001 	eor	r2, r3, #1
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
		lValue += intgCONST2;
80808a5c:	e59d3004 	ldr	r3, [sp, #4]
80808a60:	e2833be5 	add	r3, r3, #234496	; 0x39400
80808a64:	e2833047 	add	r3, r3, #71	; 0x47
80808a68:	e58d3004 	str	r3, [sp, #4]
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
80808a6c:	e59d3004 	ldr	r3, [sp, #4]
80808a70:	e0433103 	sub	r3, r3, r3, lsl #2
80808a74:	e58d3004 	str	r3, [sp, #4]
		lValue /= intgCONST4;
80808a78:	e59d3004 	ldr	r3, [sp, #4]
80808a7c:	e0c10693 	smull	r0, r1, r3, r6
80808a80:	e1a00fc3 	asr	r0, r3, #31
80808a84:	e0833001 	add	r3, r3, r1
80808a88:	e0603143 	rsb	r3, r0, r3, asr #2
80808a8c:	e58d3004 	str	r3, [sp, #4]

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
80808a90:	e59d3004 	ldr	r3, [sp, #4]
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
80808a94:	e1530005 	cmp	r3, r5
80808a98:	13a03000 	movne	r3, #0
80808a9c:	02023001 	andeq	r3, r2, #1
80808aa0:	e3530000 	cmp	r3, #0
80808aa4:	0a000005 	beq	80808ac0 <vCompeteingIntMathTask+0x90>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
80808aa8:	ebffed94 	bl	80804100 <vTaskEnterCritical>
				*pxTaskHasExecuted = pdTRUE;
80808aac:	e3a03001 	mov	r3, #1
80808ab0:	e5843000 	str	r3, [r4]
			portEXIT_CRITICAL();
80808ab4:	ebffed9d 	bl	80804130 <vTaskExitCritical>
80808ab8:	e3a03000 	mov	r3, #0
80808abc:	eaffffe4 	b	80808a54 <vCompeteingIntMathTask+0x24>
80808ac0:	e3a03001 	mov	r3, #1
80808ac4:	eaffffe2 	b	80808a54 <vCompeteingIntMathTask+0x24>

80808ac8 <vStartIntegerMathTasks>:
static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
80808ac8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
80808acc:	e24dd00c 	sub	sp, sp, #12
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, ( const char * const ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
80808ad0:	e58d0000 	str	r0, [sp]
80808ad4:	e3a02000 	mov	r2, #0
80808ad8:	e30830c4 	movw	r3, #32964	; 0x80c4
80808adc:	e3091ba0 	movw	r1, #39840	; 0x9ba0
80808ae0:	e3080a30 	movw	r0, #35376	; 0x8a30
80808ae4:	e58d2004 	str	r2, [sp, #4]
80808ae8:	e3483101 	movt	r3, #33025	; 0x8101
80808aec:	e3481080 	movt	r1, #32896	; 0x8080
80808af0:	e3a02b01 	mov	r2, #1024	; 0x400
80808af4:	e3480080 	movt	r0, #32896	; 0x8080
80808af8:	ebffe3a3 	bl	8080198c <xTaskCreate>
	}
}
80808afc:	e28dd00c 	add	sp, sp, #12
80808b00:	e49df004 	pop	{pc}		; (ldr pc, [sp], #4)

80808b04 <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
80808b04:	e30830c4 	movw	r3, #32964	; 0x80c4
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
80808b08:	e3a02000 	mov	r2, #0

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
80808b0c:	e3483101 	movt	r3, #33025	; 0x8101
80808b10:	e5930000 	ldr	r0, [r3]
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
80808b14:	e5832000 	str	r2, [r3]
	}

	return xReturn;
}
80808b18:	e0500002 	subs	r0, r0, r2
80808b1c:	13a00001 	movne	r0, #1
80808b20:	e12fff1e 	bx	lr

80808b24 <vPolledQueueProducer>:
	xTaskCreate( vPolledQueueProducer, ( const char * const ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
80808b24:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
unsigned short usValue = ( unsigned short ) 0;
80808b28:	e3a03000 	mov	r3, #0
80808b2c:	e30880c8 	movw	r8, #32968	; 0x80c8
	xTaskCreate( vPolledQueueProducer, ( const char * const ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
80808b30:	e24dd008 	sub	sp, sp, #8
80808b34:	e1a07000 	mov	r7, r0
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;
80808b38:	e1a06003 	mov	r6, r3
80808b3c:	e3488101 	movt	r8, #33025	; 0x8101
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
unsigned short usValue = ( unsigned short ) 0;
80808b40:	e28d5008 	add	r5, sp, #8
80808b44:	e16530b2 	strh	r3, [r5, #-2]!
signed portBASE_TYPE xError = pdFALSE, xLoop;
80808b48:	e3a04003 	mov	r4, #3
	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
80808b4c:	e3a03000 	mov	r3, #0
80808b50:	e1a01005 	mov	r1, r5
80808b54:	e1a02003 	mov	r2, r3
80808b58:	e5970000 	ldr	r0, [r7]
80808b5c:	ebffde56 	bl	808004bc <xQueueGenericSend>
80808b60:	e3500001 	cmp	r0, #1
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
80808b64:	13a06001 	movne	r6, #1
	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
80808b68:	0a000004 	beq	80808b80 <vPolledQueueProducer+0x5c>
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
80808b6c:	e2544001 	subs	r4, r4, #1
80808b70:	1afffff5 	bne	80808b4c <vPolledQueueProducer+0x28>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
80808b74:	e3a000c8 	mov	r0, #200	; 0xc8
80808b78:	ebffe936 	bl	80803058 <vTaskDelay>
	}
80808b7c:	eafffff1 	b	80808b48 <vPolledQueueProducer+0x24>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
80808b80:	e3560000 	cmp	r6, #0
80808b84:	0a000003 	beq	80808b98 <vPolledQueueProducer+0x74>
						xPollingProducerCount++;
					portEXIT_CRITICAL();
				}

				/* Update the value we are going to post next time around. */
				usValue++;
80808b88:	e1dd30b6 	ldrh	r3, [sp, #6]
80808b8c:	e2833001 	add	r3, r3, #1
80808b90:	e1cd30b6 	strh	r3, [sp, #6]
80808b94:	eafffff4 	b	80808b6c <vPolledQueueProducer+0x48>
			{
				if( xError == pdFALSE )
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
80808b98:	ebffed58 	bl	80804100 <vTaskEnterCritical>
						xPollingProducerCount++;
80808b9c:	e5983000 	ldr	r3, [r8]
80808ba0:	e2833001 	add	r3, r3, #1
80808ba4:	e5883000 	str	r3, [r8]
					portEXIT_CRITICAL();
80808ba8:	ebffed60 	bl	80804130 <vTaskExitCritical>
80808bac:	eafffff5 	b	80808b88 <vPolledQueueProducer+0x64>

80808bb0 <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
80808bb0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
unsigned short usData, usExpectedValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE;
80808bb4:	e3a07000 	mov	r7, #0
80808bb8:	e30880c8 	movw	r8, #32968	; 0x80c8
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
80808bbc:	e24dd008 	sub	sp, sp, #8
80808bc0:	e1a04000 	mov	r4, r0
unsigned short usData, usExpectedValue = ( unsigned short ) 0;
80808bc4:	e1a06007 	mov	r6, r7
80808bc8:	e3488101 	movt	r8, #33025	; 0x8101
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
80808bcc:	e5940000 	ldr	r0, [r4]
80808bd0:	ebffe2ea 	bl	80801780 <uxQueueMessagesWaiting>
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
80808bd4:	e3a03000 	mov	r3, #0
80808bd8:	e28d1006 	add	r1, sp, #6
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
80808bdc:	e1500003 	cmp	r0, r3
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
80808be0:	e1a02003 	mov	r2, r3
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
80808be4:	e3a000b4 	mov	r0, #180	; 0xb4
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
80808be8:	1a000001 	bne	80808bf4 <vPolledQueueConsumer+0x44>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
80808bec:	ebffe919 	bl	80803058 <vTaskDelay>
	}
80808bf0:	eafffff5 	b	80808bcc <vPolledQueueConsumer+0x1c>
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
80808bf4:	e5940000 	ldr	r0, [r4]
80808bf8:	ebffe0d1 	bl	80800f44 <xQueueGenericReceive>
80808bfc:	e3500001 	cmp	r0, #1
80808c00:	1afffff1 	bne	80808bcc <vPolledQueueConsumer+0x1c>
			{
				if( usData != usExpectedValue )
80808c04:	e1dd50b6 	ldrh	r5, [sp, #6]
80808c08:	e1560005 	cmp	r6, r5
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
80808c0c:	11a07000 	movne	r7, r0
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
			{
				if( usData != usExpectedValue )
80808c10:	0a000002 	beq	80808c20 <vPolledQueueConsumer+0x70>
						portEXIT_CRITICAL();
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
80808c14:	e2855001 	add	r5, r5, #1
80808c18:	e6ff6075 	uxth	r6, r5
80808c1c:	eaffffea 	b	80808bcc <vPolledQueueConsumer+0x1c>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
80808c20:	e3570000 	cmp	r7, #0
80808c24:	1afffffa 	bne	80808c14 <vPolledQueueConsumer+0x64>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
80808c28:	ebffed34 	bl	80804100 <vTaskEnterCritical>
							xPollingConsumerCount++;
80808c2c:	e5983004 	ldr	r3, [r8, #4]
80808c30:	e2833001 	add	r3, r3, #1
80808c34:	e5883004 	str	r3, [r8, #4]
						portEXIT_CRITICAL();
80808c38:	ebffed3c 	bl	80804130 <vTaskExitCritical>
80808c3c:	eafffff4 	b	80808c14 <vPolledQueueConsumer+0x64>

80808c40 <vStartPolledQueueTasks>:
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
80808c40:	e92d4070 	push	{r4, r5, r6, lr}
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80808c44:	e30840c8 	movw	r4, #32968	; 0x80c8
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
80808c48:	e24dd008 	sub	sp, sp, #8
80808c4c:	e1a05000 	mov	r5, r0
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80808c50:	e3484101 	movt	r4, #33025	; 0x8101
80808c54:	e3a02000 	mov	r2, #0
80808c58:	e3a01002 	mov	r1, #2
80808c5c:	e3a0000a 	mov	r0, #10
80808c60:	ebffddad 	bl	8080031c <xQueueGenericCreate>
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( const char * const ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
80808c64:	e3a06000 	mov	r6, #0
void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
80808c68:	e5a40008 	str	r0, [r4, #8]!
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( const char * const ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
80808c6c:	e3091ba8 	movw	r1, #39848	; 0x9ba8
80808c70:	e3080bb0 	movw	r0, #35760	; 0x8bb0
80808c74:	e1a03004 	mov	r3, r4
80808c78:	e58d5000 	str	r5, [sp]
80808c7c:	e58d6004 	str	r6, [sp, #4]
80808c80:	e3481080 	movt	r1, #32896	; 0x8080
80808c84:	e3a02b01 	mov	r2, #1024	; 0x400
80808c88:	e3480080 	movt	r0, #32896	; 0x8080
80808c8c:	ebffe33e 	bl	8080198c <xTaskCreate>
	xTaskCreate( vPolledQueueProducer, ( const char * const ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
80808c90:	e3091bb0 	movw	r1, #39856	; 0x9bb0
80808c94:	e3080b24 	movw	r0, #35620	; 0x8b24
80808c98:	e1a03004 	mov	r3, r4
80808c9c:	e88d0060 	stm	sp, {r5, r6}
80808ca0:	e3481080 	movt	r1, #32896	; 0x8080
80808ca4:	e3a02b01 	mov	r2, #1024	; 0x400
80808ca8:	e3480080 	movt	r0, #32896	; 0x8080
80808cac:	ebffe336 	bl	8080198c <xTaskCreate>
}
80808cb0:	e28dd008 	add	sp, sp, #8
80808cb4:	e8bd8070 	pop	{r4, r5, r6, pc}

80808cb8 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
80808cb8:	e30830c8 	movw	r3, #32968	; 0x80c8
80808cbc:	e3483101 	movt	r3, #33025	; 0x8101
80808cc0:	e5930004 	ldr	r0, [r3, #4]
80808cc4:	e3500000 	cmp	r0, #0
80808cc8:	0a000002 	beq	80808cd8 <xArePollingQueuesStillRunning+0x20>
		( xPollingProducerCount == pollqINITIAL_VALUE )
80808ccc:	e5930000 	ldr	r0, [r3]
	  )
	{
		xReturn = pdFALSE;
80808cd0:	e2900000 	adds	r0, r0, #0
80808cd4:	13a00001 	movne	r0, #1
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
80808cd8:	e3a02000 	mov	r2, #0
80808cdc:	e5832004 	str	r2, [r3, #4]
	xPollingProducerCount = pollqINITIAL_VALUE;
80808ce0:	e5832000 	str	r2, [r3]

	return xReturn;
}
80808ce4:	e12fff1e 	bx	lr

80808ce8 <prvHighestPriorityPeekTask>:
	xTaskCreate( prvHighestPriorityPeekTask, ( const char * const )"PeekH2", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGHEST_PRIORITY, &xHighestPriorityTask );
}
/*-----------------------------------------------------------*/

static void prvHighestPriorityPeekTask( void *pvParameters )
{
80808ce8:	e92d43f0 	push	{r4, r5, r6, r7, r8, r9, lr}
80808cec:	e30840d4 	movw	r4, #32980	; 0x80d4
		be blocked on the queue.  We unblocked because the low priority task
		wrote a value to the queue, which we should have peeked.  Peeking the
		data (rather than receiving it) will leave the data on the queue, so
		the high priority task should then have also been unblocked, but not
		yet executed. */
		if( ulValue != 0x11223344 )
80808cf0:	e3037344 	movw	r7, #13124	; 0x3344
			xErrorDetected = pdTRUE;
		}

		/* When we get here the low priority task should have again written to the
		queue. */
		if( ulValue != 0x01234567 )
80808cf4:	e3048567 	movw	r8, #17767	; 0x4567
	xTaskCreate( prvHighestPriorityPeekTask, ( const char * const )"PeekH2", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGHEST_PRIORITY, &xHighestPriorityTask );
}
/*-----------------------------------------------------------*/

static void prvHighestPriorityPeekTask( void *pvParameters )
{
80808cf8:	e24dd00c 	sub	sp, sp, #12
80808cfc:	e1a06000 	mov	r6, r0
80808d00:	e3484101 	movt	r4, #33025	; 0x8101
		be blocked on the queue.  We unblocked because the low priority task
		wrote a value to the queue, which we should have peeked.  Peeking the
		data (rather than receiving it) will leave the data on the queue, so
		the high priority task should then have also been unblocked, but not
		yet executed. */
		if( ulValue != 0x11223344 )
80808d04:	e3417122 	movt	r7, #4386	; 0x1122
			xErrorDetected = pdTRUE;
		}

		/* When we get here the low priority task should have again written to the
		queue. */
		if( ulValue != 0x01234567 )
80808d08:	e3408123 	movt	r8, #291	; 0x123

	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the high priority task to execute. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d0c:	e3a05001 	mov	r5, #1
		}

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
80808d10:	e3a09000 	mov	r9, #0

	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the high priority task to execute. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d14:	e28d1004 	add	r1, sp, #4
80808d18:	e3e02000 	mvn	r2, #0
80808d1c:	e3a03001 	mov	r3, #1
80808d20:	e1a00006 	mov	r0, r6
80808d24:	ebffe086 	bl	80800f44 <xQueueGenericReceive>
		be blocked on the queue.  We unblocked because the low priority task
		wrote a value to the queue, which we should have peeked.  Peeking the
		data (rather than receiving it) will leave the data on the queue, so
		the high priority task should then have also been unblocked, but not
		yet executed. */
		if( ulValue != 0x11223344 )
80808d28:	e59d3004 	ldr	r3, [sp, #4]

	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the high priority task to execute. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d2c:	e3500001 	cmp	r0, #1
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
80808d30:	15845000 	strne	r5, [r4]
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808d34:	e1a00006 	mov	r0, r6
		be blocked on the queue.  We unblocked because the low priority task
		wrote a value to the queue, which we should have peeked.  Peeking the
		data (rather than receiving it) will leave the data on the queue, so
		the high priority task should then have also been unblocked, but not
		yet executed. */
		if( ulValue != 0x11223344 )
80808d38:	e1530007 	cmp	r3, r7
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
80808d3c:	15845000 	strne	r5, [r4]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808d40:	ebffe28e 	bl	80801780 <uxQueueMessagesWaiting>

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808d44:	e3a03000 	mov	r3, #0
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808d48:	e3500001 	cmp	r0, #1

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808d4c:	e28d1004 	add	r1, sp, #4
80808d50:	e1a02003 	mov	r2, r3
80808d54:	e1a00006 	mov	r0, r6
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
80808d58:	15845000 	strne	r5, [r4]
		}

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
80808d5c:	e58d9004 	str	r9, [sp, #4]
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808d60:	ebffe077 	bl	80800f44 <xQueueGenericReceive>
		{
			/* We expected to receive the value. */
			xErrorDetected = pdTRUE;
		}

		if( ulValue != 0x11223344 )
80808d64:	e59d3004 	ldr	r3, [sp, #4]

		/* Now we are going to actually receive the data, so when the high
		priority task runs it will find the queue empty and return to the
		blocked state. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808d68:	e3500001 	cmp	r0, #1
			xErrorDetected = pdTRUE;
		}

		/* Now we will block again as the queue is once more empty.  The low 
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d6c:	e28d1004 	add	r1, sp, #4
		blocked state. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
		{
			/* We expected to receive the value. */
			xErrorDetected = pdTRUE;
80808d70:	15845000 	strne	r5, [r4]
			xErrorDetected = pdTRUE;
		}

		/* Now we will block again as the queue is once more empty.  The low 
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d74:	e3e02000 	mvn	r2, #0
80808d78:	e1a00006 	mov	r0, r6
		{
			/* We expected to receive the value. */
			xErrorDetected = pdTRUE;
		}

		if( ulValue != 0x11223344 )
80808d7c:	e1530007 	cmp	r3, r7
			xErrorDetected = pdTRUE;
		}

		/* Now we will block again as the queue is once more empty.  The low 
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d80:	e3a03001 	mov	r3, #1

		if( ulValue != 0x11223344 )
		{
			/* We did not receive the expected value - which should have been
			the same value as was peeked. */
			xErrorDetected = pdTRUE;
80808d84:	15845000 	strne	r5, [r4]
		}

		/* Now we will block again as the queue is once more empty.  The low 
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d88:	ebffe06d 	bl	80800f44 <xQueueGenericReceive>
			xErrorDetected = pdTRUE;
		}

		/* When we get here the low priority task should have again written to the
		queue. */
		if( ulValue != 0x01234567 )
80808d8c:	e59d3004 	ldr	r3, [sp, #4]
			xErrorDetected = pdTRUE;
		}

		/* Now we will block again as the queue is once more empty.  The low 
		priority task can then execute again. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808d90:	e3500001 	cmp	r0, #1
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
80808d94:	15845000 	strne	r5, [r4]
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808d98:	e1a00006 	mov	r0, r6
			xErrorDetected = pdTRUE;
		}

		/* When we get here the low priority task should have again written to the
		queue. */
		if( ulValue != 0x01234567 )
80808d9c:	e1530008 	cmp	r3, r8
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
80808da0:	15845000 	strne	r5, [r4]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808da4:	ebffe275 	bl	80801780 <uxQueueMessagesWaiting>
80808da8:	e3500001 	cmp	r0, #1

		/* We only peeked the data, so suspending ourselves now should enable
		the high priority task to also peek the data.  The high priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
80808dac:	e3a00000 	mov	r0, #0
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
80808db0:	15845000 	strne	r5, [r4]

		/* We only peeked the data, so suspending ourselves now should enable
		the high priority task to also peek the data.  The high priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
80808db4:	ebffe4df 	bl	80802138 <vTaskSuspend>


		/* This time we are going to do the same as the above test, but the
		high priority task is going to receive the data, rather than peek it.
		This means that the medium priority task should never peek the value. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808db8:	e3a03001 	mov	r3, #1
80808dbc:	e3e02000 	mvn	r2, #0
80808dc0:	e28d1004 	add	r1, sp, #4
80808dc4:	e1a00006 	mov	r0, r6
80808dc8:	ebffe05d 	bl	80800f44 <xQueueGenericReceive>
		{
			xErrorDetected = pdTRUE;
		}

		if( ulValue != 0xaabbaabb )
80808dcc:	e59d2004 	ldr	r2, [sp, #4]
80808dd0:	e30a3abb 	movw	r3, #43707	; 0xaabb


		/* This time we are going to do the same as the above test, but the
		high priority task is going to receive the data, rather than peek it.
		This means that the medium priority task should never peek the value. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808dd4:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
		}

		if( ulValue != 0xaabbaabb )
80808dd8:	e34a3abb 	movt	r3, #43707	; 0xaabb
		/* This time we are going to do the same as the above test, but the
		high priority task is going to receive the data, rather than peek it.
		This means that the medium priority task should never peek the value. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
80808ddc:	15845000 	strne	r5, [r4]
		if( ulValue != 0xaabbaabb )
		{
			xErrorDetected = pdTRUE;
		}

		vTaskSuspend( NULL );		
80808de0:	e3a00000 	mov	r0, #0
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
		}

		if( ulValue != 0xaabbaabb )
80808de4:	e1520003 	cmp	r2, r3
		{
			xErrorDetected = pdTRUE;
80808de8:	15845000 	strne	r5, [r4]
		}

		vTaskSuspend( NULL );		
80808dec:	ebffe4d1 	bl	80802138 <vTaskSuspend>
	}
80808df0:	eaffffc7 	b	80808d14 <prvHighestPriorityPeekTask+0x2c>

80808df4 <prvHighPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvHighPriorityPeekTask( void *pvParameters )
{
80808df4:	e92d4070 	push	{r4, r5, r6, lr}
80808df8:	e30840d4 	movw	r4, #32980	; 0x80d4
		}

		/* When we get here the highest priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
80808dfc:	e3046567 	movw	r6, #17767	; 0x4567
	}
}
/*-----------------------------------------------------------*/

static void prvHighPriorityPeekTask( void *pvParameters )
{
80808e00:	e24dd008 	sub	sp, sp, #8
80808e04:	e1a05000 	mov	r5, r0
80808e08:	e3484101 	movt	r4, #33025	; 0x8101
		}

		/* When we get here the highest priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
80808e0c:	e3406123 	movt	r6, #291	; 0x123
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the medium priority task to execute.  Both the high
		and highest priority tasks will then be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808e10:	e28d1004 	add	r1, sp, #4
80808e14:	e3a03001 	mov	r3, #1
80808e18:	e3e02000 	mvn	r2, #0
80808e1c:	e1a00005 	mov	r0, r5
80808e20:	ebffe047 	bl	80800f44 <xQueueGenericReceive>
80808e24:	e3500001 	cmp	r0, #1
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808e28:	e1a00005 	mov	r0, r5
		block, allowing the medium priority task to execute.  Both the high
		and highest priority tasks will then be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
80808e2c:	13a03001 	movne	r3, #1
80808e30:	15843000 	strne	r3, [r4]
		}

		/* When we get here the highest priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
80808e34:	e59d3004 	ldr	r3, [sp, #4]
80808e38:	e1530006 	cmp	r3, r6
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
80808e3c:	13a03001 	movne	r3, #1
80808e40:	15843000 	strne	r3, [r4]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808e44:	ebffe24d 	bl	80801780 <uxQueueMessagesWaiting>
80808e48:	e3500001 	cmp	r0, #1

		/* We only peeked the data, so suspending ourselves now should enable
		the medium priority task to also peek the data.  The medium priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
80808e4c:	e3a00000 	mov	r0, #0
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
80808e50:	13a03001 	movne	r3, #1
80808e54:	15843000 	strne	r3, [r4]

		/* We only peeked the data, so suspending ourselves now should enable
		the medium priority task to also peek the data.  The medium priority task
		will have been unblocked when we peeked the data as we left the data
		in the queue. */
		vTaskSuspend( NULL );
80808e58:	ebffe4b6 	bl	80802138 <vTaskSuspend>


		/* This time we are going actually receive the value, so the medium
		priority task will never peek the data - we removed it from the queue. */
		if( xQueueReceive( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808e5c:	e3a03000 	mov	r3, #0
80808e60:	e3e02000 	mvn	r2, #0
80808e64:	e28d1004 	add	r1, sp, #4
80808e68:	e1a00005 	mov	r0, r5
80808e6c:	ebffe034 	bl	80800f44 <xQueueGenericReceive>
80808e70:	e3500001 	cmp	r0, #1
		{
			xErrorDetected = pdTRUE;
		}

		if( ulValue != 0xaabbaabb )
80808e74:	e59d2004 	ldr	r2, [sp, #4]

		/* This time we are going actually receive the value, so the medium
		priority task will never peek the data - we removed it from the queue. */
		if( xQueueReceive( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
80808e78:	13a03001 	movne	r3, #1
		if( ulValue != 0xaabbaabb )
		{
			xErrorDetected = pdTRUE;
		}

		vTaskSuspend( NULL );				
80808e7c:	e3a00000 	mov	r0, #0

		/* This time we are going actually receive the value, so the medium
		priority task will never peek the data - we removed it from the queue. */
		if( xQueueReceive( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
		{
			xErrorDetected = pdTRUE;
80808e80:	15843000 	strne	r3, [r4]
		}

		if( ulValue != 0xaabbaabb )
80808e84:	e30a3abb 	movw	r3, #43707	; 0xaabb
80808e88:	e34a3abb 	movt	r3, #43707	; 0xaabb
80808e8c:	e1520003 	cmp	r2, r3
		{
			xErrorDetected = pdTRUE;
80808e90:	13a03001 	movne	r3, #1
80808e94:	15843000 	strne	r3, [r4]
		}

		vTaskSuspend( NULL );				
80808e98:	ebffe4a6 	bl	80802138 <vTaskSuspend>
	}
80808e9c:	eaffffdb 	b	80808e10 <prvHighPriorityPeekTask+0x1c>

80808ea0 <prvMediumPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityPeekTask( void *pvParameters )
{
80808ea0:	e92d40f0 	push	{r4, r5, r6, r7, lr}
80808ea4:	e30840d4 	movw	r4, #32980	; 0x80d4
		}

		/* When we get here the high priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
80808ea8:	e3047567 	movw	r7, #17767	; 0x4567
	}
}
/*-----------------------------------------------------------*/

static void prvMediumPriorityPeekTask( void *pvParameters )
{
80808eac:	e24dd00c 	sub	sp, sp, #12
80808eb0:	e1a06000 	mov	r6, r0
80808eb4:	e3484101 	movt	r4, #33025	; 0x8101
		}

		/* When we get here the high priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
80808eb8:	e3407123 	movt	r7, #291	; 0x123
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the low priority task to execute.  The highest, high
		and medium priority tasks will then all be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808ebc:	e3a05001 	mov	r5, #1
80808ec0:	e3e02000 	mvn	r2, #0
80808ec4:	e28d1004 	add	r1, sp, #4
80808ec8:	e3a03001 	mov	r3, #1
80808ecc:	e1a00006 	mov	r0, r6
80808ed0:	ebffe01b 	bl	80800f44 <xQueueGenericReceive>
		}

		/* When we get here the high priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
80808ed4:	e59d3004 	ldr	r3, [sp, #4]
	for( ;; )
	{
		/* Try peeking from the queue.  The queue should be empty so we will
		block, allowing the low priority task to execute.  The highest, high
		and medium priority tasks will then all be blocked on the queue. */
		if( xQueuePeek( xQueue, &ulValue, portMAX_DELAY ) != pdPASS )
80808ed8:	e3500001 	cmp	r0, #1
		{
			/* We expected to have received something by the time we unblock. */
			xErrorDetected = pdTRUE;
80808edc:	15845000 	strne	r5, [r4]
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808ee0:	e1a00006 	mov	r0, r6
		}

		/* When we get here the high priority task should have peeked the data
		(unblocking this task) then suspended (allowing this task to also peek
		the data). */
		if( ulValue != 0x01234567 )
80808ee4:	e1530007 	cmp	r3, r7
		{
			/* We did not receive the expected value. */
			xErrorDetected = pdTRUE;
80808ee8:	15845000 	strne	r5, [r4]
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
80808eec:	ebffe223 	bl	80801780 <uxQueueMessagesWaiting>
80808ef0:	e3500001 	cmp	r0, #1
		/* Just so we know the test is still running. */
		ulLoopCounter++;

		/* Now we can suspend ourselves so the low priority task can execute
		again. */
		vTaskSuspend( NULL );
80808ef4:	e3a00000 	mov	r0, #0
		}

		if( uxQueueMessagesWaiting( xQueue ) != 1 )
		{
			/* The message should have been left on the queue. */
			xErrorDetected = pdTRUE;
80808ef8:	15845000 	strne	r5, [r4]
		}

		/* Just so we know the test is still running. */
		ulLoopCounter++;
80808efc:	e5943004 	ldr	r3, [r4, #4]
80808f00:	e2833001 	add	r3, r3, #1
80808f04:	e5843004 	str	r3, [r4, #4]

		/* Now we can suspend ourselves so the low priority task can execute
		again. */
		vTaskSuspend( NULL );
80808f08:	ebffe48a 	bl	80802138 <vTaskSuspend>
	}
80808f0c:	eaffffeb 	b	80808ec0 <prvMediumPriorityPeekTask+0x20>

80808f10 <prvLowPriorityPeekTask>:
}
/*-----------------------------------------------------------*/

static void prvLowPriorityPeekTask( void *pvParameters )
{
80808f10:	e92d4ff0 	push	{r4, r5, r6, r7, r8, r9, sl, fp, lr}
80808f14:	e30850d4 	movw	r5, #32980	; 0x80d4
80808f18:	e308912c 	movw	r9, #33068	; 0x812c
80808f1c:	e3088128 	movw	r8, #33064	; 0x8128
80808f20:	e3087130 	movw	r7, #33072	; 0x8130

	for( ;; )
	{
		/* Write some data to the queue.  This should unblock the highest 
		priority task that is waiting to peek data from the queue. */
		ulValue = 0x11223344;
80808f24:	e303b344 	movw	fp, #13124	; 0x3344
			xErrorDetected = pdTRUE;
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
80808f28:	e304a567 	movw	sl, #17767	; 0x4567
	}
}
/*-----------------------------------------------------------*/

static void prvLowPriorityPeekTask( void *pvParameters )
{
80808f2c:	e24dd00c 	sub	sp, sp, #12
80808f30:	e1a04000 	mov	r4, r0
80808f34:	e3485101 	movt	r5, #33025	; 0x8101
80808f38:	e3489101 	movt	r9, #33025	; 0x8101
80808f3c:	e3488101 	movt	r8, #33025	; 0x8101
80808f40:	e3487101 	movt	r7, #33025	; 0x8101

	for( ;; )
	{
		/* Write some data to the queue.  This should unblock the highest 
		priority task that is waiting to peek data from the queue. */
		ulValue = 0x11223344;
80808f44:	e341b122 	movt	fp, #4386	; 0x1122
			xErrorDetected = pdTRUE;
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
80808f48:	e340a123 	movt	sl, #291	; 0x123
		ulValue = 0x11223344;
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
80808f4c:	e3a06001 	mov	r6, #1
	for( ;; )
	{
		/* Write some data to the queue.  This should unblock the highest 
		priority task that is waiting to peek data from the queue. */
		ulValue = 0x11223344;
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808f50:	e3a03000 	mov	r3, #0
80808f54:	e28d1004 	add	r1, sp, #4
80808f58:	e1a02003 	mov	r2, r3
80808f5c:	e1a00004 	mov	r0, r4

	for( ;; )
	{
		/* Write some data to the queue.  This should unblock the highest 
		priority task that is waiting to peek data from the queue. */
		ulValue = 0x11223344;
80808f60:	e58db004 	str	fp, [sp, #4]
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808f64:	ebffdd54 	bl	808004bc <xQueueGenericSend>
80808f68:	e3500001 	cmp	r0, #1
			xErrorDetected = pdTRUE;
		}

		/* By the time we get here the data should have been removed from
		the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808f6c:	e1a00004 	mov	r0, r4
		ulValue = 0x11223344;
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
80808f70:	15856000 	strne	r6, [r5]
		}

		/* By the time we get here the data should have been removed from
		the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808f74:	ebffe201 	bl	80801780 <uxQueueMessagesWaiting>
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808f78:	e3a03000 	mov	r3, #0
			xErrorDetected = pdTRUE;
		}

		/* By the time we get here the data should have been removed from
		the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
80808f7c:	e3500000 	cmp	r0, #0
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808f80:	e28d1004 	add	r1, sp, #4
80808f84:	e1a02003 	mov	r2, r3
80808f88:	e1a00004 	mov	r0, r4

		/* By the time we get here the data should have been removed from
		the queue. */
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
		{
			xErrorDetected = pdTRUE;
80808f8c:	15856000 	strne	r6, [r5]
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
80808f90:	e58da004 	str	sl, [sp, #4]
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808f94:	ebffdd48 	bl	808004bc <xQueueGenericSend>
		}

		/* All the other tasks should now have successfully peeked the data.
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808f98:	e3a03000 	mov	r3, #0
80808f9c:	e28d1004 	add	r1, sp, #4
80808fa0:	e1a02003 	mov	r2, r3
		}

		/* Write another value to the queue, again waking the highest priority
		task that is blocked on the queue. */
		ulValue = 0x01234567;
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808fa4:	e3500001 	cmp	r0, #1
		}

		/* All the other tasks should now have successfully peeked the data.
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808fa8:	e1a00004 	mov	r0, r4
			xErrorDetected = pdTRUE;
		}

		/* All the other tasks should now have successfully peeked the data.
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
80808fac:	e58d3004 	str	r3, [sp, #4]
		ulValue = 0x01234567;
		if( xQueueSendToBack( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
80808fb0:	15856000 	strne	r6, [r5]
		}

		/* All the other tasks should now have successfully peeked the data.
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808fb4:	ebffdfe2 	bl	80800f44 <xQueueGenericReceive>
80808fb8:	e3500001 	cmp	r0, #1
			/* We did not receive the expected value. */
		}
		
		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
80808fbc:	e3a0000a 	mov	r0, #10
		The data is still in the queue so we should be able to receive it. */
		ulValue = 0;
		if( xQueueReceive( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
80808fc0:	15856000 	strne	r6, [r5]
			/* We did not receive the expected value. */
		}
		
		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
80808fc4:	ebffe823 	bl	80803058 <vTaskDelay>
		/* Unsuspend the other tasks so we can repeat the test - this time
		however not all the other tasks will peek the data as the high
		priority task is actually going to remove it from the queue.  Send
		to front is used just to be different.  As the queue is empty it
		makes no difference to the result. */
		vTaskResume( xMediumPriorityTask );
80808fc8:	e5990000 	ldr	r0, [r9]
80808fcc:	ebffe596 	bl	8080262c <vTaskResume>
		vTaskResume( xHighPriorityTask );
80808fd0:	e5980000 	ldr	r0, [r8]
80808fd4:	ebffe594 	bl	8080262c <vTaskResume>
		vTaskResume( xHighestPriorityTask );
80808fd8:	e5970000 	ldr	r0, [r7]
80808fdc:	ebffe592 	bl	8080262c <vTaskResume>

		ulValue = 0xaabbaabb;
80808fe0:	e30acabb 	movw	ip, #43707	; 0xaabb
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808fe4:	e28d1004 	add	r1, sp, #4
		makes no difference to the result. */
		vTaskResume( xMediumPriorityTask );
		vTaskResume( xHighPriorityTask );
		vTaskResume( xHighestPriorityTask );

		ulValue = 0xaabbaabb;
80808fe8:	e7dfc81c 	bfi	ip, ip, #16, #16
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808fec:	e3a03001 	mov	r3, #1
80808ff0:	e3a02000 	mov	r2, #0
80808ff4:	e1a00004 	mov	r0, r4
		makes no difference to the result. */
		vTaskResume( xMediumPriorityTask );
		vTaskResume( xHighPriorityTask );
		vTaskResume( xHighestPriorityTask );

		ulValue = 0xaabbaabb;
80808ff8:	e58dc004 	str	ip, [sp, #4]
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80808ffc:	ebffdd2e 	bl	808004bc <xQueueGenericSend>
			xErrorDetected = pdTRUE;
		}

		/* This time we should find that the queue is empty.  The high priority
		task actually removed the data rather than just peeking it. */
		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
80809000:	e3a03001 	mov	r3, #1
		vTaskResume( xMediumPriorityTask );
		vTaskResume( xHighPriorityTask );
		vTaskResume( xHighestPriorityTask );

		ulValue = 0xaabbaabb;
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
80809004:	e3500001 	cmp	r0, #1
			xErrorDetected = pdTRUE;
		}

		/* This time we should find that the queue is empty.  The high priority
		task actually removed the data rather than just peeking it. */
		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
80809008:	e3a02000 	mov	r2, #0
8080900c:	e28d1004 	add	r1, sp, #4
80809010:	e1a00004 	mov	r0, r4
		ulValue = 0xaabbaabb;
		if( xQueueSendToFront( xQueue, &ulValue, qpeekNO_BLOCK ) != pdPASS )
		{
			/* We were expecting the queue to be empty so we should not of
			had a problem writing to the queue. */
			xErrorDetected = pdTRUE;
80809014:	15856000 	strne	r6, [r5]
		}

		/* This time we should find that the queue is empty.  The high priority
		task actually removed the data rather than just peeking it. */
		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
80809018:	ebffdfc9 	bl	80800f44 <xQueueGenericReceive>
8080901c:	e3500000 	cmp	r0, #0
		}

		/* Unsuspend the highest and high priority tasks so we can go back
		and repeat the whole thing.  The medium priority task should not be
		suspended as it was not able to peek the data in this last case. */
		vTaskResume( xHighPriorityTask );
80809020:	e5980000 	ldr	r0, [r8]
		/* This time we should find that the queue is empty.  The high priority
		task actually removed the data rather than just peeking it. */
		if( xQueuePeek( xQueue, &ulValue, qpeekNO_BLOCK ) != errQUEUE_EMPTY )
		{
			/* We expected to receive the data. */
			xErrorDetected = pdTRUE;
80809024:	15856000 	strne	r6, [r5]
		}

		/* Unsuspend the highest and high priority tasks so we can go back
		and repeat the whole thing.  The medium priority task should not be
		suspended as it was not able to peek the data in this last case. */
		vTaskResume( xHighPriorityTask );
80809028:	ebffe57f 	bl	8080262c <vTaskResume>
		vTaskResume( xHighestPriorityTask );		
8080902c:	e5970000 	ldr	r0, [r7]
80809030:	ebffe57d 	bl	8080262c <vTaskResume>

		/* Lets just delay a while as this is an intensive test as we don't
		want to starve other tests of processing time. */
		vTaskDelay( qpeekSHORT_DELAY );
80809034:	e3a0000a 	mov	r0, #10
80809038:	ebffe806 	bl	80803058 <vTaskDelay>
	}
8080903c:	eaffffc3 	b	80808f50 <prvLowPriorityPeekTask+0x40>

80809040 <vStartQueuePeekTasks>:
/* Handles to the test tasks. */
xTaskHandle xMediumPriorityTask, xHighPriorityTask, xHighestPriorityTask;
/*-----------------------------------------------------------*/

void vStartQueuePeekTasks( void )
{
80809040:	e92d4010 	push	{r4, lr}
xQueueHandle xQueue;

	/* Create the queue that we are going to use for the test/demo. */
	xQueue = xQueueCreate( qpeekQUEUE_LENGTH, sizeof( unsigned portLONG ) );
80809044:	e3a02000 	mov	r2, #0
/* Handles to the test tasks. */
xTaskHandle xMediumPriorityTask, xHighPriorityTask, xHighestPriorityTask;
/*-----------------------------------------------------------*/

void vStartQueuePeekTasks( void )
{
80809048:	e24dd008 	sub	sp, sp, #8
xQueueHandle xQueue;

	/* Create the queue that we are going to use for the test/demo. */
	xQueue = xQueueCreate( qpeekQUEUE_LENGTH, sizeof( unsigned portLONG ) );
8080904c:	e3a01004 	mov	r1, #4
80809050:	e3a00005 	mov	r0, #5
80809054:	ebffdcb0 	bl	8080031c <xQueueGenericCreate>
	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "QPeek_Test_Queue" );

	/* Create the demo tasks and pass it the queue just created.  We are
	passing the queue handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityPeekTask, ( const char * const )"PeekL", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekLOW_PRIORITY, NULL );
80809058:	e3a02000 	mov	r2, #0
void vStartQueuePeekTasks( void )
{
xQueueHandle xQueue;

	/* Create the queue that we are going to use for the test/demo. */
	xQueue = xQueueCreate( qpeekQUEUE_LENGTH, sizeof( unsigned portLONG ) );
8080905c:	e1a04000 	mov	r4, r0
	vQueueAddToRegistry( xQueue, ( signed portCHAR * ) "QPeek_Test_Queue" );

	/* Create the demo tasks and pass it the queue just created.  We are
	passing the queue handle by value so it does not matter that it is declared
	on the stack here. */
	xTaskCreate( prvLowPriorityPeekTask, ( const char * const )"PeekL", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekLOW_PRIORITY, NULL );
80809060:	e3091bb8 	movw	r1, #39864	; 0x9bb8
80809064:	e3080f10 	movw	r0, #36624	; 0x8f10
80809068:	e1a03004 	mov	r3, r4
8080906c:	e58d2004 	str	r2, [sp, #4]
80809070:	e58d2000 	str	r2, [sp]
80809074:	e3481080 	movt	r1, #32896	; 0x8080
80809078:	e3a02b01 	mov	r2, #1024	; 0x400
8080907c:	e3480080 	movt	r0, #32896	; 0x8080
80809080:	ebffe241 	bl	8080198c <xTaskCreate>
	xTaskCreate( prvMediumPriorityPeekTask, ( const char * const )"PeekM", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekMEDIUM_PRIORITY, &xMediumPriorityTask );
80809084:	e308312c 	movw	r3, #33068	; 0x812c
80809088:	e3a02001 	mov	r2, #1
8080908c:	e3483101 	movt	r3, #33025	; 0x8101
80809090:	e3091bc0 	movw	r1, #39872	; 0x9bc0
80809094:	e3080ea0 	movw	r0, #36512	; 0x8ea0
80809098:	e58d3004 	str	r3, [sp, #4]
8080909c:	e58d2000 	str	r2, [sp]
808090a0:	e1a03004 	mov	r3, r4
808090a4:	e3481080 	movt	r1, #32896	; 0x8080
808090a8:	e3a02b01 	mov	r2, #1024	; 0x400
808090ac:	e3480080 	movt	r0, #32896	; 0x8080
808090b0:	ebffe235 	bl	8080198c <xTaskCreate>
	xTaskCreate( prvHighPriorityPeekTask, ( const char * const )"PeekH1", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGH_PRIORITY, &xHighPriorityTask );
808090b4:	e3083128 	movw	r3, #33064	; 0x8128
808090b8:	e3a02002 	mov	r2, #2
808090bc:	e3483101 	movt	r3, #33025	; 0x8101
808090c0:	e3091bc8 	movw	r1, #39880	; 0x9bc8
808090c4:	e3080df4 	movw	r0, #36340	; 0x8df4
808090c8:	e58d3004 	str	r3, [sp, #4]
808090cc:	e58d2000 	str	r2, [sp]
808090d0:	e1a03004 	mov	r3, r4
808090d4:	e3481080 	movt	r1, #32896	; 0x8080
808090d8:	e3a02b01 	mov	r2, #1024	; 0x400
808090dc:	e3480080 	movt	r0, #32896	; 0x8080
808090e0:	ebffe229 	bl	8080198c <xTaskCreate>
	xTaskCreate( prvHighestPriorityPeekTask, ( const char * const )"PeekH2", configMINIMAL_STACK_SIZE, ( void * ) xQueue, qpeekHIGHEST_PRIORITY, &xHighestPriorityTask );
808090e4:	e3082130 	movw	r2, #33072	; 0x8130
808090e8:	e3a0c003 	mov	ip, #3
808090ec:	e3482101 	movt	r2, #33025	; 0x8101
808090f0:	e3091bd0 	movw	r1, #39888	; 0x9bd0
808090f4:	e3080ce8 	movw	r0, #36072	; 0x8ce8
808090f8:	e58d2004 	str	r2, [sp, #4]
808090fc:	e1a03004 	mov	r3, r4
80809100:	e3481080 	movt	r1, #32896	; 0x8080
80809104:	e58dc000 	str	ip, [sp]
80809108:	e3a02b01 	mov	r2, #1024	; 0x400
8080910c:	e3480080 	movt	r0, #32896	; 0x8080
80809110:	ebffe21d 	bl	8080198c <xTaskCreate>
}
80809114:	e28dd008 	add	sp, sp, #8
80809118:	e8bd8010 	pop	{r4, pc}

8080911c <xAreQueuePeekTasksStillRunning>:
{
static unsigned portLONG ulLastLoopCounter = 0;

	/* If the demo task is still running then we expect the loopcounter to
	have incremented since this function was last called. */
	if( ulLastLoopCounter == ulLoopCounter )
8080911c:	e30830d4 	movw	r3, #32980	; 0x80d4
80809120:	e3483101 	movt	r3, #33025	; 0x8101
80809124:	e5932004 	ldr	r2, [r3, #4]
80809128:	e5931008 	ldr	r1, [r3, #8]
8080912c:	e1510002 	cmp	r1, r2
	{
		xErrorDetected = pdTRUE;
80809130:	03a02001 	moveq	r2, #1
80809134:	05832000 	streq	r2, [r3]
	}

	ulLastLoopCounter = ulLoopCounter;
80809138:	e5932004 	ldr	r2, [r3, #4]

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return !xErrorDetected;
8080913c:	e5930000 	ldr	r0, [r3]
	if( ulLastLoopCounter == ulLoopCounter )
	{
		xErrorDetected = pdTRUE;
	}

	ulLastLoopCounter = ulLoopCounter;
80809140:	e5832008 	str	r2, [r3, #8]

	/* Errors detected in the task itself will have latched xErrorDetected
	to true. */

	return !xErrorDetected;
}
80809144:	e16f0f10 	clz	r0, r0
80809148:	e1a002a0 	lsr	r0, r0, #5
8080914c:	e12fff1e 	bx	lr

80809150 <prvRecursiveMutexPollingTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexPollingTask( void *pvParameters )
{
80809150:	e30840e0 	movw	r4, #32992	; 0x80e0
80809154:	e92d4080 	push	{r7, lr}
80809158:	e3484101 	movt	r4, #33025	; 0x8101
		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
		{
			/* Is the blocking task suspended? */
			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
			{
				xErrorOccurred = pdTRUE;
8080915c:	e3a06001 	mov	r6, #1
	for( ;; )
	{
		/* Keep attempting to obtain the mutex.  We should only obtain it when
		the blocking task has suspended itself, which in turn should only
		happen when the controlling task is also suspended. */
		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
80809160:	e1a07004 	mov	r7, r4
80809164:	e1a05004 	mov	r5, r4
80809168:	e3a01000 	mov	r1, #0
8080916c:	e5940000 	ldr	r0, [r4]
80809170:	ebffe0f4 	bl	80801548 <xQueueTakeMutexRecursive>
80809174:	e3500001 	cmp	r0, #1
80809178:	1afffffa 	bne	80809168 <prvRecursiveMutexPollingTask+0x18>
		{
			/* Is the blocking task suspended? */
			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
8080917c:	e5953004 	ldr	r3, [r5, #4]
80809180:	e3530001 	cmp	r3, #1
80809184:	0a000001 	beq	80809190 <prvRecursiveMutexPollingTask+0x40>
			{
				xErrorOccurred = pdTRUE;
80809188:	e584600c 	str	r6, [r4, #12]
8080918c:	eafffff5 	b	80809168 <prvRecursiveMutexPollingTask+0x18>
		the blocking task has suspended itself, which in turn should only
		happen when the controlling task is also suspended. */
		if( xSemaphoreTakeRecursive( xMutex, recmuNO_DELAY ) == pdPASS )
		{
			/* Is the blocking task suspended? */
			if( ( xBlockingIsSuspended != pdTRUE ) || ( xControllingIsSuspended != pdTRUE ) )
80809190:	e5953008 	ldr	r3, [r5, #8]
80809194:	e3530001 	cmp	r3, #1
80809198:	1afffffa 	bne	80809188 <prvRecursiveMutexPollingTask+0x38>
			}
			else
			{
				/* Keep count of the number of cycles this task has performed 
				so a stall can be detected. */
				uxPollingCycles++;
8080919c:	e5953010 	ldr	r3, [r5, #16]
				will then inherit the higher priority.  The Blocking task will
				block indefinitely when it attempts to obtain the mutex, the
				Controlling task will only block for a fixed period and an
				error will be latched if the polling task has not returned the
				mutex by the time this fixed period has expired. */
				vTaskResume( xBlockingTaskHandle );
808091a0:	e5950014 	ldr	r0, [r5, #20]
			}
			else
			{
				/* Keep count of the number of cycles this task has performed 
				so a stall can be detected. */
				uxPollingCycles++;
808091a4:	e2833001 	add	r3, r3, #1
808091a8:	e5853010 	str	r3, [r5, #16]
				will then inherit the higher priority.  The Blocking task will
				block indefinitely when it attempts to obtain the mutex, the
				Controlling task will only block for a fixed period and an
				error will be latched if the polling task has not returned the
				mutex by the time this fixed period has expired. */
				vTaskResume( xBlockingTaskHandle );
808091ac:	ebffe51e 	bl	8080262c <vTaskResume>
                vTaskResume( xControllingTaskHandle );
808091b0:	e5950018 	ldr	r0, [r5, #24]
808091b4:	ebffe51c 	bl	8080262c <vTaskResume>
			
				/* The other two tasks should now have executed and no longer
				be suspended. */
				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
808091b8:	e5953004 	ldr	r3, [r5, #4]
808091bc:	e3530001 	cmp	r3, #1
808091c0:	0a000007 	beq	808091e4 <prvRecursiveMutexPollingTask+0x94>
808091c4:	e5953008 	ldr	r3, [r5, #8]
808091c8:	e3530001 	cmp	r3, #1
808091cc:	0a000004 	beq	808091e4 <prvRecursiveMutexPollingTask+0x94>
				{
					xErrorOccurred = pdTRUE;
				}				
			
				/* Release the mutex, disinheriting the higher priority again. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
808091d0:	e5940000 	ldr	r0, [r4]
808091d4:	ebffde8a 	bl	80800c04 <xQueueGiveMutexRecursive>
808091d8:	e3500001 	cmp	r0, #1
				{
					xErrorOccurred = pdTRUE;
808091dc:	1587600c 	strne	r6, [r7, #12]
808091e0:	eaffffe0 	b	80809168 <prvRecursiveMutexPollingTask+0x18>
			
				/* The other two tasks should now have executed and no longer
				be suspended. */
				if( ( xBlockingIsSuspended == pdTRUE ) || ( xControllingIsSuspended == pdTRUE ) )
				{
					xErrorOccurred = pdTRUE;
808091e4:	e584600c 	str	r6, [r4, #12]
808091e8:	eafffff8 	b	808091d0 <prvRecursiveMutexPollingTask+0x80>

808091ec <prvRecursiveMutexBlockingTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexBlockingTask( void *pvParameters )
{
808091ec:	e30840e0 	movw	r4, #32992	; 0x80e0
808091f0:	e92d4080 	push	{r7, lr}
808091f4:	e3484101 	movt	r4, #33025	; 0x8101
		}
		else
		{
			/* We should not leave the xSemaphoreTakeRecursive() function
			until the mutex was obtained. */
			xErrorOccurred = pdTRUE;
808091f8:	e3a06001 	mov	r6, #1
		/* This task will run while the controlling task is blocked, and the
		controlling task will block only once it has the mutex - therefore
		this call should block until the controlling task has given up the 
		mutex, and not actually execute	past this call until the controlling 
		task is suspended. */
		if( xSemaphoreTakeRecursive( xMutex, portMAX_DELAY ) == pdPASS )
808091fc:	e1a05004 	mov	r5, r4
80809200:	ea000007 	b	80809224 <prvRecursiveMutexBlockingTask+0x38>
			until the mutex was obtained. */
			xErrorOccurred = pdTRUE;
		}

		/* The controlling and blocking tasks should be in lock step. */
		if( uxControllingCycles != ( uxBlockingCycles + 1 ) )
80809204:	e594301c 	ldr	r3, [r4, #28]
80809208:	e5942020 	ldr	r2, [r4, #32]
8080920c:	e2833001 	add	r3, r3, #1
80809210:	e1530002 	cmp	r3, r2
		{
			xErrorOccurred = pdTRUE;
80809214:	1585600c 	strne	r6, [r5, #12]
		}

		/* Keep count of the number of cycles this task has performed so a 
		stall can be detected. */
		uxBlockingCycles++;
80809218:	e594301c 	ldr	r3, [r4, #28]
8080921c:	e2833001 	add	r3, r3, #1
80809220:	e584301c 	str	r3, [r4, #28]
		/* This task will run while the controlling task is blocked, and the
		controlling task will block only once it has the mutex - therefore
		this call should block until the controlling task has given up the 
		mutex, and not actually execute	past this call until the controlling 
		task is suspended. */
		if( xSemaphoreTakeRecursive( xMutex, portMAX_DELAY ) == pdPASS )
80809224:	e3e01000 	mvn	r1, #0
80809228:	e5940000 	ldr	r0, [r4]
8080922c:	ebffe0c5 	bl	80801548 <xQueueTakeMutexRecursive>
80809230:	e3500001 	cmp	r0, #1
		}
		else
		{
			/* We should not leave the xSemaphoreTakeRecursive() function
			until the mutex was obtained. */
			xErrorOccurred = pdTRUE;
80809234:	1585600c 	strne	r6, [r5, #12]
		/* This task will run while the controlling task is blocked, and the
		controlling task will block only once it has the mutex - therefore
		this call should block until the controlling task has given up the 
		mutex, and not actually execute	past this call until the controlling 
		task is suspended. */
		if( xSemaphoreTakeRecursive( xMutex, portMAX_DELAY ) == pdPASS )
80809238:	1afffff1 	bne	80809204 <prvRecursiveMutexBlockingTask+0x18>
		{
			if( xControllingIsSuspended != pdTRUE )
8080923c:	e5957008 	ldr	r7, [r5, #8]
80809240:	e3570001 	cmp	r7, #1
			{
				/* Did not expect to execute until the controlling task was
				suspended. */
				xErrorOccurred = pdTRUE;
80809244:	1585000c 	strne	r0, [r5, #12]
		this call should block until the controlling task has given up the 
		mutex, and not actually execute	past this call until the controlling 
		task is suspended. */
		if( xSemaphoreTakeRecursive( xMutex, portMAX_DELAY ) == pdPASS )
		{
			if( xControllingIsSuspended != pdTRUE )
80809248:	1affffed 	bne	80809204 <prvRecursiveMutexBlockingTask+0x18>
			}
			else
			{
				/* Give the mutex back before suspending ourselves to allow
				the polling task to obtain the mutex. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
8080924c:	e5950000 	ldr	r0, [r5]
80809250:	ebffde6b 	bl	80800c04 <xQueueGiveMutexRecursive>
80809254:	e3500001 	cmp	r0, #1
				{
					xErrorOccurred = pdTRUE;
				}

				xBlockingIsSuspended = pdTRUE;
				vTaskSuspend( NULL );
80809258:	e3a00000 	mov	r0, #0
			{
				/* Give the mutex back before suspending ourselves to allow
				the polling task to obtain the mutex. */
				if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
				{
					xErrorOccurred = pdTRUE;
8080925c:	1585700c 	strne	r7, [r5, #12]
				}

				xBlockingIsSuspended = pdTRUE;
80809260:	e5846004 	str	r6, [r4, #4]
				vTaskSuspend( NULL );
80809264:	ebffe3b3 	bl	80802138 <vTaskSuspend>
				xBlockingIsSuspended = pdFALSE;
80809268:	e3a03000 	mov	r3, #0
8080926c:	e5843004 	str	r3, [r4, #4]
80809270:	eaffffe3 	b	80809204 <prvRecursiveMutexBlockingTask+0x18>

80809274 <prvRecursiveMutexControllingTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexControllingTask( void *pvParameters )
{
80809274:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
80809278:	e30850e0 	movw	r5, #32992	; 0x80e0
8080927c:	e3485101 	movt	r5, #33025	; 0x8101
			long enough to ensure the polling task will execute again before the
			block time expires.  If the block time does expire then the error
			flag will be set here. */
			if( xSemaphoreTakeRecursive( xMutex, recmuTWO_TICK_DELAY ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
80809280:	e3a06001 	mov	r6, #1
	{
		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
		it.   The first time through, the mutex will not have been used yet,
		subsequent times through, at this point the mutex will be held by the
		polling task. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
80809284:	e1a07005 	mov	r7, r5
80809288:	e5950000 	ldr	r0, [r5]
	}
}
/*-----------------------------------------------------------*/

static void prvRecursiveMutexControllingTask( void *pvParameters )
{
8080928c:	e3a0400a 	mov	r4, #10
	{
		/* Should not be able to 'give' the mutex, as we have not yet 'taken'
		it.   The first time through, the mutex will not have been used yet,
		subsequent times through, at this point the mutex will be held by the
		polling task. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
80809290:	ebffde5b 	bl	80800c04 <xQueueGiveMutexRecursive>
80809294:	e3500001 	cmp	r0, #1
		{
			xErrorOccurred = pdTRUE;
80809298:	0587000c 	streq	r0, [r7, #12]
			at this point and this Take will cause the polling task to inherit
			the priority of this task.  In this case the block time must be
			long enough to ensure the polling task will execute again before the
			block time expires.  If the block time does expire then the error
			flag will be set here. */
			if( xSemaphoreTakeRecursive( xMutex, recmuTWO_TICK_DELAY ) != pdPASS )
8080929c:	e3a01002 	mov	r1, #2
808092a0:	e5950000 	ldr	r0, [r5]
808092a4:	ebffe0a7 	bl	80801548 <xQueueTakeMutexRecursive>
808092a8:	e3500001 	cmp	r0, #1

			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute to ensure they either block
			(where a block time is specified) or return an error (where no 
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
808092ac:	e3a00014 	mov	r0, #20
			long enough to ensure the polling task will execute again before the
			block time expires.  If the block time does expire then the error
			flag will be set here. */
			if( xSemaphoreTakeRecursive( xMutex, recmuTWO_TICK_DELAY ) != pdPASS )
			{
				xErrorOccurred = pdTRUE;
808092b0:	1587600c 	strne	r6, [r7, #12]

			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute to ensure they either block
			(where a block time is specified) or return an error (where no 
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
808092b4:	ebffe767 	bl	80803058 <vTaskDelay>
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
		{
			xErrorOccurred = pdTRUE;
		}

		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
808092b8:	e2544001 	subs	r4, r4, #1
808092bc:	1afffff6 	bne	8080929c <prvRecursiveMutexControllingTask+0x28>
808092c0:	e3a0400a 	mov	r4, #10
		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
		{
			/* Ensure the other task attempting to access the mutex (and the
			other demo tasks) are able to execute. */
			vTaskDelay( recmuSHORT_DELAY );
808092c4:	e3a00014 	mov	r0, #20
808092c8:	ebffe762 	bl	80803058 <vTaskDelay>
			/* We should now be able to give the mutex as many times as we
			took it.  When the mutex is available again the Blocking task
			should be unblocked but not run because it has a lower priority
			than this task.  The polling task should also not run at this point
			as it too has a lower priority than this task. */
			if( xSemaphoreGiveRecursive( xMutex ) != pdPASS )
808092cc:	e5950000 	ldr	r0, [r5]
808092d0:	ebffde4b 	bl	80800c04 <xQueueGiveMutexRecursive>
808092d4:	e3500001 	cmp	r0, #1
			{
				xErrorOccurred = pdTRUE;
808092d8:	1587600c 	strne	r6, [r7, #12]
			block time is specified) as the mutex is held by this task. */
			vTaskDelay( recmuSHORT_DELAY );
		}

		/* For each time we took the mutex, give it back. */
		for( ux = 0; ux < recmuMAX_COUNT; ux++ )
808092dc:	e2544001 	subs	r4, r4, #1
808092e0:	1afffff7 	bne	808092c4 <prvRecursiveMutexControllingTask+0x50>
			}
		}

		/* Having given it back the same number of times as it was taken, we
		should no longer be the mutex owner, so the next give sh ould fail. */
		if( xSemaphoreGiveRecursive( xMutex ) == pdPASS )
808092e4:	e5950000 	ldr	r0, [r5]
808092e8:	ebffde45 	bl	80800c04 <xQueueGiveMutexRecursive>
808092ec:	e3500001 	cmp	r0, #1
		{
			xErrorOccurred = pdTRUE;
808092f0:	0587000c 	streq	r0, [r7, #12]
		stall can be detected. */
		uxControllingCycles++;

		/* Suspend ourselves to the blocking task can execute. */
		xControllingIsSuspended = pdTRUE;
		vTaskSuspend( NULL );
808092f4:	e3a00000 	mov	r0, #0
			xErrorOccurred = pdTRUE;
		}

		/* Keep count of the number of cycles this task has performed so a 
		stall can be detected. */
		uxControllingCycles++;
808092f8:	e5953020 	ldr	r3, [r5, #32]
808092fc:	e2833001 	add	r3, r3, #1
80809300:	e5853020 	str	r3, [r5, #32]

		/* Suspend ourselves to the blocking task can execute. */
		xControllingIsSuspended = pdTRUE;
80809304:	e5856008 	str	r6, [r5, #8]
		vTaskSuspend( NULL );
80809308:	ebffe38a 	bl	80802138 <vTaskSuspend>
		xControllingIsSuspended = pdFALSE;
8080930c:	e3a03000 	mov	r3, #0
80809310:	e5853008 	str	r3, [r5, #8]
	}
80809314:	eaffffdb 	b	80809288 <prvRecursiveMutexControllingTask+0x14>

80809318 <vStartRecursiveMutexTasks>:
static xTaskHandle xControllingTaskHandle, xBlockingTaskHandle;

/*-----------------------------------------------------------*/

void vStartRecursiveMutexTasks( void )
{
80809318:	e92d4010 	push	{r4, lr}
	/* Just creates the mutex and the three tasks. */

	xMutex = xSemaphoreCreateRecursiveMutex();
8080931c:	e3a00004 	mov	r0, #4
static xTaskHandle xControllingTaskHandle, xBlockingTaskHandle;

/*-----------------------------------------------------------*/

void vStartRecursiveMutexTasks( void )
{
80809320:	e24dd008 	sub	sp, sp, #8
	/* Just creates the mutex and the three tasks. */

	xMutex = xSemaphoreCreateRecursiveMutex();
80809324:	e30840e0 	movw	r4, #32992	; 0x80e0
80809328:	e3484101 	movt	r4, #33025	; 0x8101
8080932c:	ebffde0a 	bl	80800b5c <xQueueCreateMutex>
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Recursive_Mutex" );


	if( xMutex != NULL )
80809330:	e3500000 	cmp	r0, #0

void vStartRecursiveMutexTasks( void )
{
	/* Just creates the mutex and the three tasks. */

	xMutex = xSemaphoreCreateRecursiveMutex();
80809334:	e5840000 	str	r0, [r4]
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( ( xQueueHandle ) xMutex, ( signed portCHAR * ) "Recursive_Mutex" );


	if( xMutex != NULL )
80809338:	0a00001e 	beq	808093b8 <vStartRecursiveMutexTasks+0xa0>
	{
		xTaskCreate( prvRecursiveMutexControllingTask, ( const char * const ) "Rec1", configMINIMAL_STACK_SIZE, NULL, recmuCONTROLLING_TASK_PRIORITY, &xControllingTaskHandle );
8080933c:	e2842018 	add	r2, r4, #24
80809340:	e3a03002 	mov	r3, #2
80809344:	e3091bd8 	movw	r1, #39896	; 0x9bd8
80809348:	e3090274 	movw	r0, #37492	; 0x9274
8080934c:	e58d2004 	str	r2, [sp, #4]
80809350:	e3481080 	movt	r1, #32896	; 0x8080
80809354:	e58d3000 	str	r3, [sp]
80809358:	e3a02b01 	mov	r2, #1024	; 0x400
8080935c:	e3a03000 	mov	r3, #0
80809360:	e3480080 	movt	r0, #32896	; 0x8080
80809364:	ebffe188 	bl	8080198c <xTaskCreate>
        xTaskCreate( prvRecursiveMutexBlockingTask, ( const char * const ) "Rec2", configMINIMAL_STACK_SIZE, NULL, recmuBLOCKING_TASK_PRIORITY, &xBlockingTaskHandle );
80809368:	e2844014 	add	r4, r4, #20
8080936c:	e3a03001 	mov	r3, #1
80809370:	e3091be0 	movw	r1, #39904	; 0x9be0
80809374:	e30901ec 	movw	r0, #37356	; 0x91ec
80809378:	e3481080 	movt	r1, #32896	; 0x8080
8080937c:	e58d3000 	str	r3, [sp]
80809380:	e3a02b01 	mov	r2, #1024	; 0x400
80809384:	e3a03000 	mov	r3, #0
80809388:	e58d4004 	str	r4, [sp, #4]
8080938c:	e3480080 	movt	r0, #32896	; 0x8080
80809390:	ebffe17d 	bl	8080198c <xTaskCreate>
        xTaskCreate( prvRecursiveMutexPollingTask, ( const char * const ) "Rec3", configMINIMAL_STACK_SIZE, NULL, recmuPOLLING_TASK_PRIORITY, NULL );
80809394:	e3a03000 	mov	r3, #0
80809398:	e3091be8 	movw	r1, #39912	; 0x9be8
8080939c:	e3090150 	movw	r0, #37200	; 0x9150
808093a0:	e58d3004 	str	r3, [sp, #4]
808093a4:	e58d3000 	str	r3, [sp]
808093a8:	e3481080 	movt	r1, #32896	; 0x8080
808093ac:	e3480080 	movt	r0, #32896	; 0x8080
808093b0:	e3a02b01 	mov	r2, #1024	; 0x400
808093b4:	ebffe174 	bl	8080198c <xTaskCreate>
	}
}
808093b8:	e28dd008 	add	sp, sp, #8
808093bc:	e8bd8010 	pop	{r4, pc}

808093c0 <xAreRecursiveMutexTasksStillRunning>:
{
portBASE_TYPE xReturn;
static unsigned portBASE_TYPE uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;

	/* Is the controlling task still cycling? */
	if( uxLastControllingCycles == uxControllingCycles )
808093c0:	e30830e0 	movw	r3, #32992	; 0x80e0
808093c4:	e3483101 	movt	r3, #33025	; 0x8101
808093c8:	e5932020 	ldr	r2, [r3, #32]
808093cc:	e5931024 	ldr	r1, [r3, #36]	; 0x24
	{
		uxLastControllingCycles = uxControllingCycles;
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
808093d0:	e5930028 	ldr	r0, [r3, #40]	; 0x28
{
portBASE_TYPE xReturn;
static unsigned portBASE_TYPE uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;

	/* Is the controlling task still cycling? */
	if( uxLastControllingCycles == uxControllingCycles )
808093d4:	e1510002 	cmp	r1, r2
	{
		xErrorOccurred = pdTRUE;
	}
	else
	{
		uxLastControllingCycles = uxControllingCycles;
808093d8:	15932020 	ldrne	r2, [r3, #32]
static unsigned portBASE_TYPE uxLastControllingCycles = 0, uxLastBlockingCycles = 0, uxLastPollingCycles = 0;

	/* Is the controlling task still cycling? */
	if( uxLastControllingCycles == uxControllingCycles )
	{
		xErrorOccurred = pdTRUE;
808093dc:	03a02001 	moveq	r2, #1
808093e0:	0583200c 	streq	r2, [r3, #12]
	{
		uxLastControllingCycles = uxControllingCycles;
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
808093e4:	e593101c 	ldr	r1, [r3, #28]
	{
		xErrorOccurred = pdTRUE;
	}
	else
	{
		uxLastControllingCycles = uxControllingCycles;
808093e8:	15832024 	strne	r2, [r3, #36]	; 0x24
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
808093ec:	e30820e0 	movw	r2, #32992	; 0x80e0
808093f0:	e3482101 	movt	r2, #33025	; 0x8101
808093f4:	e1500001 	cmp	r0, r1
	{
		uxLastBlockingCycles = uxBlockingCycles;
	}

	/* Is the polling task still cycling? */
	if( uxLastPollingCycles == uxPollingCycles )
808093f8:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
	{
		xErrorOccurred = pdTRUE;
	}
	else
	{
		uxLastBlockingCycles = uxBlockingCycles;
808093fc:	1592101c 	ldrne	r1, [r2, #28]
	}

	/* Is the blocking task still cycling? */
	if( uxLastBlockingCycles == uxBlockingCycles )
	{
		xErrorOccurred = pdTRUE;
80809400:	03a01001 	moveq	r1, #1
80809404:	0582100c 	streq	r1, [r2, #12]
	}
	else
	{
		uxLastBlockingCycles = uxBlockingCycles;
80809408:	15821028 	strne	r1, [r2, #40]	; 0x28
	}

	/* Is the polling task still cycling? */
	if( uxLastPollingCycles == uxPollingCycles )
8080940c:	e30820e0 	movw	r2, #32992	; 0x80e0
80809410:	e5931010 	ldr	r1, [r3, #16]
80809414:	e3482101 	movt	r2, #33025	; 0x8101
80809418:	e1500001 	cmp	r0, r1
	{
		xErrorOccurred = pdTRUE;
8080941c:	03a01001 	moveq	r1, #1
	}
	else
	{
		uxLastPollingCycles = uxPollingCycles;
80809420:	15921010 	ldrne	r1, [r2, #16]
	}

	/* Is the polling task still cycling? */
	if( uxLastPollingCycles == uxPollingCycles )
	{
		xErrorOccurred = pdTRUE;
80809424:	0582100c 	streq	r1, [r2, #12]
	else
	{
		uxLastPollingCycles = uxPollingCycles;
	}

	if( xErrorOccurred == pdTRUE )
80809428:	e593000c 	ldr	r0, [r3, #12]
	{
		xErrorOccurred = pdTRUE;
	}
	else
	{
		uxLastPollingCycles = uxPollingCycles;
8080942c:	1582102c 	strne	r1, [r2, #44]	; 0x2c
	{
		xReturn = pdTRUE;
	}

	return xReturn;
}
80809430:	e2500001 	subs	r0, r0, #1
80809434:	13a00001 	movne	r0, #1
80809438:	e12fff1e 	bx	lr

8080943c <prvSemaphoreTest>:
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
8080943c:	e92d47f0 	push	{r4, r5, r6, r7, r8, r9, sl, lr}
short sError = pdFALSE, sCheckVariableToUse;

	/* See which check variable to use.  sNextCheckVariable is not semaphore 
	protected! */
	portENTER_CRITICAL();
		sCheckVariableToUse = sNextCheckVariable;
80809440:	e3089110 	movw	r9, #33040	; 0x8110
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
80809444:	e24dd008 	sub	sp, sp, #8
short sError = pdFALSE, sCheckVariableToUse;

	/* See which check variable to use.  sNextCheckVariable is not semaphore 
	protected! */
	portENTER_CRITICAL();
		sCheckVariableToUse = sNextCheckVariable;
80809448:	e3489101 	movt	r9, #33025	; 0x8101
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
8080944c:	e1a05000 	mov	r5, r0

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
80809450:	e3a08801 	mov	r8, #65536	; 0x10000
unsigned long ulCounter;
short sError = pdFALSE, sCheckVariableToUse;

	/* See which check variable to use.  sNextCheckVariable is not semaphore 
	protected! */
	portENTER_CRITICAL();
80809454:	ebffeb29 	bl	80804100 <vTaskEnterCritical>
		sCheckVariableToUse = sNextCheckVariable;
80809458:	e1d970b0 	ldrh	r7, [r9]
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
8080945c:	e3a06a01 	mov	r6, #4096	; 0x1000
		sNextCheckVariable++;
80809460:	e1d930b0 	ldrh	r3, [r9]
80809464:	e3446824 	movt	r6, #18468	; 0x4824
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvSemaphoreTest, pvParameters )
{
80809468:	e3a0a000 	mov	sl, #0

	/* See which check variable to use.  sNextCheckVariable is not semaphore 
	protected! */
	portENTER_CRITICAL();
		sCheckVariableToUse = sNextCheckVariable;
		sNextCheckVariable++;
8080946c:	e2833001 	add	r3, r3, #1
short sError = pdFALSE, sCheckVariableToUse;

	/* See which check variable to use.  sNextCheckVariable is not semaphore 
	protected! */
	portENTER_CRITICAL();
		sCheckVariableToUse = sNextCheckVariable;
80809470:	e6ff7077 	uxth	r7, r7
		sNextCheckVariable++;
80809474:	e6ff3073 	uxth	r3, r3
80809478:	e6bf7077 	sxth	r7, r7
8080947c:	e1c930b0 	strh	r3, [r9]
	portEXIT_CRITICAL();
80809480:	ebffeb2a 	bl	80804130 <vTaskExitCritical>
	pxParameters = ( xSemaphoreParameters * ) pvParameters;
	pulSharedVariable = pxParameters->pulSharedVariable;

	/* If we are blocking we use a much higher count to ensure loads of context
	switches occur during the count. */
	if( pxParameters->xBlockTime > ( portTickType ) 0 )
80809484:	e5952008 	ldr	r2, [r5, #8]
	portEXIT_CRITICAL();

	/* A structure is passed in as the parameter.  This contains the shared 
	variable being guarded. */
	pxParameters = ( xSemaphoreParameters * ) pvParameters;
	pulSharedVariable = pxParameters->pulSharedVariable;
80809488:	e5954004 	ldr	r4, [r5, #4]

	/* If we are blocking we use a much higher count to ensure loads of context
	switches occur during the count. */
	if( pxParameters->xBlockTime > ( portTickType ) 0 )
8080948c:	e3520000 	cmp	r2, #0
	{
		ulExpectedValue = semtstBLOCKING_EXPECTED_VALUE;
80809490:	13003fff 	movwne	r3, #4095	; 0xfff
	}
	else
	{
		ulExpectedValue = semtstNON_BLOCKING_EXPECTED_VALUE;
80809494:	03a030ff 	moveq	r3, #255	; 0xff
80809498:	e58d3004 	str	r3, [sp, #4]
#define portNOP()

static inline unsigned long portCORE_ID(void)
{
	unsigned long val;
	__asm(" mrc p15,0,%[val],c0,c0,5\n":[val] "=r" (val)::);
8080949c:	ee103fb0 	mrc	15, 0, r3, cr0, cr0, {5}

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808094a0:	e2033003 	and	r3, r3, #3
808094a4:	e1a03318 	lsl	r3, r8, r3
808094a8:	e3838001 	orr	r8, r3, #1
	}

	for( ;; )
	{
		/* Try to obtain the semaphore. */
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
808094ac:	e3a03000 	mov	r3, #0
808094b0:	e5950000 	ldr	r0, [r5]
808094b4:	e1a01003 	mov	r1, r3
808094b8:	ebffdea1 	bl	80800f44 <xQueueGenericReceive>
808094bc:	e3500001 	cmp	r0, #1
808094c0:	0a000028 	beq	80809568 <prvSemaphoreTest+0x12c>
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
		}
		else
		{
			if( pxParameters->xBlockTime == ( portTickType ) 0 )
808094c4:	e5952008 	ldr	r2, [r5, #8]
808094c8:	e3520000 	cmp	r2, #0
808094cc:	1afffff6 	bne	808094ac <prvSemaphoreTest+0x70>
#define portSGI_YIELD( xCPUID )			( ( 0 << 24 ) | ( ( 1 << 16 ) << ( xCPUID ) ) | portSGI_YIELD_VECTOR_ID )
/* #define portYIELD()		( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL ? portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) ) : (void)portGIC_DISTRIBUTOR_BASE ) */

static inline void portYIELD(void)
{
	if( ( portGIC_READ( portGIC_ICDISPR_BASE( portGIC_DISTRIBUTOR_BASE ) ) & portSGI_YIELD_VECTOR_ID ) == 0UL)
808094d0:	e5963200 	ldr	r3, [r6, #512]	; 0x200
808094d4:	e3130001 	tst	r3, #1
808094d8:	1afffff3 	bne	808094ac <prvSemaphoreTest+0x70>
	{
		portGIC_WRITE( portGIC_ICDSGIR( portGIC_DISTRIBUTOR_BASE ), portSGI_YIELD( portCORE_ID() ) );
808094dc:	e5868f00 	str	r8, [r6, #3840]	; 0xf00
		__asm__ __volatile__ ( "nop" ); /* Allow the yield SGI time to propagate. */
808094e0:	e320f000 	nop	{0}

#if configPLATFORM == 3
		__asm__ __volatile__ ( "nop" );
808094e4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808094e8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808094ec:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808094f0:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808094f4:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808094f8:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
808094fc:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809500:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809504:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809508:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080950c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809510:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809514:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809518:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080951c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809520:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809524:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809528:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080952c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809530:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809534:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809538:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080953c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809540:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809544:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809548:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080954c:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809550:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809554:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
80809558:	e320f000 	nop	{0}
		__asm__ __volatile__ ( "nop" );
8080955c:	e320f000 	nop	{0}
80809560:	e5952008 	ldr	r2, [r5, #8]
80809564:	eaffffd0 	b	808094ac <prvSemaphoreTest+0x70>
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
		{
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
80809568:	e5941000 	ldr	r1, [r4]
			}
			
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
8080956c:	e3a03000 	mov	r3, #0
		if( xSemaphoreTake( pxParameters->xSemaphore, pxParameters->xBlockTime ) == pdPASS )
		{
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
80809570:	e59d2004 	ldr	r2, [sp, #4]
			}
			
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
80809574:	e59d0004 	ldr	r0, [sp, #4]
			/* We have the semaphore and so expect any other tasks using the
			shared variable to have left it in the state we expect to find
			it. */
			if( *pulSharedVariable != ulExpectedValue )
			{
				sError = pdTRUE;
80809578:	e1510002 	cmp	r1, r2
8080957c:	13a0a001 	movne	sl, #1
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
			{
				*pulSharedVariable = ulCounter;
80809580:	e5843000 	str	r3, [r4]
				if( *pulSharedVariable != ulCounter )
80809584:	e5942000 	ldr	r2, [r4]
			}
			
			/* Clear the variable, then count it back up to the expected value
			before releasing the semaphore.  Would expect a context switch or
			two during this time. */
			for( ulCounter = ( unsigned long ) 0; ulCounter <= ulExpectedValue; ulCounter++ )
80809588:	e59d1004 	ldr	r1, [sp, #4]
8080958c:	e1520003 	cmp	r2, r3
80809590:	e2833001 	add	r3, r3, #1
80809594:	01a0200a 	moveq	r2, sl
80809598:	13a02001 	movne	r2, #1
8080959c:	e1510003 	cmp	r1, r3
808095a0:	e6ffa072 	uxth	sl, r2
808095a4:	2afffff5 	bcs	80809580 <prvSemaphoreTest+0x144>
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
808095a8:	e3a03000 	mov	r3, #0
808095ac:	e5950000 	ldr	r0, [r5]
808095b0:	e1a02003 	mov	r2, r3
808095b4:	e1a01003 	mov	r1, r3
808095b8:	ebffdbbf 	bl	808004bc <xQueueGenericSend>
808095bc:	e3500000 	cmp	r0, #0
			{
				sError = pdTRUE;
808095c0:	03a0a001 	moveq	sl, #1
				}
			}

			/* Release the semaphore, and if no errors have occurred increment the check
			variable. */
			if(	xSemaphoreGive( pxParameters->xSemaphore ) == pdFALSE )
808095c4:	0a000006 	beq	808095e4 <prvSemaphoreTest+0x1a8>
				sError = pdTRUE;
			}

			if( sError == pdFALSE )
			{
				if( sCheckVariableToUse < semtstNUM_TASKS )
808095c8:	e3570003 	cmp	r7, #3
808095cc:	d35a0000 	cmple	sl, #0
				{
					( sCheckVariables[ sCheckVariableToUse ] )++;
808095d0:	00892087 	addeq	r2, r9, r7, lsl #1
808095d4:	01d230b4 	ldrheq	r3, [r2, #4]
808095d8:	02833001 	addeq	r3, r3, #1
808095dc:	06ff3073 	uxtheq	r3, r3
808095e0:	01c230b4 	strheq	r3, [r2, #4]
			/* If we have a block time then we are running at a priority higher
			than the idle priority.  This task takes a long time to complete
			a cycle	(deliberately so to test the guarding) so will be starving
			out lower priority tasks.  Block for some time to allow give lower
			priority tasks some processor time. */
			vTaskDelay( pxParameters->xBlockTime * semtstDELAY_FACTOR );
808095e4:	e5953008 	ldr	r3, [r5, #8]
808095e8:	e1a00183 	lsl	r0, r3, #3
808095ec:	e0800083 	add	r0, r0, r3, lsl #1
808095f0:	ebffe698 	bl	80803058 <vTaskDelay>
808095f4:	e5952008 	ldr	r2, [r5, #8]
808095f8:	eaffffab 	b	808094ac <prvSemaphoreTest+0x70>

808095fc <vStartSemaphoreTasks>:
static volatile short sNextCheckVariable = 0;

/*-----------------------------------------------------------*/

void vStartSemaphoreTasks( unsigned portBASE_TYPE uxPriority )
{
808095fc:	e92d4070 	push	{r4, r5, r6, lr}
80809600:	e1a06000 	mov	r6, r0
80809604:	e24dd008 	sub	sp, sp, #8
xSemaphoreParameters *pxFirstSemaphoreParameters, *pxSecondSemaphoreParameters;
const portTickType xBlockTime = ( portTickType ) 100;

	/* Create the structure used to pass parameters to the first two tasks. */
	pxFirstSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
80809608:	e3a0000c 	mov	r0, #12
8080960c:	ebfff06b 	bl	808057c0 <pvPortMalloc>

	if( pxFirstSemaphoreParameters != NULL )
80809610:	e2504000 	subs	r4, r0, #0
80809614:	0a000027 	beq	808096b8 <vStartSemaphoreTasks+0xbc>
	{
		/* Create the semaphore used by the first two tasks. */
		vSemaphoreCreateBinary( pxFirstSemaphoreParameters->xSemaphore );
80809618:	e3a02003 	mov	r2, #3
8080961c:	e3a01000 	mov	r1, #0
80809620:	e3a00001 	mov	r0, #1
80809624:	ebffdb3c 	bl	8080031c <xQueueGenericCreate>
80809628:	e3500000 	cmp	r0, #0
8080962c:	e5840000 	str	r0, [r4]
80809630:	0a000020 	beq	808096b8 <vStartSemaphoreTasks+0xbc>
80809634:	e3a03000 	mov	r3, #0
80809638:	e1a02003 	mov	r2, r3
8080963c:	e1a01003 	mov	r1, r3
80809640:	ebffdb9d 	bl	808004bc <xQueueGenericSend>

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
80809644:	e5943000 	ldr	r3, [r4]
80809648:	e3530000 	cmp	r3, #0
8080964c:	0a000019 	beq	808096b8 <vStartSemaphoreTasks+0xbc>
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80809650:	e3a00004 	mov	r0, #4

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;
80809654:	e3a05000 	mov	r5, #0
		vSemaphoreCreateBinary( pxFirstSemaphoreParameters->xSemaphore );

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80809658:	ebfff058 	bl	808057c0 <pvPortMalloc>

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
8080965c:	e3a020ff 	mov	r2, #255	; 0xff
		vSemaphoreCreateBinary( pxFirstSemaphoreParameters->xSemaphore );

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80809660:	e1a03000 	mov	r3, r0

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, ( const char * const ) "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
80809664:	e3091bf0 	movw	r1, #39920	; 0x9bf0
80809668:	e309043c 	movw	r0, #37948	; 0x943c
		vSemaphoreCreateBinary( pxFirstSemaphoreParameters->xSemaphore );

		if( pxFirstSemaphoreParameters->xSemaphore != NULL )
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
8080966c:	e5843004 	str	r3, [r4, #4]

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, ( const char * const ) "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
80809670:	e3481080 	movt	r1, #32896	; 0x8080
		{
			/* Create the variable which is to be shared by the first two tasks. */
			pxFirstSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;
80809674:	e5832000 	str	r2, [r3]

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, ( const char * const ) "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
80809678:	e3480080 	movt	r0, #32896	; 0x8080

			/* Initialise the share variable to the value the tasks expect. */
			*( pxFirstSemaphoreParameters->pulSharedVariable ) = semtstNON_BLOCKING_EXPECTED_VALUE;

			/* The first two tasks do not block on semaphore calls. */
			pxFirstSemaphoreParameters->xBlockTime = ( portTickType ) 0;
8080967c:	e5845008 	str	r5, [r4, #8]

			/* Spawn the first two tasks.  As they poll they operate at the idle priority. */
			xTaskCreate( prvSemaphoreTest, ( const char * const ) "PolSEM1", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
80809680:	e1a03004 	mov	r3, r4
80809684:	e3a02b01 	mov	r2, #1024	; 0x400
80809688:	e58d5004 	str	r5, [sp, #4]
8080968c:	e58d5000 	str	r5, [sp]
80809690:	ebffe0bd 	bl	8080198c <xTaskCreate>
			xTaskCreate( prvSemaphoreTest, ( const char * const ) "PolSEM2", semtstSTACK_SIZE, ( void * ) pxFirstSemaphoreParameters, tskIDLE_PRIORITY, ( xTaskHandle * ) NULL );
80809694:	e3091bf8 	movw	r1, #39928	; 0x9bf8
80809698:	e309043c 	movw	r0, #37948	; 0x943c
8080969c:	e58d5004 	str	r5, [sp, #4]
808096a0:	e1a03004 	mov	r3, r4
808096a4:	e58d5000 	str	r5, [sp]
808096a8:	e3481080 	movt	r1, #32896	; 0x8080
808096ac:	e3480080 	movt	r0, #32896	; 0x8080
808096b0:	e3a02b01 	mov	r2, #1024	; 0x400
808096b4:	ebffe0b4 	bl	8080198c <xTaskCreate>
		}
	}

	/* Do exactly the same to create the second set of tasks, only this time 
	provide a block time for the semaphore calls. */
	pxSecondSemaphoreParameters = ( xSemaphoreParameters * ) pvPortMalloc( sizeof( xSemaphoreParameters ) );
808096b8:	e3a0000c 	mov	r0, #12
808096bc:	ebfff03f 	bl	808057c0 <pvPortMalloc>
	if( pxSecondSemaphoreParameters != NULL )
808096c0:	e2504000 	subs	r4, r0, #0
808096c4:	0a000028 	beq	8080976c <vStartSemaphoreTasks+0x170>
	{
		vSemaphoreCreateBinary( pxSecondSemaphoreParameters->xSemaphore );
808096c8:	e3a02003 	mov	r2, #3
808096cc:	e3a01000 	mov	r1, #0
808096d0:	e3a00001 	mov	r0, #1
808096d4:	ebffdb10 	bl	8080031c <xQueueGenericCreate>
808096d8:	e3500000 	cmp	r0, #0
808096dc:	e5840000 	str	r0, [r4]
808096e0:	0a000021 	beq	8080976c <vStartSemaphoreTasks+0x170>
808096e4:	e3a03000 	mov	r3, #0
808096e8:	e1a02003 	mov	r2, r3
808096ec:	e1a01003 	mov	r1, r3
808096f0:	ebffdb71 	bl	808004bc <xQueueGenericSend>

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
808096f4:	e5943000 	ldr	r3, [r4]
808096f8:	e3530000 	cmp	r3, #0
808096fc:	0a00001a 	beq	8080976c <vStartSemaphoreTasks+0x170>
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80809700:	e3a00004 	mov	r0, #4
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;

			xTaskCreate( prvSemaphoreTest, ( const char * const ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
80809704:	e3a05000 	mov	r5, #0
	{
		vSemaphoreCreateBinary( pxSecondSemaphoreParameters->xSemaphore );

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80809708:	ebfff02c 	bl	808057c0 <pvPortMalloc>
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
8080970c:	e300cfff 	movw	ip, #4095	; 0xfff
	{
		vSemaphoreCreateBinary( pxSecondSemaphoreParameters->xSemaphore );

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80809710:	e1a03000 	mov	r3, r0
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;
80809714:	e3a02064 	mov	r2, #100	; 0x64

			xTaskCreate( prvSemaphoreTest, ( const char * const ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
80809718:	e309043c 	movw	r0, #37948	; 0x943c
8080971c:	e3091c00 	movw	r1, #39936	; 0x9c00
	{
		vSemaphoreCreateBinary( pxSecondSemaphoreParameters->xSemaphore );

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
80809720:	e5843004 	str	r3, [r4, #4]
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;

			xTaskCreate( prvSemaphoreTest, ( const char * const ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
80809724:	e3481080 	movt	r1, #32896	; 0x8080
		vSemaphoreCreateBinary( pxSecondSemaphoreParameters->xSemaphore );

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
80809728:	e583c000 	str	ip, [r3]
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;

			xTaskCreate( prvSemaphoreTest, ( const char * const ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
8080972c:	e3480080 	movt	r0, #32896	; 0x8080

		if( pxSecondSemaphoreParameters->xSemaphore != NULL )
		{
			pxSecondSemaphoreParameters->pulSharedVariable = ( unsigned long * ) pvPortMalloc( sizeof( unsigned long ) );
			*( pxSecondSemaphoreParameters->pulSharedVariable ) = semtstBLOCKING_EXPECTED_VALUE;
			pxSecondSemaphoreParameters->xBlockTime = xBlockTime / portTICK_RATE_MS;
80809730:	e5842008 	str	r2, [r4, #8]

			xTaskCreate( prvSemaphoreTest, ( const char * const ) "BlkSEM1", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
80809734:	e1a03004 	mov	r3, r4
80809738:	e3a02b01 	mov	r2, #1024	; 0x400
8080973c:	e58d6000 	str	r6, [sp]
80809740:	e58d5004 	str	r5, [sp, #4]
80809744:	ebffe090 	bl	8080198c <xTaskCreate>
			xTaskCreate( prvSemaphoreTest, ( const char * const ) "BlkSEM2", semtstSTACK_SIZE, ( void * ) pxSecondSemaphoreParameters, uxPriority, ( xTaskHandle * ) NULL );
80809748:	e3091c08 	movw	r1, #39944	; 0x9c08
8080974c:	e309043c 	movw	r0, #37948	; 0x943c
80809750:	e58d5004 	str	r5, [sp, #4]
80809754:	e1a03004 	mov	r3, r4
80809758:	e58d6000 	str	r6, [sp]
8080975c:	e3481080 	movt	r1, #32896	; 0x8080
80809760:	e3480080 	movt	r0, #32896	; 0x8080
80809764:	e3a02b01 	mov	r2, #1024	; 0x400
80809768:	ebffe087 	bl	8080198c <xTaskCreate>
	is not being used.  The call to vQueueAddToRegistry() will be removed
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( ( xQueueHandle ) pxFirstSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_1" );
	vQueueAddToRegistry( ( xQueueHandle ) pxSecondSemaphoreParameters->xSemaphore, ( signed char * ) "Counting_Sem_2" );
}
8080976c:	e28dd008 	add	sp, sp, #8
80809770:	e8bd8070 	pop	{r4, r5, r6, pc}

80809774 <xAreSemaphoreTasksStillRunning>:
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
80809774:	e3083110 	movw	r3, #33040	; 0x8110
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreSemaphoreTasksStillRunning( void )
{
80809778:	e92d40f0 	push	{r4, r5, r6, r7, lr}
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
8080977c:	e3483101 	movt	r3, #33025	; 0x8101
80809780:	e1d3c0b4 	ldrh	ip, [r3, #4]
80809784:	e1d310bc 	ldrh	r1, [r3, #12]
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
80809788:	e1d350b4 	ldrh	r5, [r3, #4]
8080978c:	e1d3e0be 	ldrh	lr, [r3, #14]
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
80809790:	e1d320b6 	ldrh	r2, [r3, #6]
80809794:	e05cc001 	subs	ip, ip, r1
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
80809798:	e1d340b6 	ldrh	r4, [r3, #6]
8080979c:	13a0c001 	movne	ip, #1
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
808097a0:	e1d370b8 	ldrh	r7, [r3, #8]
808097a4:	e1d361b0 	ldrh	r6, [r3, #16]
808097a8:	e152000e 	cmp	r2, lr
808097ac:	11a0100c 	movne	r1, ip
808097b0:	03a01000 	moveq	r1, #0
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
808097b4:	e1d3c0b8 	ldrh	ip, [r3, #8]
808097b8:	e1570006 	cmp	r7, r6
static short sLastCheckVariables[ semtstNUM_TASKS ] = { 0 };
portBASE_TYPE xTask, xReturn = pdTRUE;

	for( xTask = 0; xTask < semtstNUM_TASKS; xTask++ )
	{
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
808097bc:	e1d300ba 	ldrh	r0, [r3, #10]
808097c0:	e1d3e1b2 	ldrh	lr, [r3, #18]
808097c4:	11a02001 	movne	r2, r1
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
808097c8:	e1d310ba 	ldrh	r1, [r3, #10]
808097cc:	03a02000 	moveq	r2, #0
808097d0:	e1c350bc 	strh	r5, [r3, #12]
	}

	return xReturn;
}
808097d4:	e150000e 	cmp	r0, lr
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
808097d8:	e1c340be 	strh	r4, [r3, #14]
	}

	return xReturn;
}
808097dc:	11a00002 	movne	r0, r2
808097e0:	03a00000 	moveq	r0, #0
		if( sLastCheckVariables[ xTask ] == sCheckVariables[ xTask ] )
		{
			xReturn = pdFALSE;
		}

		sLastCheckVariables[ xTask ] = sCheckVariables[ xTask ];
808097e4:	e1c3c1b0 	strh	ip, [r3, #16]
808097e8:	e1c311b2 	strh	r1, [r3, #18]
	}

	return xReturn;
}
808097ec:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

808097f0 <memcpy>:
808097f0:	4684      	mov	ip, r0
808097f2:	ea41 0300 	orr.w	r3, r1, r0
808097f6:	f013 0303 	ands.w	r3, r3, #3
808097fa:	d149      	bne.n	80809890 <memcpy+0xa0>
808097fc:	3a40      	subs	r2, #64	; 0x40
808097fe:	d323      	bcc.n	80809848 <memcpy+0x58>
80809800:	680b      	ldr	r3, [r1, #0]
80809802:	6003      	str	r3, [r0, #0]
80809804:	684b      	ldr	r3, [r1, #4]
80809806:	6043      	str	r3, [r0, #4]
80809808:	688b      	ldr	r3, [r1, #8]
8080980a:	6083      	str	r3, [r0, #8]
8080980c:	68cb      	ldr	r3, [r1, #12]
8080980e:	60c3      	str	r3, [r0, #12]
80809810:	690b      	ldr	r3, [r1, #16]
80809812:	6103      	str	r3, [r0, #16]
80809814:	694b      	ldr	r3, [r1, #20]
80809816:	6143      	str	r3, [r0, #20]
80809818:	698b      	ldr	r3, [r1, #24]
8080981a:	6183      	str	r3, [r0, #24]
8080981c:	69cb      	ldr	r3, [r1, #28]
8080981e:	61c3      	str	r3, [r0, #28]
80809820:	6a0b      	ldr	r3, [r1, #32]
80809822:	6203      	str	r3, [r0, #32]
80809824:	6a4b      	ldr	r3, [r1, #36]	; 0x24
80809826:	6243      	str	r3, [r0, #36]	; 0x24
80809828:	6a8b      	ldr	r3, [r1, #40]	; 0x28
8080982a:	6283      	str	r3, [r0, #40]	; 0x28
8080982c:	6acb      	ldr	r3, [r1, #44]	; 0x2c
8080982e:	62c3      	str	r3, [r0, #44]	; 0x2c
80809830:	6b0b      	ldr	r3, [r1, #48]	; 0x30
80809832:	6303      	str	r3, [r0, #48]	; 0x30
80809834:	6b4b      	ldr	r3, [r1, #52]	; 0x34
80809836:	6343      	str	r3, [r0, #52]	; 0x34
80809838:	6b8b      	ldr	r3, [r1, #56]	; 0x38
8080983a:	6383      	str	r3, [r0, #56]	; 0x38
8080983c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
8080983e:	63c3      	str	r3, [r0, #60]	; 0x3c
80809840:	3040      	adds	r0, #64	; 0x40
80809842:	3140      	adds	r1, #64	; 0x40
80809844:	3a40      	subs	r2, #64	; 0x40
80809846:	d2db      	bcs.n	80809800 <memcpy+0x10>
80809848:	3230      	adds	r2, #48	; 0x30
8080984a:	d30b      	bcc.n	80809864 <memcpy+0x74>
8080984c:	680b      	ldr	r3, [r1, #0]
8080984e:	6003      	str	r3, [r0, #0]
80809850:	684b      	ldr	r3, [r1, #4]
80809852:	6043      	str	r3, [r0, #4]
80809854:	688b      	ldr	r3, [r1, #8]
80809856:	6083      	str	r3, [r0, #8]
80809858:	68cb      	ldr	r3, [r1, #12]
8080985a:	60c3      	str	r3, [r0, #12]
8080985c:	3010      	adds	r0, #16
8080985e:	3110      	adds	r1, #16
80809860:	3a10      	subs	r2, #16
80809862:	d2f3      	bcs.n	8080984c <memcpy+0x5c>
80809864:	320c      	adds	r2, #12
80809866:	d305      	bcc.n	80809874 <memcpy+0x84>
80809868:	f851 3b04 	ldr.w	r3, [r1], #4
8080986c:	f840 3b04 	str.w	r3, [r0], #4
80809870:	3a04      	subs	r2, #4
80809872:	d2f9      	bcs.n	80809868 <memcpy+0x78>
80809874:	3204      	adds	r2, #4
80809876:	d008      	beq.n	8080988a <memcpy+0x9a>
80809878:	07d2      	lsls	r2, r2, #31
8080987a:	bf1c      	itt	ne
8080987c:	f811 3b01 	ldrbne.w	r3, [r1], #1
80809880:	f800 3b01 	strbne.w	r3, [r0], #1
80809884:	d301      	bcc.n	8080988a <memcpy+0x9a>
80809886:	880b      	ldrh	r3, [r1, #0]
80809888:	8003      	strh	r3, [r0, #0]
8080988a:	4660      	mov	r0, ip
8080988c:	4770      	bx	lr
8080988e:	bf00      	nop
80809890:	2a08      	cmp	r2, #8
80809892:	d313      	bcc.n	808098bc <memcpy+0xcc>
80809894:	078b      	lsls	r3, r1, #30
80809896:	d0b1      	beq.n	808097fc <memcpy+0xc>
80809898:	f010 0303 	ands.w	r3, r0, #3
8080989c:	d0ae      	beq.n	808097fc <memcpy+0xc>
8080989e:	f1c3 0304 	rsb	r3, r3, #4
808098a2:	1ad2      	subs	r2, r2, r3
808098a4:	07db      	lsls	r3, r3, #31
808098a6:	bf1c      	itt	ne
808098a8:	f811 3b01 	ldrbne.w	r3, [r1], #1
808098ac:	f800 3b01 	strbne.w	r3, [r0], #1
808098b0:	d3a4      	bcc.n	808097fc <memcpy+0xc>
808098b2:	f831 3b02 	ldrh.w	r3, [r1], #2
808098b6:	f820 3b02 	strh.w	r3, [r0], #2
808098ba:	e79f      	b.n	808097fc <memcpy+0xc>
808098bc:	3a04      	subs	r2, #4
808098be:	d3d9      	bcc.n	80809874 <memcpy+0x84>
808098c0:	3a01      	subs	r2, #1
808098c2:	f811 3b01 	ldrb.w	r3, [r1], #1
808098c6:	f800 3b01 	strb.w	r3, [r0], #1
808098ca:	d2f9      	bcs.n	808098c0 <memcpy+0xd0>
808098cc:	780b      	ldrb	r3, [r1, #0]
808098ce:	7003      	strb	r3, [r0, #0]
808098d0:	784b      	ldrb	r3, [r1, #1]
808098d2:	7043      	strb	r3, [r0, #1]
808098d4:	788b      	ldrb	r3, [r1, #2]
808098d6:	7083      	strb	r3, [r0, #2]
808098d8:	4660      	mov	r0, ip
808098da:	4770      	bx	lr

808098dc <memset>:
808098dc:	0783      	lsls	r3, r0, #30
808098de:	b4f0      	push	{r4, r5, r6, r7}
808098e0:	d045      	beq.n	8080996e <memset+0x92>
808098e2:	1e54      	subs	r4, r2, #1
808098e4:	2a00      	cmp	r2, #0
808098e6:	d040      	beq.n	8080996a <memset+0x8e>
808098e8:	b2cd      	uxtb	r5, r1
808098ea:	4603      	mov	r3, r0
808098ec:	e001      	b.n	808098f2 <memset+0x16>
808098ee:	b3e4      	cbz	r4, 8080996a <memset+0x8e>
808098f0:	4614      	mov	r4, r2
808098f2:	f803 5b01 	strb.w	r5, [r3], #1
808098f6:	f013 0f03 	tst.w	r3, #3
808098fa:	f104 32ff 	add.w	r2, r4, #4294967295
808098fe:	d1f6      	bne.n	808098ee <memset+0x12>
80809900:	2c03      	cmp	r4, #3
80809902:	d92b      	bls.n	8080995c <memset+0x80>
80809904:	b2cd      	uxtb	r5, r1
80809906:	2c0f      	cmp	r4, #15
80809908:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
8080990c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
80809910:	d930      	bls.n	80809974 <memset+0x98>
80809912:	f1a4 0610 	sub.w	r6, r4, #16
80809916:	f103 0210 	add.w	r2, r3, #16
8080991a:	0936      	lsrs	r6, r6, #4
8080991c:	1cb7      	adds	r7, r6, #2
8080991e:	eb03 1707 	add.w	r7, r3, r7, lsl #4
80809922:	f842 5c10 	str.w	r5, [r2, #-16]
80809926:	3210      	adds	r2, #16
80809928:	f842 5c1c 	str.w	r5, [r2, #-28]
8080992c:	f842 5c18 	str.w	r5, [r2, #-24]
80809930:	f842 5c14 	str.w	r5, [r2, #-20]
80809934:	42ba      	cmp	r2, r7
80809936:	d1f4      	bne.n	80809922 <memset+0x46>
80809938:	f004 040f 	and.w	r4, r4, #15
8080993c:	1c72      	adds	r2, r6, #1
8080993e:	2c03      	cmp	r4, #3
80809940:	eb03 1202 	add.w	r2, r3, r2, lsl #4
80809944:	d918      	bls.n	80809978 <memset+0x9c>
80809946:	1f23      	subs	r3, r4, #4
80809948:	f023 0303 	bic.w	r3, r3, #3
8080994c:	3304      	adds	r3, #4
8080994e:	4413      	add	r3, r2
80809950:	f842 5b04 	str.w	r5, [r2], #4
80809954:	4293      	cmp	r3, r2
80809956:	d1fb      	bne.n	80809950 <memset+0x74>
80809958:	f004 0403 	and.w	r4, r4, #3
8080995c:	b12c      	cbz	r4, 8080996a <memset+0x8e>
8080995e:	b2c9      	uxtb	r1, r1
80809960:	441c      	add	r4, r3
80809962:	f803 1b01 	strb.w	r1, [r3], #1
80809966:	42a3      	cmp	r3, r4
80809968:	d1fb      	bne.n	80809962 <memset+0x86>
8080996a:	bcf0      	pop	{r4, r5, r6, r7}
8080996c:	4770      	bx	lr
8080996e:	4614      	mov	r4, r2
80809970:	4603      	mov	r3, r0
80809972:	e7c5      	b.n	80809900 <memset+0x24>
80809974:	461a      	mov	r2, r3
80809976:	e7e6      	b.n	80809946 <memset+0x6a>
80809978:	4613      	mov	r3, r2
8080997a:	2c00      	cmp	r4, #0
8080997c:	d1ef      	bne.n	8080995e <memset+0x82>
8080997e:	e7f4      	b.n	8080996a <memset+0x8e>
80809980:	2e2f2e2e 	.word	0x2e2f2e2e
80809984:	6f532f2e 	.word	0x6f532f2e
80809988:	65637275 	.word	0x65637275
8080998c:	6575712f 	.word	0x6575712f
80809990:	632e6575 	.word	0x632e6575
80809994:	00000000 	.word	0x00000000
80809998:	2e2f2e2e 	.word	0x2e2f2e2e
8080999c:	6f532f2e 	.word	0x6f532f2e
808099a0:	65637275 	.word	0x65637275
808099a4:	7361742f 	.word	0x7361742f
808099a8:	632e736b 	.word	0x632e736b
808099ac:	00000000 	.word	0x00000000
808099b0:	454c4449 	.word	0x454c4449
808099b4:	00000000 	.word	0x00000000

808099b8 <ulKernelPriority>:
808099b8:	000000c0 000a0d70 000a0d61 0d535446     ....p...a...FTS.
808099c8:	0000000a 6c696146 6e49203a 65676574     ....Fail: Intege
808099d8:	614d2072 0d736874 0000000a 6c696146     r Maths.....Fail
808099e8:	6f50203a 6e696c6c 75512067 73657565     : Polling Queues
808099f8:	00000a0d 6c696146 6553203a 6154206d     ....Fail: Sem Ta
80809a08:	0d736b73 0000000a 6c696146 6c42203a     sks.....Fail: Bl
80809a18:	516b636f 00000a0d 6c696146 6553203a     ockQ....Fail: Se
80809a28:	756f436d 0a0d746e 00000000 6c696146     mCount......Fail
80809a38:	7944203a 696d616e 69725063 000a0d6f     : DynamicPrio...
80809a48:	6c696146 6547203a 0a0d516e 00000000     Fail: GenQ......
80809a58:	6c696146 6550203a 0d516b65 0000000a     Fail: PeekQ.....
80809a68:	6c696146 6552203a 74754d63 0a0d7865     Fail: RecMutex..
80809a78:	00000000 6c696146 6c25203a 000a0d75     ....Fail: %lu...
80809a88:	73736150 6c25203a 000a0d75 65726f43     Pass: %lu...Core
80809a98:	6c25203a 000a0d64 63656843 0000006b     : %ld...Check...
80809aa8:	756f6853 6e20646c 72657665 61657220     Should never rea
80809ab8:	68206863 21657265 00000a0d 6b636954     ch here!....Tick
80809ac8:	00000a0d 65737341 6f697472 6166206e     ....Assertion fa
80809ad8:	64656c69 20746120 202c7325 656e696c     iled at %s, line
80809ae8:	0a642520 0000000d 6c756e28 0000296c      %d.....(null)..
80809af8:	6e6f4351 00314273 6f725051 00324264     QConsB1.QProdB2.
80809b08:	6f725051 00334264 6e6f4351 00344273     QProdB3.QConsB4.
80809b18:	6f725051 00354264 6e6f4351 00364273     QProdB5.QConsB6.
80809b28:	73655442 00003174 73655442 00003274     BTest1..BTest2..
80809b38:	544d4f43 00000078 524d4f43 00000078     COMTx...COMRx...
80809b48:	31544e43 00000000 32544e43 00000000     CNT1....CNT2....
80809b58:	5f544e43 00434e49 5f4d494c 00434e49     CNT_INC.LIM_INC.
80809b68:	54435f43 00004c52 50535553 0058545f     C_CTRL..SUSP_TX.
80809b78:	50535553 0058525f 516e6547 00000000     SUSP_RX.GenQ....
80809b88:	6f4c754d 00000077 654d754d 00000064     MuLow...MuMed...
80809b98:	6948754d 00006867 4d746e49 00687461     MuHigh..IntMath.
80809ba8:	6e6f4351 00424e73 6f725051 00424e64     QConsNB.QProdNB.
80809bb8:	6b656550 0000004c 6b656550 0000004d     PeekL...PeekM...
80809bc8:	6b656550 00003148 6b656550 00003248     PeekH1..PeekH2..
80809bd8:	31636552 00000000 32636552 00000000     Rec1....Rec2....
80809be8:	33636552 00000000 536c6f50 00314d45     Rec3....PolSEM1.
80809bf8:	536c6f50 00324d45 536b6c42 00314d45     PolSEM2.BlkSEM1.
80809c08:	536b6c42 00324d45                       BlkSEM2.

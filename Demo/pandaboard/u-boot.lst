
u-boot.elf:     file format elf32-littlearm

SYMBOL TABLE:
80800000 l    d  .init	00000000 .init
80800040 l    d  .text	00000000 .text
808027b0 l    d  .rodata	00000000 .rodata
808027c4 l    d  .data	00000000 .data
808027c8 l    d  .bss	00000000 .bss
808078e0 l    d  .heap	00000000 .heap
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .ARM.attributes	00000000 .ARM.attributes
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 obj/Demo/pandaboard/startup.o
0000001f l       *ABS*	00000000 PSR_MASK
00000010 l       *ABS*	00000000 MODE_USR
00000011 l       *ABS*	00000000 MODE_FIQ
00000012 l       *ABS*	00000000 MODE_IRQ
00000013 l       *ABS*	00000000 MODE_SVC
00000017 l       *ABS*	00000000 MODE_ABT
0000001b l       *ABS*	00000000 MODE_UND
0000001f l       *ABS*	00000000 MODE_SYS
00000040 l       *ABS*	00000000 FIQ_BIT
00000080 l       *ABS*	00000000 IRQ_BIT
00000000 l       *ABS*	00000000 EXCEPTION_VECT
80800020 l       .init	00000000 reset_handler_addr
80800024 l       .init	00000000 undef_handler_addr
80800028 l       .init	00000000 swi_handler_addr
8080002c l       .init	00000000 prefetch_abort_handler_addr
80800030 l       .init	00000000 data_abort_handler_addr
80800034 l       .init	00000000 invalid_addr_handler
80800038 l       .init	00000000 irq_handler_addr
8080003c l       .init	00000000 fiq_handler_addr
80802634 l       .text	00000000 reset_handler
808026a0 l       .text	00000000 unhandled
80800040 l       .init	00000000 vectors_end
808026a4 l       .text	00000000 __bss_begin_addr
808026a8 l       .text	00000000 __bss_end_addr
80802644 l       .text	00000000 bss_clear_loop
808026ac l       .text	00000000 svc_stack_addr
00000000 l    df *ABS*	00000000 croutine.c
00000000 l    df *ABS*	00000000 list.c
00000000 l    df *ABS*	00000000 queue.c
808002a0 l     F .text	0000003e prvInitialiseNewQueue
808007c8 l     F .text	000000b8 prvCopyDataToQueue
808009c4 l     F .text	00000030 prvIsQueueFull
808008cc l     F .text	000000a4 prvUnlockQueue
80800880 l     F .text	0000004c prvCopyDataFromQueue
80800970 l     F .text	0000002c prvIsQueueEmpty
00000000 l    df *ABS*	00000000 tasks.c
808027cc l       .bss	00000000 pxReadyTasksLists
80802830 l       .bss	00000000 xDelayedTaskList1
80802844 l       .bss	00000000 xDelayedTaskList2
80802858 l       .bss	00000000 pxDelayedTaskList
8080285c l       .bss	00000000 pxOverflowDelayedTaskList
80802860 l       .bss	00000000 xPendingReadyList
80802874 l       .bss	00000000 xTasksWaitingTermination
80802888 l       .bss	00000000 uxDeletedTasksWaitingCleanUp
8080288c l       .bss	00000000 xSuspendedTaskList
808028a0 l       .bss	00000000 uxCurrentNumberOfTasks
808028a4 l       .bss	00000000 xTickCount
808028a8 l       .bss	00000000 uxTopReadyPriority
808028ac l       .bss	00000000 xSchedulerRunning
808028b0 l       .bss	00000000 uxPendedTicks
808028b4 l       .bss	00000000 xYieldPending
808028b8 l       .bss	00000000 xNumOfOverflows
808028bc l       .bss	00000000 uxTaskNumber
808028c0 l       .bss	00000000 xNextTaskUnblockTime
808028c4 l       .bss	00000000 xIdleTaskHandle
808028c8 l       .bss	00000000 uxSchedulerSuspended
80800aa4 l     F .text	000000d8 prvInitialiseNewTask
80800b7c l     F .text	00000104 prvAddNewTaskToReadyList
80801a9c l     F .text	00000098 prvInitialiseTaskLists
80801bc8 l     F .text	00000020 prvDeleteTCB
80801be8 l     F .text	00000058 prvResetNextTaskUnblockTime
8080214c l     F .text	000000d2 prvAddCurrentTaskToDelayedList
80801074 l     F .text	0000005c prvTaskIsTaskSuspended
80801a7c l     F .text	0000001e prvIdleTask
80801b34 l     F .text	00000094 prvCheckTasksWaitingTermination
00000000 l    df *ABS*	00000000 timers.c
00000000 l    df *ABS*	00000000 heap_2.c
808028cc l       .bss	00000000 ucHeap
808027b6 l     O .rodata	00000002 heapSTRUCT_SIZE
808078cc l       .bss	00000000 xStart
808078d4 l       .bss	00000000 xEnd
808027c4 l     O .data	00000004 xFreeBytesRemaining
808078dc l       .bss	00000000 xHeapHasBeenInitialised.4802
808023fc l     F .text	00000068 prvHeapInit
00000000 l    df *ABS*	00000000 port.c
00000000 l    df *ABS*	00000000 main.c
8080259c l       .text	00000000 __mgpio_set_l2
00000000 l    df *ABS*	00000000 lib_a-memcpy.o
808027a8 l     F .text	00000008 ___main_from_arm
00001000 g       *ABS*	00000000 __ld_Svc_Stack_Size
80801808 g     F .text	00000042 vTaskPlaceOnUnorderedEventList
808023d8 g     F .text	00000016 xPortGetFreeHeapSize
80802470 g     F .text	0000000c vPortExitCritical
80800e20 g     F .text	00000036 uxTaskPriorityGet
808024b0 g     F .text	00000052 kputc
80800408 g     F .text	0000008c xQueueGenericSendFromISR
8080148c g     F .text	0000002c pcTaskGetName
808027c8 g     O .bss	00000004 pxCurrentTCB
80800e8c g     F .text	00000124 vTaskPrioritySet
80802578 g     F .text	00000040 mgpio_set
8080247c g     F .text	0000000e xPortStartScheduler
80801298 g     F .text	0000002a vTaskEndScheduler
808026bc g     F .text	000000ec memcpy
808017d8 g     F .text	0000002e vTaskPlaceOnEventList
80800700 g     F .text	00000042 xQueuePeekFromISR
8080235c g     F .text	0000007c vPortFree
808027c1 g       .rodata	00000000 __rodata_end
80800098 g     F .text	00000046 vListInsertEnd
80801170 g     F .text	000000ae xTaskResumeFromISR
80800080 g     F .text	00000018 vListInitialiseItem
80800e58 g     F .text	00000034 uxTaskPriorityGetFromISR
08000000 g       *ABS*	00000000 __ld_Ram_size
808078e0 g       .bss	00000000 __bss_end
80802220 g     F .text	0000013a pvPortMalloc
808025b8 g     F .text	00000052 _init
808007ac g     F .text	0000001a vQueueDelete
8080248c g     F .text	0000000c vPortEndScheduler
80800040 g     F .text	0000003e vListInitialise
8080142c g     F .text	00000024 xTaskGetTickCount
808002e0 g     F .text	00000128 xQueueGenericSend
8080184c g     F .text	000000ba xTaskRemoveFromEventList
80001000 g       .init	00000000 svc_stack_top
80000000 g       *ABS*	00000000 __ld_Ram_Addr
80800c80 g     F .text	000000da vTaskDelete
808019d8 g     F .text	0000008c xTaskCheckForTimeOut
80801c7c g     F .text	0000009e ulTaskNotifyTake
808012c4 g     F .text	00000022 vTaskSuspendAll
80801450 g     F .text	00000022 xTaskGetTickCountFromISR
80800150 g     F .text	00000052 uxListRemove
80800000 g       .init	00000000 __init_begin
80801670 g     F .text	00000038 vTaskSetApplicationTaskTag
808027c8 g       .data	00000000 __data_end
808020fc g     F .text	0000004e xTaskNotifyStateClear
808010d0 g     F .text	0000009e vTaskResume
80801724 g     F .text	000000b4 vTaskSwitchContext
80801d1c g     F .text	000000c8 xTaskNotifyWait
80800040 g       .init	00000000 __init_end
807ffffc g       .init	00000000 stack_top
80800fb0 g     F .text	000000c2 vTaskSuspend
80801474 g     F .text	00000016 uxTaskGetNumberOfTasks
808027b0 g       .text	00000000 __text_end
00001000 g       *ABS*	00000000 __ld_Irq_Stack_size
80801de4 g     F .text	00000106 xTaskGenericNotify
808000e0 g     F .text	00000070 vListInsert
808016a8 g     F .text	00000038 xTaskGetApplicationTaskTag
80800d5c g     F .text	00000090 vTaskDelayUntil
808027c4 g       .data	00000000 __data_begin
80800674 g     F .text	0000008a xQueueReceiveFromISR
80800248 g     F .text	00000058 xQueueGenericCreate
888078e0 g       .heap	00000000 __heap_end
80800000 g       *ABS*	00000000 __ld_Init_Addr
80801eec g     F .text	0000013c xTaskGenericNotifyFromISR
808078e0 g       .heap	00000000 __heap_begin
80801908 g     F .text	0000009e xTaskRemoveFromUnorderedEventList
808012e8 g     F .text	00000142 xTaskResumeAll
80800764 g     F .text	0000002a uxQueueSpacesAvailable
80801220 g     F .text	00000078 vTaskStartScheduler
808027c8 g       .bss	00000000 __bss_begin
80800000 g       .init	00000000 vectors_start
808009f4 g     F .text	0000002a xQueueIsQueueFullFromISR
808027b0 g       .rodata	00000000 __rodata_begin
80802550 g     F .text	00000028 kputs
80801a64 g     F .text	00000018 vTaskMissedYield
80800744 g     F .text	00000020 uxQueueMessagesWaiting
80800518 g     F .text	0000015a xQueueGenericReceive
808014b8 g     F .text	000001b6 xTaskIncrementTick
808001a4 g     F .text	000000a2 xQueueGenericReset
80800a20 g     F .text	00000082 xTaskCreate
808023f0 g     F .text	0000000c vPortInitialiseBlocks
80802504 g     F .text	0000004c kputhex
80800dec g     F .text	00000034 vTaskDelay
80802498 g     F .text	00000018 pxPortInitialiseStack
808019a8 g     F .text	0000002e vTaskSetTimeOutState
80802464 g     F .text	0000000c vPortEnterCritical
80800790 g     F .text	0000001a uxQueueMessagesWaitingFromISR
8080099c g     F .text	00000026 xQueueIsQueueEmptyFromISR
808016e0 g     F .text	00000044 xTaskCallApplicationTaskHook
80002000 g       .init	00000000 irq_stack_top
80801c40 g     F .text	0000003c uxTaskResetEventItemValue
8080260c g     F .text	0000001c _main
80802028 g     F .text	000000d4 vTaskNotifyGiveFromISR
80800494 g     F .text	00000084 xQueueGiveFromISR
80800040 g       .text	00000000 __text_begin



Disassembly of section .init:

80800000 <__init_begin>:
@ This symbol must be visible to the linker
.global vectors_start

vectors_start:
    @ Exception vectors, relative to the base address, see page 2-26 of DDI0222
    LDR pc, reset_handler_addr             @ Reset (and startup) vector
80800000:	e59ff018 	ldr	pc, [pc, #24]	; 80800020 <reset_handler_addr>
    LDR pc, undef_handler_addr             @ Undefined (unknown) instruction
80800004:	e59ff018 	ldr	pc, [pc, #24]	; 80800024 <undef_handler_addr>
    LDR pc, swi_handler_addr               @ Software interrupt
80800008:	e59ff018 	ldr	pc, [pc, #24]	; 80800028 <swi_handler_addr>
    LDR pc, prefetch_abort_handler_addr    @ Prefetch abort
8080000c:	e59ff018 	ldr	pc, [pc, #24]	; 8080002c <prefetch_abort_handler_addr>
    LDR pc, data_abort_handler_addr        @ Data abort (system bus cannot access a peripheral)
80800010:	e59ff018 	ldr	pc, [pc, #24]	; 80800030 <data_abort_handler_addr>
    LDR pc, invalid_addr_handler           @ Reserved (early ARM only supported 26-bit addresses)
80800014:	e59ff018 	ldr	pc, [pc, #24]	; 80800034 <invalid_addr_handler>
    LDR pc, irq_handler_addr               @ IRQ handler
80800018:	e59ff018 	ldr	pc, [pc, #24]	; 80800038 <irq_handler_addr>
    LDR pc, fiq_handler_addr               @ FIQ handler
8080001c:	e59ff018 	ldr	pc, [pc, #24]	; 8080003c <fiq_handler_addr>

80800020 <reset_handler_addr>:
80800020:	80802634 	.word	0x80802634

80800024 <undef_handler_addr>:
80800024:	808026a0 	.word	0x808026a0

80800028 <swi_handler_addr>:
80800028:	808026a0 	.word	0x808026a0

8080002c <prefetch_abort_handler_addr>:
8080002c:	808026a0 	.word	0x808026a0

80800030 <data_abort_handler_addr>:
80800030:	808026a0 	.word	0x808026a0

80800034 <invalid_addr_handler>:
80800034:	808026a0 	.word	0x808026a0

80800038 <irq_handler_addr>:
80800038:	808026a0 	.word	0x808026a0

8080003c <fiq_handler_addr>:
8080003c:	808026a0 	.word	0x808026a0

Disassembly of section .text:

80800040 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
80800040:	b480      	push	{r7}
80800042:	b083      	sub	sp, #12
80800044:	af00      	add	r7, sp, #0
80800046:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80800048:	687b      	ldr	r3, [r7, #4]
8080004a:	f103 0208 	add.w	r2, r3, #8
8080004e:	687b      	ldr	r3, [r7, #4]
80800050:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
80800052:	687b      	ldr	r3, [r7, #4]
80800054:	f04f 32ff 	mov.w	r2, #4294967295
80800058:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
8080005a:	687b      	ldr	r3, [r7, #4]
8080005c:	f103 0208 	add.w	r2, r3, #8
80800060:	687b      	ldr	r3, [r7, #4]
80800062:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80800064:	687b      	ldr	r3, [r7, #4]
80800066:	f103 0208 	add.w	r2, r3, #8
8080006a:	687b      	ldr	r3, [r7, #4]
8080006c:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
8080006e:	687b      	ldr	r3, [r7, #4]
80800070:	2200      	movs	r2, #0
80800072:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
80800074:	bf00      	nop
80800076:	370c      	adds	r7, #12
80800078:	46bd      	mov	sp, r7
8080007a:	bc80      	pop	{r7}
8080007c:	4770      	bx	lr
8080007e:	bf00      	nop

80800080 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
80800080:	b480      	push	{r7}
80800082:	b083      	sub	sp, #12
80800084:	af00      	add	r7, sp, #0
80800086:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
80800088:	687b      	ldr	r3, [r7, #4]
8080008a:	2200      	movs	r2, #0
8080008c:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
8080008e:	bf00      	nop
80800090:	370c      	adds	r7, #12
80800092:	46bd      	mov	sp, r7
80800094:	bc80      	pop	{r7}
80800096:	4770      	bx	lr

80800098 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
80800098:	b480      	push	{r7}
8080009a:	b085      	sub	sp, #20
8080009c:	af00      	add	r7, sp, #0
8080009e:	6078      	str	r0, [r7, #4]
808000a0:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
808000a2:	687b      	ldr	r3, [r7, #4]
808000a4:	685b      	ldr	r3, [r3, #4]
808000a6:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
808000a8:	683b      	ldr	r3, [r7, #0]
808000aa:	68fa      	ldr	r2, [r7, #12]
808000ac:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
808000ae:	68fb      	ldr	r3, [r7, #12]
808000b0:	689a      	ldr	r2, [r3, #8]
808000b2:	683b      	ldr	r3, [r7, #0]
808000b4:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
808000b6:	68fb      	ldr	r3, [r7, #12]
808000b8:	689b      	ldr	r3, [r3, #8]
808000ba:	683a      	ldr	r2, [r7, #0]
808000bc:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
808000be:	68fb      	ldr	r3, [r7, #12]
808000c0:	683a      	ldr	r2, [r7, #0]
808000c2:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
808000c4:	683b      	ldr	r3, [r7, #0]
808000c6:	687a      	ldr	r2, [r7, #4]
808000c8:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
808000ca:	687b      	ldr	r3, [r7, #4]
808000cc:	681b      	ldr	r3, [r3, #0]
808000ce:	1c5a      	adds	r2, r3, #1
808000d0:	687b      	ldr	r3, [r7, #4]
808000d2:	601a      	str	r2, [r3, #0]
}
808000d4:	bf00      	nop
808000d6:	3714      	adds	r7, #20
808000d8:	46bd      	mov	sp, r7
808000da:	bc80      	pop	{r7}
808000dc:	4770      	bx	lr
808000de:	bf00      	nop

808000e0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
808000e0:	b480      	push	{r7}
808000e2:	b085      	sub	sp, #20
808000e4:	af00      	add	r7, sp, #0
808000e6:	6078      	str	r0, [r7, #4]
808000e8:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
808000ea:	683b      	ldr	r3, [r7, #0]
808000ec:	681b      	ldr	r3, [r3, #0]
808000ee:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
808000f0:	68bb      	ldr	r3, [r7, #8]
808000f2:	f1b3 3fff 	cmp.w	r3, #4294967295
808000f6:	d103      	bne.n	80800100 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
808000f8:	687b      	ldr	r3, [r7, #4]
808000fa:	691b      	ldr	r3, [r3, #16]
808000fc:	60fb      	str	r3, [r7, #12]
808000fe:	e00c      	b.n	8080011a <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
80800100:	687b      	ldr	r3, [r7, #4]
80800102:	3308      	adds	r3, #8
80800104:	60fb      	str	r3, [r7, #12]
80800106:	e002      	b.n	8080010e <vListInsert+0x2e>
80800108:	68fb      	ldr	r3, [r7, #12]
8080010a:	685b      	ldr	r3, [r3, #4]
8080010c:	60fb      	str	r3, [r7, #12]
8080010e:	68fb      	ldr	r3, [r7, #12]
80800110:	685b      	ldr	r3, [r3, #4]
80800112:	681a      	ldr	r2, [r3, #0]
80800114:	68bb      	ldr	r3, [r7, #8]
80800116:	429a      	cmp	r2, r3
80800118:	d9f6      	bls.n	80800108 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
8080011a:	68fb      	ldr	r3, [r7, #12]
8080011c:	685a      	ldr	r2, [r3, #4]
8080011e:	683b      	ldr	r3, [r7, #0]
80800120:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
80800122:	683b      	ldr	r3, [r7, #0]
80800124:	685b      	ldr	r3, [r3, #4]
80800126:	683a      	ldr	r2, [r7, #0]
80800128:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
8080012a:	683b      	ldr	r3, [r7, #0]
8080012c:	68fa      	ldr	r2, [r7, #12]
8080012e:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
80800130:	68fb      	ldr	r3, [r7, #12]
80800132:	683a      	ldr	r2, [r7, #0]
80800134:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
80800136:	683b      	ldr	r3, [r7, #0]
80800138:	687a      	ldr	r2, [r7, #4]
8080013a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
8080013c:	687b      	ldr	r3, [r7, #4]
8080013e:	681b      	ldr	r3, [r3, #0]
80800140:	1c5a      	adds	r2, r3, #1
80800142:	687b      	ldr	r3, [r7, #4]
80800144:	601a      	str	r2, [r3, #0]
}
80800146:	bf00      	nop
80800148:	3714      	adds	r7, #20
8080014a:	46bd      	mov	sp, r7
8080014c:	bc80      	pop	{r7}
8080014e:	4770      	bx	lr

80800150 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
80800150:	b480      	push	{r7}
80800152:	b085      	sub	sp, #20
80800154:	af00      	add	r7, sp, #0
80800156:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
80800158:	687b      	ldr	r3, [r7, #4]
8080015a:	691b      	ldr	r3, [r3, #16]
8080015c:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
8080015e:	687b      	ldr	r3, [r7, #4]
80800160:	685b      	ldr	r3, [r3, #4]
80800162:	687a      	ldr	r2, [r7, #4]
80800164:	6892      	ldr	r2, [r2, #8]
80800166:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
80800168:	687b      	ldr	r3, [r7, #4]
8080016a:	689b      	ldr	r3, [r3, #8]
8080016c:	687a      	ldr	r2, [r7, #4]
8080016e:	6852      	ldr	r2, [r2, #4]
80800170:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
80800172:	68fb      	ldr	r3, [r7, #12]
80800174:	685a      	ldr	r2, [r3, #4]
80800176:	687b      	ldr	r3, [r7, #4]
80800178:	429a      	cmp	r2, r3
8080017a:	d103      	bne.n	80800184 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
8080017c:	687b      	ldr	r3, [r7, #4]
8080017e:	689a      	ldr	r2, [r3, #8]
80800180:	68fb      	ldr	r3, [r7, #12]
80800182:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
80800184:	687b      	ldr	r3, [r7, #4]
80800186:	2200      	movs	r2, #0
80800188:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
8080018a:	68fb      	ldr	r3, [r7, #12]
8080018c:	681b      	ldr	r3, [r3, #0]
8080018e:	1e5a      	subs	r2, r3, #1
80800190:	68fb      	ldr	r3, [r7, #12]
80800192:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
80800194:	68fb      	ldr	r3, [r7, #12]
80800196:	681b      	ldr	r3, [r3, #0]
}
80800198:	4618      	mov	r0, r3
8080019a:	3714      	adds	r7, #20
8080019c:	46bd      	mov	sp, r7
8080019e:	bc80      	pop	{r7}
808001a0:	4770      	bx	lr
808001a2:	bf00      	nop

808001a4 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
808001a4:	b580      	push	{r7, lr}
808001a6:	b084      	sub	sp, #16
808001a8:	af00      	add	r7, sp, #0
808001aa:	6078      	str	r0, [r7, #4]
808001ac:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
808001ae:	687b      	ldr	r3, [r7, #4]
808001b0:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
808001b2:	f002 f957 	bl	80802464 <vPortEnterCritical>
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
808001b6:	68fb      	ldr	r3, [r7, #12]
808001b8:	681a      	ldr	r2, [r3, #0]
808001ba:	68fb      	ldr	r3, [r7, #12]
808001bc:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
808001be:	68f9      	ldr	r1, [r7, #12]
808001c0:	6c09      	ldr	r1, [r1, #64]	; 0x40
808001c2:	fb01 f303 	mul.w	r3, r1, r3
808001c6:	441a      	add	r2, r3
808001c8:	68fb      	ldr	r3, [r7, #12]
808001ca:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
808001cc:	68fb      	ldr	r3, [r7, #12]
808001ce:	2200      	movs	r2, #0
808001d0:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
808001d2:	68fb      	ldr	r3, [r7, #12]
808001d4:	681a      	ldr	r2, [r3, #0]
808001d6:	68fb      	ldr	r3, [r7, #12]
808001d8:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
808001da:	68fb      	ldr	r3, [r7, #12]
808001dc:	681a      	ldr	r2, [r3, #0]
808001de:	68fb      	ldr	r3, [r7, #12]
808001e0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
808001e2:	3b01      	subs	r3, #1
808001e4:	68f9      	ldr	r1, [r7, #12]
808001e6:	6c09      	ldr	r1, [r1, #64]	; 0x40
808001e8:	fb01 f303 	mul.w	r3, r1, r3
808001ec:	441a      	add	r2, r3
808001ee:	68fb      	ldr	r3, [r7, #12]
808001f0:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
808001f2:	68fb      	ldr	r3, [r7, #12]
808001f4:	22ff      	movs	r2, #255	; 0xff
808001f6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
		pxQueue->cTxLock = queueUNLOCKED;
808001fa:	68fb      	ldr	r3, [r7, #12]
808001fc:	22ff      	movs	r2, #255	; 0xff
808001fe:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45

		if( xNewQueue == pdFALSE )
80800202:	683b      	ldr	r3, [r7, #0]
80800204:	2b00      	cmp	r3, #0
80800206:	d10d      	bne.n	80800224 <xQueueGenericReset+0x80>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
80800208:	68fb      	ldr	r3, [r7, #12]
8080020a:	691b      	ldr	r3, [r3, #16]
8080020c:	2b00      	cmp	r3, #0
8080020e:	d013      	beq.n	80800238 <xQueueGenericReset+0x94>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80800210:	68fb      	ldr	r3, [r7, #12]
80800212:	3310      	adds	r3, #16
80800214:	4618      	mov	r0, r3
80800216:	f001 fb19 	bl	8080184c <xTaskRemoveFromEventList>
8080021a:	4603      	mov	r3, r0
8080021c:	2b00      	cmp	r3, #0
8080021e:	d00b      	beq.n	80800238 <xQueueGenericReset+0x94>
				{
					queueYIELD_IF_USING_PREEMPTION();
80800220:	df00      	svc	0
80800222:	e009      	b.n	80800238 <xQueueGenericReset+0x94>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
80800224:	68fb      	ldr	r3, [r7, #12]
80800226:	3310      	adds	r3, #16
80800228:	4618      	mov	r0, r3
8080022a:	f7ff ff09 	bl	80800040 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
8080022e:	68fb      	ldr	r3, [r7, #12]
80800230:	3324      	adds	r3, #36	; 0x24
80800232:	4618      	mov	r0, r3
80800234:	f7ff ff04 	bl	80800040 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
80800238:	f002 f91a 	bl	80802470 <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
8080023c:	2301      	movs	r3, #1
}
8080023e:	4618      	mov	r0, r3
80800240:	3710      	adds	r7, #16
80800242:	46bd      	mov	sp, r7
80800244:	bd80      	pop	{r7, pc}
80800246:	bf00      	nop

80800248 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
80800248:	b580      	push	{r7, lr}
8080024a:	b08a      	sub	sp, #40	; 0x28
8080024c:	af02      	add	r7, sp, #8
8080024e:	60f8      	str	r0, [r7, #12]
80800250:	60b9      	str	r1, [r7, #8]
80800252:	4613      	mov	r3, r2
80800254:	71fb      	strb	r3, [r7, #7]
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
80800256:	68bb      	ldr	r3, [r7, #8]
80800258:	2b00      	cmp	r3, #0
8080025a:	d102      	bne.n	80800262 <xQueueGenericCreate+0x1a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
8080025c:	2300      	movs	r3, #0
8080025e:	61fb      	str	r3, [r7, #28]
80800260:	e004      	b.n	8080026c <xQueueGenericCreate+0x24>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80800262:	68fb      	ldr	r3, [r7, #12]
80800264:	68ba      	ldr	r2, [r7, #8]
80800266:	fb02 f303 	mul.w	r3, r2, r3
8080026a:	61fb      	str	r3, [r7, #28]
		}

		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
8080026c:	69fb      	ldr	r3, [r7, #28]
8080026e:	3348      	adds	r3, #72	; 0x48
80800270:	4618      	mov	r0, r3
80800272:	f001 ffd5 	bl	80802220 <pvPortMalloc>
80800276:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
80800278:	69bb      	ldr	r3, [r7, #24]
8080027a:	2b00      	cmp	r3, #0
8080027c:	d00b      	beq.n	80800296 <xQueueGenericCreate+0x4e>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
8080027e:	69bb      	ldr	r3, [r7, #24]
80800280:	3348      	adds	r3, #72	; 0x48
80800282:	617b      	str	r3, [r7, #20]
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
80800284:	79fa      	ldrb	r2, [r7, #7]
80800286:	69bb      	ldr	r3, [r7, #24]
80800288:	9300      	str	r3, [sp, #0]
8080028a:	4613      	mov	r3, r2
8080028c:	697a      	ldr	r2, [r7, #20]
8080028e:	68b9      	ldr	r1, [r7, #8]
80800290:	68f8      	ldr	r0, [r7, #12]
80800292:	f000 f805 	bl	808002a0 <prvInitialiseNewQueue>
		}

		return pxNewQueue;
80800296:	69bb      	ldr	r3, [r7, #24]
	}
80800298:	4618      	mov	r0, r3
8080029a:	3720      	adds	r7, #32
8080029c:	46bd      	mov	sp, r7
8080029e:	bd80      	pop	{r7, pc}

808002a0 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
808002a0:	b580      	push	{r7, lr}
808002a2:	b084      	sub	sp, #16
808002a4:	af00      	add	r7, sp, #0
808002a6:	60f8      	str	r0, [r7, #12]
808002a8:	60b9      	str	r1, [r7, #8]
808002aa:	607a      	str	r2, [r7, #4]
808002ac:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
808002ae:	68bb      	ldr	r3, [r7, #8]
808002b0:	2b00      	cmp	r3, #0
808002b2:	d103      	bne.n	808002bc <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
808002b4:	69bb      	ldr	r3, [r7, #24]
808002b6:	69ba      	ldr	r2, [r7, #24]
808002b8:	601a      	str	r2, [r3, #0]
808002ba:	e002      	b.n	808002c2 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
808002bc:	69bb      	ldr	r3, [r7, #24]
808002be:	687a      	ldr	r2, [r7, #4]
808002c0:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
808002c2:	69bb      	ldr	r3, [r7, #24]
808002c4:	68fa      	ldr	r2, [r7, #12]
808002c6:	63da      	str	r2, [r3, #60]	; 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
808002c8:	69bb      	ldr	r3, [r7, #24]
808002ca:	68ba      	ldr	r2, [r7, #8]
808002cc:	641a      	str	r2, [r3, #64]	; 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
808002ce:	2101      	movs	r1, #1
808002d0:	69b8      	ldr	r0, [r7, #24]
808002d2:	f7ff ff67 	bl	808001a4 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
808002d6:	bf00      	nop
808002d8:	3710      	adds	r7, #16
808002da:	46bd      	mov	sp, r7
808002dc:	bd80      	pop	{r7, pc}
808002de:	bf00      	nop

808002e0 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
808002e0:	b580      	push	{r7, lr}
808002e2:	b08a      	sub	sp, #40	; 0x28
808002e4:	af00      	add	r7, sp, #0
808002e6:	60f8      	str	r0, [r7, #12]
808002e8:	60b9      	str	r1, [r7, #8]
808002ea:	607a      	str	r2, [r7, #4]
808002ec:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
808002ee:	2300      	movs	r3, #0
808002f0:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
808002f2:	68fb      	ldr	r3, [r7, #12]
808002f4:	623b      	str	r3, [r7, #32]
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
808002f6:	f002 f8b5 	bl	80802464 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
808002fa:	6a3b      	ldr	r3, [r7, #32]
808002fc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
808002fe:	6a3b      	ldr	r3, [r7, #32]
80800300:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
80800302:	429a      	cmp	r2, r3
80800304:	d302      	bcc.n	8080030c <xQueueGenericSend+0x2c>
80800306:	683b      	ldr	r3, [r7, #0]
80800308:	2b02      	cmp	r3, #2
8080030a:	d11b      	bne.n	80800344 <xQueueGenericSend+0x64>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
8080030c:	683a      	ldr	r2, [r7, #0]
8080030e:	68b9      	ldr	r1, [r7, #8]
80800310:	6a38      	ldr	r0, [r7, #32]
80800312:	f000 fa59 	bl	808007c8 <prvCopyDataToQueue>
80800316:	61f8      	str	r0, [r7, #28]
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
80800318:	6a3b      	ldr	r3, [r7, #32]
8080031a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
8080031c:	2b00      	cmp	r3, #0
8080031e:	d009      	beq.n	80800334 <xQueueGenericSend+0x54>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80800320:	6a3b      	ldr	r3, [r7, #32]
80800322:	3324      	adds	r3, #36	; 0x24
80800324:	4618      	mov	r0, r3
80800326:	f001 fa91 	bl	8080184c <xTaskRemoveFromEventList>
8080032a:	4603      	mov	r3, r0
8080032c:	2b00      	cmp	r3, #0
8080032e:	d005      	beq.n	8080033c <xQueueGenericSend+0x5c>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
80800330:	df00      	svc	0
80800332:	e003      	b.n	8080033c <xQueueGenericSend+0x5c>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
80800334:	69fb      	ldr	r3, [r7, #28]
80800336:	2b00      	cmp	r3, #0
80800338:	d000      	beq.n	8080033c <xQueueGenericSend+0x5c>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
8080033a:	df00      	svc	0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
8080033c:	f002 f898 	bl	80802470 <vPortExitCritical>
				return pdPASS;
80800340:	2301      	movs	r3, #1
80800342:	e05d      	b.n	80800400 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
80800344:	687b      	ldr	r3, [r7, #4]
80800346:	2b00      	cmp	r3, #0
80800348:	d103      	bne.n	80800352 <xQueueGenericSend+0x72>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
8080034a:	f002 f891 	bl	80802470 <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
8080034e:	2300      	movs	r3, #0
80800350:	e056      	b.n	80800400 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
80800352:	6a7b      	ldr	r3, [r7, #36]	; 0x24
80800354:	2b00      	cmp	r3, #0
80800356:	d106      	bne.n	80800366 <xQueueGenericSend+0x86>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
80800358:	f107 0314 	add.w	r3, r7, #20
8080035c:	4618      	mov	r0, r3
8080035e:	f001 fb23 	bl	808019a8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
80800362:	2301      	movs	r3, #1
80800364:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
80800366:	f002 f883 	bl	80802470 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
8080036a:	f000 ffab 	bl	808012c4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
8080036e:	f002 f879 	bl	80802464 <vPortEnterCritical>
80800372:	6a3b      	ldr	r3, [r7, #32]
80800374:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
80800378:	b2db      	uxtb	r3, r3
8080037a:	b25b      	sxtb	r3, r3
8080037c:	f1b3 3fff 	cmp.w	r3, #4294967295
80800380:	d103      	bne.n	8080038a <xQueueGenericSend+0xaa>
80800382:	6a3b      	ldr	r3, [r7, #32]
80800384:	2200      	movs	r2, #0
80800386:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
8080038a:	6a3b      	ldr	r3, [r7, #32]
8080038c:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
80800390:	b2db      	uxtb	r3, r3
80800392:	b25b      	sxtb	r3, r3
80800394:	f1b3 3fff 	cmp.w	r3, #4294967295
80800398:	d103      	bne.n	808003a2 <xQueueGenericSend+0xc2>
8080039a:	6a3b      	ldr	r3, [r7, #32]
8080039c:	2200      	movs	r2, #0
8080039e:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
808003a2:	f002 f865 	bl	80802470 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
808003a6:	1d3a      	adds	r2, r7, #4
808003a8:	f107 0314 	add.w	r3, r7, #20
808003ac:	4611      	mov	r1, r2
808003ae:	4618      	mov	r0, r3
808003b0:	f001 fb12 	bl	808019d8 <xTaskCheckForTimeOut>
808003b4:	4603      	mov	r3, r0
808003b6:	2b00      	cmp	r3, #0
808003b8:	d11c      	bne.n	808003f4 <xQueueGenericSend+0x114>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
808003ba:	6a38      	ldr	r0, [r7, #32]
808003bc:	f000 fb02 	bl	808009c4 <prvIsQueueFull>
808003c0:	4603      	mov	r3, r0
808003c2:	2b00      	cmp	r3, #0
808003c4:	d010      	beq.n	808003e8 <xQueueGenericSend+0x108>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
808003c6:	6a3b      	ldr	r3, [r7, #32]
808003c8:	3310      	adds	r3, #16
808003ca:	687a      	ldr	r2, [r7, #4]
808003cc:	4611      	mov	r1, r2
808003ce:	4618      	mov	r0, r3
808003d0:	f001 fa02 	bl	808017d8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
808003d4:	6a38      	ldr	r0, [r7, #32]
808003d6:	f000 fa79 	bl	808008cc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
808003da:	f000 ff85 	bl	808012e8 <xTaskResumeAll>
808003de:	4603      	mov	r3, r0
808003e0:	2b00      	cmp	r3, #0
808003e2:	d188      	bne.n	808002f6 <xQueueGenericSend+0x16>
				{
					portYIELD_WITHIN_API();
808003e4:	df00      	svc	0
808003e6:	e786      	b.n	808002f6 <xQueueGenericSend+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
808003e8:	6a38      	ldr	r0, [r7, #32]
808003ea:	f000 fa6f 	bl	808008cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
808003ee:	f000 ff7b 	bl	808012e8 <xTaskResumeAll>
808003f2:	e780      	b.n	808002f6 <xQueueGenericSend+0x16>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
808003f4:	6a38      	ldr	r0, [r7, #32]
808003f6:	f000 fa69 	bl	808008cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
808003fa:	f000 ff75 	bl	808012e8 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
808003fe:	2300      	movs	r3, #0
		}
	}
}
80800400:	4618      	mov	r0, r3
80800402:	3728      	adds	r7, #40	; 0x28
80800404:	46bd      	mov	sp, r7
80800406:	bd80      	pop	{r7, pc}

80800408 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
80800408:	b580      	push	{r7, lr}
8080040a:	b088      	sub	sp, #32
8080040c:	af00      	add	r7, sp, #0
8080040e:	60f8      	str	r0, [r7, #12]
80800410:	60b9      	str	r1, [r7, #8]
80800412:	607a      	str	r2, [r7, #4]
80800414:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
80800416:	68fb      	ldr	r3, [r7, #12]
80800418:	61bb      	str	r3, [r7, #24]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
8080041a:	2300      	movs	r3, #0
8080041c:	617b      	str	r3, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
8080041e:	69bb      	ldr	r3, [r7, #24]
80800420:	6b9a      	ldr	r2, [r3, #56]	; 0x38
80800422:	69bb      	ldr	r3, [r7, #24]
80800424:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
80800426:	429a      	cmp	r2, r3
80800428:	d302      	bcc.n	80800430 <xQueueGenericSendFromISR+0x28>
8080042a:	683b      	ldr	r3, [r7, #0]
8080042c:	2b02      	cmp	r3, #2
8080042e:	d12a      	bne.n	80800486 <xQueueGenericSendFromISR+0x7e>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
80800430:	69bb      	ldr	r3, [r7, #24]
80800432:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
80800436:	74fb      	strb	r3, [r7, #19]
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
80800438:	683a      	ldr	r2, [r7, #0]
8080043a:	68b9      	ldr	r1, [r7, #8]
8080043c:	69b8      	ldr	r0, [r7, #24]
8080043e:	f000 f9c3 	bl	808007c8 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
80800442:	f997 3013 	ldrsb.w	r3, [r7, #19]
80800446:	f1b3 3fff 	cmp.w	r3, #4294967295
8080044a:	d112      	bne.n	80800472 <xQueueGenericSendFromISR+0x6a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8080044c:	69bb      	ldr	r3, [r7, #24]
8080044e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
80800450:	2b00      	cmp	r3, #0
80800452:	d015      	beq.n	80800480 <xQueueGenericSendFromISR+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80800454:	69bb      	ldr	r3, [r7, #24]
80800456:	3324      	adds	r3, #36	; 0x24
80800458:	4618      	mov	r0, r3
8080045a:	f001 f9f7 	bl	8080184c <xTaskRemoveFromEventList>
8080045e:	4603      	mov	r3, r0
80800460:	2b00      	cmp	r3, #0
80800462:	d00d      	beq.n	80800480 <xQueueGenericSendFromISR+0x78>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
80800464:	687b      	ldr	r3, [r7, #4]
80800466:	2b00      	cmp	r3, #0
80800468:	d00a      	beq.n	80800480 <xQueueGenericSendFromISR+0x78>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
8080046a:	687b      	ldr	r3, [r7, #4]
8080046c:	2201      	movs	r2, #1
8080046e:	601a      	str	r2, [r3, #0]
80800470:	e006      	b.n	80800480 <xQueueGenericSendFromISR+0x78>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
80800472:	7cfb      	ldrb	r3, [r7, #19]
80800474:	3301      	adds	r3, #1
80800476:	b2db      	uxtb	r3, r3
80800478:	b2da      	uxtb	r2, r3
8080047a:	69bb      	ldr	r3, [r7, #24]
8080047c:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
80800480:	2301      	movs	r3, #1
80800482:	61fb      	str	r3, [r7, #28]
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
		{
80800484:	e001      	b.n	8080048a <xQueueGenericSendFromISR+0x82>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
80800486:	2300      	movs	r3, #0
80800488:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
8080048a:	69fb      	ldr	r3, [r7, #28]
}
8080048c:	4618      	mov	r0, r3
8080048e:	3720      	adds	r7, #32
80800490:	46bd      	mov	sp, r7
80800492:	bd80      	pop	{r7, pc}

80800494 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
80800494:	b580      	push	{r7, lr}
80800496:	b088      	sub	sp, #32
80800498:	af00      	add	r7, sp, #0
8080049a:	6078      	str	r0, [r7, #4]
8080049c:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
8080049e:	687b      	ldr	r3, [r7, #4]
808004a0:	61bb      	str	r3, [r7, #24]
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
808004a2:	2300      	movs	r3, #0
808004a4:	617b      	str	r3, [r7, #20]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
808004a6:	69bb      	ldr	r3, [r7, #24]
808004a8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
808004aa:	613b      	str	r3, [r7, #16]

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
808004ac:	69bb      	ldr	r3, [r7, #24]
808004ae:	6bda      	ldr	r2, [r3, #60]	; 0x3c
808004b0:	693b      	ldr	r3, [r7, #16]
808004b2:	429a      	cmp	r2, r3
808004b4:	d929      	bls.n	8080050a <xQueueGiveFromISR+0x76>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
808004b6:	69bb      	ldr	r3, [r7, #24]
808004b8:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
808004bc:	73fb      	strb	r3, [r7, #15]
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
808004be:	693b      	ldr	r3, [r7, #16]
808004c0:	1c5a      	adds	r2, r3, #1
808004c2:	69bb      	ldr	r3, [r7, #24]
808004c4:	639a      	str	r2, [r3, #56]	; 0x38

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
808004c6:	f997 300f 	ldrsb.w	r3, [r7, #15]
808004ca:	f1b3 3fff 	cmp.w	r3, #4294967295
808004ce:	d112      	bne.n	808004f6 <xQueueGiveFromISR+0x62>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808004d0:	69bb      	ldr	r3, [r7, #24]
808004d2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
808004d4:	2b00      	cmp	r3, #0
808004d6:	d015      	beq.n	80800504 <xQueueGiveFromISR+0x70>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
808004d8:	69bb      	ldr	r3, [r7, #24]
808004da:	3324      	adds	r3, #36	; 0x24
808004dc:	4618      	mov	r0, r3
808004de:	f001 f9b5 	bl	8080184c <xTaskRemoveFromEventList>
808004e2:	4603      	mov	r3, r0
808004e4:	2b00      	cmp	r3, #0
808004e6:	d00d      	beq.n	80800504 <xQueueGiveFromISR+0x70>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
808004e8:	683b      	ldr	r3, [r7, #0]
808004ea:	2b00      	cmp	r3, #0
808004ec:	d00a      	beq.n	80800504 <xQueueGiveFromISR+0x70>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
808004ee:	683b      	ldr	r3, [r7, #0]
808004f0:	2201      	movs	r2, #1
808004f2:	601a      	str	r2, [r3, #0]
808004f4:	e006      	b.n	80800504 <xQueueGiveFromISR+0x70>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
808004f6:	7bfb      	ldrb	r3, [r7, #15]
808004f8:	3301      	adds	r3, #1
808004fa:	b2db      	uxtb	r3, r3
808004fc:	b2da      	uxtb	r2, r3
808004fe:	69bb      	ldr	r3, [r7, #24]
80800500:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
			}

			xReturn = pdPASS;
80800504:	2301      	movs	r3, #1
80800506:	61fb      	str	r3, [r7, #28]
80800508:	e001      	b.n	8080050e <xQueueGiveFromISR+0x7a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
8080050a:	2300      	movs	r3, #0
8080050c:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
8080050e:	69fb      	ldr	r3, [r7, #28]
}
80800510:	4618      	mov	r0, r3
80800512:	3720      	adds	r7, #32
80800514:	46bd      	mov	sp, r7
80800516:	bd80      	pop	{r7, pc}

80800518 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
80800518:	b580      	push	{r7, lr}
8080051a:	b08a      	sub	sp, #40	; 0x28
8080051c:	af00      	add	r7, sp, #0
8080051e:	60f8      	str	r0, [r7, #12]
80800520:	60b9      	str	r1, [r7, #8]
80800522:	607a      	str	r2, [r7, #4]
80800524:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
80800526:	2300      	movs	r3, #0
80800528:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
8080052a:	68fb      	ldr	r3, [r7, #12]
8080052c:	623b      	str	r3, [r7, #32]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
8080052e:	f001 ff99 	bl	80802464 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80800532:	6a3b      	ldr	r3, [r7, #32]
80800534:	6b9b      	ldr	r3, [r3, #56]	; 0x38
80800536:	61fb      	str	r3, [r7, #28]

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80800538:	69fb      	ldr	r3, [r7, #28]
8080053a:	2b00      	cmp	r3, #0
8080053c:	d02f      	beq.n	8080059e <xQueueGenericReceive+0x86>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
8080053e:	6a3b      	ldr	r3, [r7, #32]
80800540:	68db      	ldr	r3, [r3, #12]
80800542:	61bb      	str	r3, [r7, #24]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
80800544:	68b9      	ldr	r1, [r7, #8]
80800546:	6a38      	ldr	r0, [r7, #32]
80800548:	f000 f99a 	bl	80800880 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
8080054c:	683b      	ldr	r3, [r7, #0]
8080054e:	2b00      	cmp	r3, #0
80800550:	d111      	bne.n	80800576 <xQueueGenericReceive+0x5e>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
80800552:	69fb      	ldr	r3, [r7, #28]
80800554:	1e5a      	subs	r2, r3, #1
80800556:	6a3b      	ldr	r3, [r7, #32]
80800558:	639a      	str	r2, [r3, #56]	; 0x38
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8080055a:	6a3b      	ldr	r3, [r7, #32]
8080055c:	691b      	ldr	r3, [r3, #16]
8080055e:	2b00      	cmp	r3, #0
80800560:	d019      	beq.n	80800596 <xQueueGenericReceive+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80800562:	6a3b      	ldr	r3, [r7, #32]
80800564:	3310      	adds	r3, #16
80800566:	4618      	mov	r0, r3
80800568:	f001 f970 	bl	8080184c <xTaskRemoveFromEventList>
8080056c:	4603      	mov	r3, r0
8080056e:	2b00      	cmp	r3, #0
80800570:	d011      	beq.n	80800596 <xQueueGenericReceive+0x7e>
						{
							queueYIELD_IF_USING_PREEMPTION();
80800572:	df00      	svc	0
80800574:	e00f      	b.n	80800596 <xQueueGenericReceive+0x7e>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
80800576:	6a3b      	ldr	r3, [r7, #32]
80800578:	69ba      	ldr	r2, [r7, #24]
8080057a:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
8080057c:	6a3b      	ldr	r3, [r7, #32]
8080057e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
80800580:	2b00      	cmp	r3, #0
80800582:	d008      	beq.n	80800596 <xQueueGenericReceive+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
80800584:	6a3b      	ldr	r3, [r7, #32]
80800586:	3324      	adds	r3, #36	; 0x24
80800588:	4618      	mov	r0, r3
8080058a:	f001 f95f 	bl	8080184c <xTaskRemoveFromEventList>
8080058e:	4603      	mov	r3, r0
80800590:	2b00      	cmp	r3, #0
80800592:	d000      	beq.n	80800596 <xQueueGenericReceive+0x7e>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
80800594:	df00      	svc	0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
80800596:	f001 ff6b 	bl	80802470 <vPortExitCritical>
				return pdPASS;
8080059a:	2301      	movs	r3, #1
8080059c:	e065      	b.n	8080066a <xQueueGenericReceive+0x152>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
8080059e:	687b      	ldr	r3, [r7, #4]
808005a0:	2b00      	cmp	r3, #0
808005a2:	d103      	bne.n	808005ac <xQueueGenericReceive+0x94>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
808005a4:	f001 ff64 	bl	80802470 <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
808005a8:	2300      	movs	r3, #0
808005aa:	e05e      	b.n	8080066a <xQueueGenericReceive+0x152>
				}
				else if( xEntryTimeSet == pdFALSE )
808005ac:	6a7b      	ldr	r3, [r7, #36]	; 0x24
808005ae:	2b00      	cmp	r3, #0
808005b0:	d106      	bne.n	808005c0 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
808005b2:	f107 0310 	add.w	r3, r7, #16
808005b6:	4618      	mov	r0, r3
808005b8:	f001 f9f6 	bl	808019a8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
808005bc:	2301      	movs	r3, #1
808005be:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
808005c0:	f001 ff56 	bl	80802470 <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
808005c4:	f000 fe7e 	bl	808012c4 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
808005c8:	f001 ff4c 	bl	80802464 <vPortEnterCritical>
808005cc:	6a3b      	ldr	r3, [r7, #32]
808005ce:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
808005d2:	b2db      	uxtb	r3, r3
808005d4:	b25b      	sxtb	r3, r3
808005d6:	f1b3 3fff 	cmp.w	r3, #4294967295
808005da:	d103      	bne.n	808005e4 <xQueueGenericReceive+0xcc>
808005dc:	6a3b      	ldr	r3, [r7, #32]
808005de:	2200      	movs	r2, #0
808005e0:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
808005e4:	6a3b      	ldr	r3, [r7, #32]
808005e6:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
808005ea:	b2db      	uxtb	r3, r3
808005ec:	b25b      	sxtb	r3, r3
808005ee:	f1b3 3fff 	cmp.w	r3, #4294967295
808005f2:	d103      	bne.n	808005fc <xQueueGenericReceive+0xe4>
808005f4:	6a3b      	ldr	r3, [r7, #32]
808005f6:	2200      	movs	r2, #0
808005f8:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
808005fc:	f001 ff38 	bl	80802470 <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
80800600:	1d3a      	adds	r2, r7, #4
80800602:	f107 0310 	add.w	r3, r7, #16
80800606:	4611      	mov	r1, r2
80800608:	4618      	mov	r0, r3
8080060a:	f001 f9e5 	bl	808019d8 <xTaskCheckForTimeOut>
8080060e:	4603      	mov	r3, r0
80800610:	2b00      	cmp	r3, #0
80800612:	d11d      	bne.n	80800650 <xQueueGenericReceive+0x138>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
80800614:	6a38      	ldr	r0, [r7, #32]
80800616:	f000 f9ab 	bl	80800970 <prvIsQueueEmpty>
8080061a:	4603      	mov	r3, r0
8080061c:	2b00      	cmp	r3, #0
8080061e:	d011      	beq.n	80800644 <xQueueGenericReceive+0x12c>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
80800620:	6a3b      	ldr	r3, [r7, #32]
80800622:	3324      	adds	r3, #36	; 0x24
80800624:	687a      	ldr	r2, [r7, #4]
80800626:	4611      	mov	r1, r2
80800628:	4618      	mov	r0, r3
8080062a:	f001 f8d5 	bl	808017d8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
8080062e:	6a38      	ldr	r0, [r7, #32]
80800630:	f000 f94c 	bl	808008cc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
80800634:	f000 fe58 	bl	808012e8 <xTaskResumeAll>
80800638:	4603      	mov	r3, r0
8080063a:	2b00      	cmp	r3, #0
8080063c:	f47f af77 	bne.w	8080052e <xQueueGenericReceive+0x16>
				{
					portYIELD_WITHIN_API();
80800640:	df00      	svc	0
80800642:	e774      	b.n	8080052e <xQueueGenericReceive+0x16>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
80800644:	6a38      	ldr	r0, [r7, #32]
80800646:	f000 f941 	bl	808008cc <prvUnlockQueue>
				( void ) xTaskResumeAll();
8080064a:	f000 fe4d 	bl	808012e8 <xTaskResumeAll>
8080064e:	e76e      	b.n	8080052e <xQueueGenericReceive+0x16>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
80800650:	6a38      	ldr	r0, [r7, #32]
80800652:	f000 f93b 	bl	808008cc <prvUnlockQueue>
			( void ) xTaskResumeAll();
80800656:	f000 fe47 	bl	808012e8 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
8080065a:	6a38      	ldr	r0, [r7, #32]
8080065c:	f000 f988 	bl	80800970 <prvIsQueueEmpty>
80800660:	4603      	mov	r3, r0
80800662:	2b00      	cmp	r3, #0
80800664:	f43f af63 	beq.w	8080052e <xQueueGenericReceive+0x16>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
80800668:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
8080066a:	4618      	mov	r0, r3
8080066c:	3728      	adds	r7, #40	; 0x28
8080066e:	46bd      	mov	sp, r7
80800670:	bd80      	pop	{r7, pc}
80800672:	bf00      	nop

80800674 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
80800674:	b580      	push	{r7, lr}
80800676:	b08a      	sub	sp, #40	; 0x28
80800678:	af00      	add	r7, sp, #0
8080067a:	60f8      	str	r0, [r7, #12]
8080067c:	60b9      	str	r1, [r7, #8]
8080067e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
80800680:	68fb      	ldr	r3, [r7, #12]
80800682:	623b      	str	r3, [r7, #32]
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80800684:	2300      	movs	r3, #0
80800686:	61fb      	str	r3, [r7, #28]
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
80800688:	6a3b      	ldr	r3, [r7, #32]
8080068a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
8080068c:	61bb      	str	r3, [r7, #24]

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
8080068e:	69bb      	ldr	r3, [r7, #24]
80800690:	2b00      	cmp	r3, #0
80800692:	d02d      	beq.n	808006f0 <xQueueReceiveFromISR+0x7c>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
80800694:	6a3b      	ldr	r3, [r7, #32]
80800696:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
8080069a:	75fb      	strb	r3, [r7, #23]

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
8080069c:	68b9      	ldr	r1, [r7, #8]
8080069e:	6a38      	ldr	r0, [r7, #32]
808006a0:	f000 f8ee 	bl	80800880 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
808006a4:	69bb      	ldr	r3, [r7, #24]
808006a6:	1e5a      	subs	r2, r3, #1
808006a8:	6a3b      	ldr	r3, [r7, #32]
808006aa:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
808006ac:	f997 3017 	ldrsb.w	r3, [r7, #23]
808006b0:	f1b3 3fff 	cmp.w	r3, #4294967295
808006b4:	d112      	bne.n	808006dc <xQueueReceiveFromISR+0x68>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
808006b6:	6a3b      	ldr	r3, [r7, #32]
808006b8:	691b      	ldr	r3, [r3, #16]
808006ba:	2b00      	cmp	r3, #0
808006bc:	d015      	beq.n	808006ea <xQueueReceiveFromISR+0x76>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
808006be:	6a3b      	ldr	r3, [r7, #32]
808006c0:	3310      	adds	r3, #16
808006c2:	4618      	mov	r0, r3
808006c4:	f001 f8c2 	bl	8080184c <xTaskRemoveFromEventList>
808006c8:	4603      	mov	r3, r0
808006ca:	2b00      	cmp	r3, #0
808006cc:	d00d      	beq.n	808006ea <xQueueReceiveFromISR+0x76>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
808006ce:	687b      	ldr	r3, [r7, #4]
808006d0:	2b00      	cmp	r3, #0
808006d2:	d00a      	beq.n	808006ea <xQueueReceiveFromISR+0x76>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
808006d4:	687b      	ldr	r3, [r7, #4]
808006d6:	2201      	movs	r2, #1
808006d8:	601a      	str	r2, [r3, #0]
808006da:	e006      	b.n	808006ea <xQueueReceiveFromISR+0x76>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
808006dc:	7dfb      	ldrb	r3, [r7, #23]
808006de:	3301      	adds	r3, #1
808006e0:	b2db      	uxtb	r3, r3
808006e2:	b2da      	uxtb	r2, r3
808006e4:	6a3b      	ldr	r3, [r7, #32]
808006e6:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
808006ea:	2301      	movs	r3, #1
808006ec:	627b      	str	r3, [r7, #36]	; 0x24
808006ee:	e001      	b.n	808006f4 <xQueueReceiveFromISR+0x80>
		}
		else
		{
			xReturn = pdFAIL;
808006f0:	2300      	movs	r3, #0
808006f2:	627b      	str	r3, [r7, #36]	; 0x24
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
808006f4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
}
808006f6:	4618      	mov	r0, r3
808006f8:	3728      	adds	r7, #40	; 0x28
808006fa:	46bd      	mov	sp, r7
808006fc:	bd80      	pop	{r7, pc}
808006fe:	bf00      	nop

80800700 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
80800700:	b580      	push	{r7, lr}
80800702:	b086      	sub	sp, #24
80800704:	af00      	add	r7, sp, #0
80800706:	6078      	str	r0, [r7, #4]
80800708:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
8080070a:	687b      	ldr	r3, [r7, #4]
8080070c:	613b      	str	r3, [r7, #16]
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
8080070e:	2300      	movs	r3, #0
80800710:	60fb      	str	r3, [r7, #12]
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
80800712:	693b      	ldr	r3, [r7, #16]
80800714:	6b9b      	ldr	r3, [r3, #56]	; 0x38
80800716:	2b00      	cmp	r3, #0
80800718:	d00c      	beq.n	80800734 <xQueuePeekFromISR+0x34>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
8080071a:	693b      	ldr	r3, [r7, #16]
8080071c:	68db      	ldr	r3, [r3, #12]
8080071e:	60bb      	str	r3, [r7, #8]
			prvCopyDataFromQueue( pxQueue, pvBuffer );
80800720:	6839      	ldr	r1, [r7, #0]
80800722:	6938      	ldr	r0, [r7, #16]
80800724:	f000 f8ac 	bl	80800880 <prvCopyDataFromQueue>
			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
80800728:	693b      	ldr	r3, [r7, #16]
8080072a:	68ba      	ldr	r2, [r7, #8]
8080072c:	60da      	str	r2, [r3, #12]

			xReturn = pdPASS;
8080072e:	2301      	movs	r3, #1
80800730:	617b      	str	r3, [r7, #20]
80800732:	e001      	b.n	80800738 <xQueuePeekFromISR+0x38>
		}
		else
		{
			xReturn = pdFAIL;
80800734:	2300      	movs	r3, #0
80800736:	617b      	str	r3, [r7, #20]
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
80800738:	697b      	ldr	r3, [r7, #20]
}
8080073a:	4618      	mov	r0, r3
8080073c:	3718      	adds	r7, #24
8080073e:	46bd      	mov	sp, r7
80800740:	bd80      	pop	{r7, pc}
80800742:	bf00      	nop

80800744 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
80800744:	b580      	push	{r7, lr}
80800746:	b084      	sub	sp, #16
80800748:	af00      	add	r7, sp, #0
8080074a:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
8080074c:	f001 fe8a 	bl	80802464 <vPortEnterCritical>
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
80800750:	687b      	ldr	r3, [r7, #4]
80800752:	6b9b      	ldr	r3, [r3, #56]	; 0x38
80800754:	60fb      	str	r3, [r7, #12]
	}
	taskEXIT_CRITICAL();
80800756:	f001 fe8b 	bl	80802470 <vPortExitCritical>

	return uxReturn;
8080075a:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
8080075c:	4618      	mov	r0, r3
8080075e:	3710      	adds	r7, #16
80800760:	46bd      	mov	sp, r7
80800762:	bd80      	pop	{r7, pc}

80800764 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
80800764:	b580      	push	{r7, lr}
80800766:	b084      	sub	sp, #16
80800768:	af00      	add	r7, sp, #0
8080076a:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;
Queue_t *pxQueue;

	pxQueue = ( Queue_t * ) xQueue;
8080076c:	687b      	ldr	r3, [r7, #4]
8080076e:	60fb      	str	r3, [r7, #12]
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
80800770:	f001 fe78 	bl	80802464 <vPortEnterCritical>
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
80800774:	68fb      	ldr	r3, [r7, #12]
80800776:	6bda      	ldr	r2, [r3, #60]	; 0x3c
80800778:	68fb      	ldr	r3, [r7, #12]
8080077a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
8080077c:	1ad3      	subs	r3, r2, r3
8080077e:	60bb      	str	r3, [r7, #8]
	}
	taskEXIT_CRITICAL();
80800780:	f001 fe76 	bl	80802470 <vPortExitCritical>

	return uxReturn;
80800784:	68bb      	ldr	r3, [r7, #8]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
80800786:	4618      	mov	r0, r3
80800788:	3710      	adds	r7, #16
8080078a:	46bd      	mov	sp, r7
8080078c:	bd80      	pop	{r7, pc}
8080078e:	bf00      	nop

80800790 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
80800790:	b480      	push	{r7}
80800792:	b085      	sub	sp, #20
80800794:	af00      	add	r7, sp, #0
80800796:	6078      	str	r0, [r7, #4]
UBaseType_t uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
80800798:	687b      	ldr	r3, [r7, #4]
8080079a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
8080079c:	60fb      	str	r3, [r7, #12]

	return uxReturn;
8080079e:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
808007a0:	4618      	mov	r0, r3
808007a2:	3714      	adds	r7, #20
808007a4:	46bd      	mov	sp, r7
808007a6:	bc80      	pop	{r7}
808007a8:	4770      	bx	lr
808007aa:	bf00      	nop

808007ac <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
808007ac:	b580      	push	{r7, lr}
808007ae:	b084      	sub	sp, #16
808007b0:	af00      	add	r7, sp, #0
808007b2:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
808007b4:	687b      	ldr	r3, [r7, #4]
808007b6:	60fb      	str	r3, [r7, #12]

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
808007b8:	68f8      	ldr	r0, [r7, #12]
808007ba:	f001 fdcf 	bl	8080235c <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
808007be:	bf00      	nop
808007c0:	3710      	adds	r7, #16
808007c2:	46bd      	mov	sp, r7
808007c4:	bd80      	pop	{r7, pc}
808007c6:	bf00      	nop

808007c8 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
808007c8:	b580      	push	{r7, lr}
808007ca:	b086      	sub	sp, #24
808007cc:	af00      	add	r7, sp, #0
808007ce:	60f8      	str	r0, [r7, #12]
808007d0:	60b9      	str	r1, [r7, #8]
808007d2:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
808007d4:	2300      	movs	r3, #0
808007d6:	613b      	str	r3, [r7, #16]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
808007d8:	68fb      	ldr	r3, [r7, #12]
808007da:	6b9b      	ldr	r3, [r3, #56]	; 0x38
808007dc:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
808007de:	68fb      	ldr	r3, [r7, #12]
808007e0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
808007e2:	2b00      	cmp	r3, #0
808007e4:	d043      	beq.n	8080086e <prvCopyDataToQueue+0xa6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
808007e6:	687b      	ldr	r3, [r7, #4]
808007e8:	2b00      	cmp	r3, #0
808007ea:	d119      	bne.n	80800820 <prvCopyDataToQueue+0x58>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
808007ec:	68fb      	ldr	r3, [r7, #12]
808007ee:	6898      	ldr	r0, [r3, #8]
808007f0:	68fb      	ldr	r3, [r7, #12]
808007f2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
808007f4:	461a      	mov	r2, r3
808007f6:	68b9      	ldr	r1, [r7, #8]
808007f8:	f001 ff60 	bl	808026bc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
808007fc:	68fb      	ldr	r3, [r7, #12]
808007fe:	689a      	ldr	r2, [r3, #8]
80800800:	68fb      	ldr	r3, [r7, #12]
80800802:	6c1b      	ldr	r3, [r3, #64]	; 0x40
80800804:	441a      	add	r2, r3
80800806:	68fb      	ldr	r3, [r7, #12]
80800808:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
8080080a:	68fb      	ldr	r3, [r7, #12]
8080080c:	689a      	ldr	r2, [r3, #8]
8080080e:	68fb      	ldr	r3, [r7, #12]
80800810:	685b      	ldr	r3, [r3, #4]
80800812:	429a      	cmp	r2, r3
80800814:	d32b      	bcc.n	8080086e <prvCopyDataToQueue+0xa6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
80800816:	68fb      	ldr	r3, [r7, #12]
80800818:	681a      	ldr	r2, [r3, #0]
8080081a:	68fb      	ldr	r3, [r7, #12]
8080081c:	609a      	str	r2, [r3, #8]
8080081e:	e026      	b.n	8080086e <prvCopyDataToQueue+0xa6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80800820:	68fb      	ldr	r3, [r7, #12]
80800822:	68d8      	ldr	r0, [r3, #12]
80800824:	68fb      	ldr	r3, [r7, #12]
80800826:	6c1b      	ldr	r3, [r3, #64]	; 0x40
80800828:	461a      	mov	r2, r3
8080082a:	68b9      	ldr	r1, [r7, #8]
8080082c:	f001 ff46 	bl	808026bc <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
80800830:	68fb      	ldr	r3, [r7, #12]
80800832:	68da      	ldr	r2, [r3, #12]
80800834:	68fb      	ldr	r3, [r7, #12]
80800836:	6c1b      	ldr	r3, [r3, #64]	; 0x40
80800838:	425b      	negs	r3, r3
8080083a:	441a      	add	r2, r3
8080083c:	68fb      	ldr	r3, [r7, #12]
8080083e:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
80800840:	68fb      	ldr	r3, [r7, #12]
80800842:	68da      	ldr	r2, [r3, #12]
80800844:	68fb      	ldr	r3, [r7, #12]
80800846:	681b      	ldr	r3, [r3, #0]
80800848:	429a      	cmp	r2, r3
8080084a:	d207      	bcs.n	8080085c <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
8080084c:	68fb      	ldr	r3, [r7, #12]
8080084e:	685a      	ldr	r2, [r3, #4]
80800850:	68fb      	ldr	r3, [r7, #12]
80800852:	6c1b      	ldr	r3, [r3, #64]	; 0x40
80800854:	425b      	negs	r3, r3
80800856:	441a      	add	r2, r3
80800858:	68fb      	ldr	r3, [r7, #12]
8080085a:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
8080085c:	687b      	ldr	r3, [r7, #4]
8080085e:	2b02      	cmp	r3, #2
80800860:	d105      	bne.n	8080086e <prvCopyDataToQueue+0xa6>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
80800862:	697b      	ldr	r3, [r7, #20]
80800864:	2b00      	cmp	r3, #0
80800866:	d002      	beq.n	8080086e <prvCopyDataToQueue+0xa6>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
80800868:	697b      	ldr	r3, [r7, #20]
8080086a:	3b01      	subs	r3, #1
8080086c:	617b      	str	r3, [r7, #20]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
8080086e:	697b      	ldr	r3, [r7, #20]
80800870:	1c5a      	adds	r2, r3, #1
80800872:	68fb      	ldr	r3, [r7, #12]
80800874:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
80800876:	693b      	ldr	r3, [r7, #16]
}
80800878:	4618      	mov	r0, r3
8080087a:	3718      	adds	r7, #24
8080087c:	46bd      	mov	sp, r7
8080087e:	bd80      	pop	{r7, pc}

80800880 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
80800880:	b580      	push	{r7, lr}
80800882:	b082      	sub	sp, #8
80800884:	af00      	add	r7, sp, #0
80800886:	6078      	str	r0, [r7, #4]
80800888:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
8080088a:	687b      	ldr	r3, [r7, #4]
8080088c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
8080088e:	2b00      	cmp	r3, #0
80800890:	d018      	beq.n	808008c4 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
80800892:	687b      	ldr	r3, [r7, #4]
80800894:	68da      	ldr	r2, [r3, #12]
80800896:	687b      	ldr	r3, [r7, #4]
80800898:	6c1b      	ldr	r3, [r3, #64]	; 0x40
8080089a:	441a      	add	r2, r3
8080089c:	687b      	ldr	r3, [r7, #4]
8080089e:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
808008a0:	687b      	ldr	r3, [r7, #4]
808008a2:	68da      	ldr	r2, [r3, #12]
808008a4:	687b      	ldr	r3, [r7, #4]
808008a6:	685b      	ldr	r3, [r3, #4]
808008a8:	429a      	cmp	r2, r3
808008aa:	d303      	bcc.n	808008b4 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
808008ac:	687b      	ldr	r3, [r7, #4]
808008ae:	681a      	ldr	r2, [r3, #0]
808008b0:	687b      	ldr	r3, [r7, #4]
808008b2:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
808008b4:	687b      	ldr	r3, [r7, #4]
808008b6:	68d9      	ldr	r1, [r3, #12]
808008b8:	687b      	ldr	r3, [r7, #4]
808008ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
808008bc:	461a      	mov	r2, r3
808008be:	6838      	ldr	r0, [r7, #0]
808008c0:	f001 fefc 	bl	808026bc <memcpy>
	}
}
808008c4:	bf00      	nop
808008c6:	3708      	adds	r7, #8
808008c8:	46bd      	mov	sp, r7
808008ca:	bd80      	pop	{r7, pc}

808008cc <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
808008cc:	b580      	push	{r7, lr}
808008ce:	b084      	sub	sp, #16
808008d0:	af00      	add	r7, sp, #0
808008d2:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
808008d4:	f001 fdc6 	bl	80802464 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
808008d8:	687b      	ldr	r3, [r7, #4]
808008da:	f893 3045 	ldrb.w	r3, [r3, #69]	; 0x45
808008de:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
808008e0:	e011      	b.n	80800906 <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
808008e2:	687b      	ldr	r3, [r7, #4]
808008e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
808008e6:	2b00      	cmp	r3, #0
808008e8:	d012      	beq.n	80800910 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
808008ea:	687b      	ldr	r3, [r7, #4]
808008ec:	3324      	adds	r3, #36	; 0x24
808008ee:	4618      	mov	r0, r3
808008f0:	f000 ffac 	bl	8080184c <xTaskRemoveFromEventList>
808008f4:	4603      	mov	r3, r0
808008f6:	2b00      	cmp	r3, #0
808008f8:	d001      	beq.n	808008fe <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
808008fa:	f001 f8b3 	bl	80801a64 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
808008fe:	7bfb      	ldrb	r3, [r7, #15]
80800900:	3b01      	subs	r3, #1
80800902:	b2db      	uxtb	r3, r3
80800904:	73fb      	strb	r3, [r7, #15]
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
80800906:	f997 300f 	ldrsb.w	r3, [r7, #15]
8080090a:	2b00      	cmp	r3, #0
8080090c:	dce9      	bgt.n	808008e2 <prvUnlockQueue+0x16>
8080090e:	e000      	b.n	80800912 <prvUnlockQueue+0x46>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
80800910:	bf00      	nop
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
80800912:	687b      	ldr	r3, [r7, #4]
80800914:	22ff      	movs	r2, #255	; 0xff
80800916:	f883 2045 	strb.w	r2, [r3, #69]	; 0x45
	}
	taskEXIT_CRITICAL();
8080091a:	f001 fda9 	bl	80802470 <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
8080091e:	f001 fda1 	bl	80802464 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
80800922:	687b      	ldr	r3, [r7, #4]
80800924:	f893 3044 	ldrb.w	r3, [r3, #68]	; 0x44
80800928:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
8080092a:	e011      	b.n	80800950 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
8080092c:	687b      	ldr	r3, [r7, #4]
8080092e:	691b      	ldr	r3, [r3, #16]
80800930:	2b00      	cmp	r3, #0
80800932:	d012      	beq.n	8080095a <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
80800934:	687b      	ldr	r3, [r7, #4]
80800936:	3310      	adds	r3, #16
80800938:	4618      	mov	r0, r3
8080093a:	f000 ff87 	bl	8080184c <xTaskRemoveFromEventList>
8080093e:	4603      	mov	r3, r0
80800940:	2b00      	cmp	r3, #0
80800942:	d001      	beq.n	80800948 <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
80800944:	f001 f88e 	bl	80801a64 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
80800948:	7bbb      	ldrb	r3, [r7, #14]
8080094a:	3b01      	subs	r3, #1
8080094c:	b2db      	uxtb	r3, r3
8080094e:	73bb      	strb	r3, [r7, #14]
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
80800950:	f997 300e 	ldrsb.w	r3, [r7, #14]
80800954:	2b00      	cmp	r3, #0
80800956:	dce9      	bgt.n	8080092c <prvUnlockQueue+0x60>
80800958:	e000      	b.n	8080095c <prvUnlockQueue+0x90>

				--cRxLock;
			}
			else
			{
				break;
8080095a:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
8080095c:	687b      	ldr	r3, [r7, #4]
8080095e:	22ff      	movs	r2, #255	; 0xff
80800960:	f883 2044 	strb.w	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
80800964:	f001 fd84 	bl	80802470 <vPortExitCritical>
}
80800968:	bf00      	nop
8080096a:	3710      	adds	r7, #16
8080096c:	46bd      	mov	sp, r7
8080096e:	bd80      	pop	{r7, pc}

80800970 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
80800970:	b580      	push	{r7, lr}
80800972:	b084      	sub	sp, #16
80800974:	af00      	add	r7, sp, #0
80800976:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
80800978:	f001 fd74 	bl	80802464 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
8080097c:	687b      	ldr	r3, [r7, #4]
8080097e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
80800980:	2b00      	cmp	r3, #0
80800982:	d102      	bne.n	8080098a <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
80800984:	2301      	movs	r3, #1
80800986:	60fb      	str	r3, [r7, #12]
80800988:	e001      	b.n	8080098e <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
8080098a:	2300      	movs	r3, #0
8080098c:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
8080098e:	f001 fd6f 	bl	80802470 <vPortExitCritical>

	return xReturn;
80800992:	68fb      	ldr	r3, [r7, #12]
}
80800994:	4618      	mov	r0, r3
80800996:	3710      	adds	r7, #16
80800998:	46bd      	mov	sp, r7
8080099a:	bd80      	pop	{r7, pc}

8080099c <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
8080099c:	b480      	push	{r7}
8080099e:	b085      	sub	sp, #20
808009a0:	af00      	add	r7, sp, #0
808009a2:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
808009a4:	687b      	ldr	r3, [r7, #4]
808009a6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
808009a8:	2b00      	cmp	r3, #0
808009aa:	d102      	bne.n	808009b2 <xQueueIsQueueEmptyFromISR+0x16>
	{
		xReturn = pdTRUE;
808009ac:	2301      	movs	r3, #1
808009ae:	60fb      	str	r3, [r7, #12]
808009b0:	e001      	b.n	808009b6 <xQueueIsQueueEmptyFromISR+0x1a>
	}
	else
	{
		xReturn = pdFALSE;
808009b2:	2300      	movs	r3, #0
808009b4:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
808009b6:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
808009b8:	4618      	mov	r0, r3
808009ba:	3714      	adds	r7, #20
808009bc:	46bd      	mov	sp, r7
808009be:	bc80      	pop	{r7}
808009c0:	4770      	bx	lr
808009c2:	bf00      	nop

808009c4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
808009c4:	b580      	push	{r7, lr}
808009c6:	b084      	sub	sp, #16
808009c8:	af00      	add	r7, sp, #0
808009ca:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
808009cc:	f001 fd4a 	bl	80802464 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
808009d0:	687b      	ldr	r3, [r7, #4]
808009d2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
808009d4:	687b      	ldr	r3, [r7, #4]
808009d6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
808009d8:	429a      	cmp	r2, r3
808009da:	d102      	bne.n	808009e2 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
808009dc:	2301      	movs	r3, #1
808009de:	60fb      	str	r3, [r7, #12]
808009e0:	e001      	b.n	808009e6 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
808009e2:	2300      	movs	r3, #0
808009e4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
808009e6:	f001 fd43 	bl	80802470 <vPortExitCritical>

	return xReturn;
808009ea:	68fb      	ldr	r3, [r7, #12]
}
808009ec:	4618      	mov	r0, r3
808009ee:	3710      	adds	r7, #16
808009f0:	46bd      	mov	sp, r7
808009f2:	bd80      	pop	{r7, pc}

808009f4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
808009f4:	b480      	push	{r7}
808009f6:	b085      	sub	sp, #20
808009f8:	af00      	add	r7, sp, #0
808009fa:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	configASSERT( xQueue );
	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
808009fc:	687b      	ldr	r3, [r7, #4]
808009fe:	6b9a      	ldr	r2, [r3, #56]	; 0x38
80800a00:	687b      	ldr	r3, [r7, #4]
80800a02:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
80800a04:	429a      	cmp	r2, r3
80800a06:	d102      	bne.n	80800a0e <xQueueIsQueueFullFromISR+0x1a>
	{
		xReturn = pdTRUE;
80800a08:	2301      	movs	r3, #1
80800a0a:	60fb      	str	r3, [r7, #12]
80800a0c:	e001      	b.n	80800a12 <xQueueIsQueueFullFromISR+0x1e>
	}
	else
	{
		xReturn = pdFALSE;
80800a0e:	2300      	movs	r3, #0
80800a10:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
80800a12:	68fb      	ldr	r3, [r7, #12]
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
80800a14:	4618      	mov	r0, r3
80800a16:	3714      	adds	r7, #20
80800a18:	46bd      	mov	sp, r7
80800a1a:	bc80      	pop	{r7}
80800a1c:	4770      	bx	lr
80800a1e:	bf00      	nop

80800a20 <xTaskCreate>:
							const char * const pcName,
							const uint16_t usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
80800a20:	b580      	push	{r7, lr}
80800a22:	b08c      	sub	sp, #48	; 0x30
80800a24:	af04      	add	r7, sp, #16
80800a26:	60f8      	str	r0, [r7, #12]
80800a28:	60b9      	str	r1, [r7, #8]
80800a2a:	603b      	str	r3, [r7, #0]
80800a2c:	4613      	mov	r3, r2
80800a2e:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80800a30:	88fb      	ldrh	r3, [r7, #6]
80800a32:	009b      	lsls	r3, r3, #2
80800a34:	4618      	mov	r0, r3
80800a36:	f001 fbf3 	bl	80802220 <pvPortMalloc>
80800a3a:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
80800a3c:	697b      	ldr	r3, [r7, #20]
80800a3e:	2b00      	cmp	r3, #0
80800a40:	d00e      	beq.n	80800a60 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
80800a42:	2050      	movs	r0, #80	; 0x50
80800a44:	f001 fbec 	bl	80802220 <pvPortMalloc>
80800a48:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
80800a4a:	69fb      	ldr	r3, [r7, #28]
80800a4c:	2b00      	cmp	r3, #0
80800a4e:	d003      	beq.n	80800a58 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
80800a50:	69fb      	ldr	r3, [r7, #28]
80800a52:	697a      	ldr	r2, [r7, #20]
80800a54:	631a      	str	r2, [r3, #48]	; 0x30
80800a56:	e005      	b.n	80800a64 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
80800a58:	6978      	ldr	r0, [r7, #20]
80800a5a:	f001 fc7f 	bl	8080235c <vPortFree>
80800a5e:	e001      	b.n	80800a64 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
80800a60:	2300      	movs	r3, #0
80800a62:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
80800a64:	69fb      	ldr	r3, [r7, #28]
80800a66:	2b00      	cmp	r3, #0
80800a68:	d013      	beq.n	80800a92 <xTaskCreate+0x72>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
80800a6a:	88fa      	ldrh	r2, [r7, #6]
80800a6c:	2300      	movs	r3, #0
80800a6e:	9303      	str	r3, [sp, #12]
80800a70:	69fb      	ldr	r3, [r7, #28]
80800a72:	9302      	str	r3, [sp, #8]
80800a74:	6afb      	ldr	r3, [r7, #44]	; 0x2c
80800a76:	9301      	str	r3, [sp, #4]
80800a78:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800a7a:	9300      	str	r3, [sp, #0]
80800a7c:	683b      	ldr	r3, [r7, #0]
80800a7e:	68b9      	ldr	r1, [r7, #8]
80800a80:	68f8      	ldr	r0, [r7, #12]
80800a82:	f000 f80f 	bl	80800aa4 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
80800a86:	69f8      	ldr	r0, [r7, #28]
80800a88:	f000 f878 	bl	80800b7c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
80800a8c:	2301      	movs	r3, #1
80800a8e:	61bb      	str	r3, [r7, #24]
80800a90:	e002      	b.n	80800a98 <xTaskCreate+0x78>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
80800a92:	f04f 33ff 	mov.w	r3, #4294967295
80800a96:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
80800a98:	69bb      	ldr	r3, [r7, #24]
	}
80800a9a:	4618      	mov	r0, r3
80800a9c:	3720      	adds	r7, #32
80800a9e:	46bd      	mov	sp, r7
80800aa0:	bd80      	pop	{r7, pc}
80800aa2:	bf00      	nop

80800aa4 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
80800aa4:	b580      	push	{r7, lr}
80800aa6:	b086      	sub	sp, #24
80800aa8:	af00      	add	r7, sp, #0
80800aaa:	60f8      	str	r0, [r7, #12]
80800aac:	60b9      	str	r1, [r7, #8]
80800aae:	607a      	str	r2, [r7, #4]
80800ab0:	603b      	str	r3, [r7, #0]
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
80800ab2:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800ab4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
80800ab6:	687b      	ldr	r3, [r7, #4]
80800ab8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
80800abc:	3b01      	subs	r3, #1
80800abe:	009b      	lsls	r3, r3, #2
80800ac0:	4413      	add	r3, r2
80800ac2:	613b      	str	r3, [r7, #16]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
80800ac4:	693b      	ldr	r3, [r7, #16]
80800ac6:	f023 0307 	bic.w	r3, r3, #7
80800aca:	613b      	str	r3, [r7, #16]
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
80800acc:	2300      	movs	r3, #0
80800ace:	617b      	str	r3, [r7, #20]
80800ad0:	e012      	b.n	80800af8 <prvInitialiseNewTask+0x54>
	{
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
80800ad2:	68ba      	ldr	r2, [r7, #8]
80800ad4:	697b      	ldr	r3, [r7, #20]
80800ad6:	4413      	add	r3, r2
80800ad8:	7819      	ldrb	r1, [r3, #0]
80800ada:	6aba      	ldr	r2, [r7, #40]	; 0x28
80800adc:	697b      	ldr	r3, [r7, #20]
80800ade:	4413      	add	r3, r2
80800ae0:	3334      	adds	r3, #52	; 0x34
80800ae2:	460a      	mov	r2, r1
80800ae4:	701a      	strb	r2, [r3, #0]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
80800ae6:	68ba      	ldr	r2, [r7, #8]
80800ae8:	697b      	ldr	r3, [r7, #20]
80800aea:	4413      	add	r3, r2
80800aec:	781b      	ldrb	r3, [r3, #0]
80800aee:	2b00      	cmp	r3, #0
80800af0:	d006      	beq.n	80800b00 <prvInitialiseNewTask+0x5c>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
80800af2:	697b      	ldr	r3, [r7, #20]
80800af4:	3301      	adds	r3, #1
80800af6:	617b      	str	r3, [r7, #20]
80800af8:	697b      	ldr	r3, [r7, #20]
80800afa:	2b0f      	cmp	r3, #15
80800afc:	d9e9      	bls.n	80800ad2 <prvInitialiseNewTask+0x2e>
80800afe:	e000      	b.n	80800b02 <prvInitialiseNewTask+0x5e>
		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
		{
			break;
80800b00:	bf00      	nop
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
80800b02:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b04:	2200      	movs	r2, #0
80800b06:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
80800b0a:	6a3b      	ldr	r3, [r7, #32]
80800b0c:	2b04      	cmp	r3, #4
80800b0e:	d901      	bls.n	80800b14 <prvInitialiseNewTask+0x70>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
80800b10:	2304      	movs	r3, #4
80800b12:	623b      	str	r3, [r7, #32]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
80800b14:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b16:	6a3a      	ldr	r2, [r7, #32]
80800b18:	62da      	str	r2, [r3, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
80800b1a:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b1c:	3304      	adds	r3, #4
80800b1e:	4618      	mov	r0, r3
80800b20:	f7ff faae 	bl	80800080 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
80800b24:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b26:	3318      	adds	r3, #24
80800b28:	4618      	mov	r0, r3
80800b2a:	f7ff faa9 	bl	80800080 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
80800b2e:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b30:	6aba      	ldr	r2, [r7, #40]	; 0x28
80800b32:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80800b34:	6a3b      	ldr	r3, [r7, #32]
80800b36:	f1c3 0205 	rsb	r2, r3, #5
80800b3a:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b3c:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
80800b3e:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b40:	6aba      	ldr	r2, [r7, #40]	; 0x28
80800b42:	625a      	str	r2, [r3, #36]	; 0x24
	}
	#endif /* portCRITICAL_NESTING_IN_TCB */

	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
	{
		pxNewTCB->pxTaskTag = NULL;
80800b44:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b46:	2200      	movs	r2, #0
80800b48:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
80800b4a:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b4c:	2200      	movs	r2, #0
80800b4e:	649a      	str	r2, [r3, #72]	; 0x48
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
80800b50:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b52:	2200      	movs	r2, #0
80800b54:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
	}
	#else /* portUSING_MPU_WRAPPERS */
	{
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
80800b58:	683a      	ldr	r2, [r7, #0]
80800b5a:	68f9      	ldr	r1, [r7, #12]
80800b5c:	6938      	ldr	r0, [r7, #16]
80800b5e:	f001 fc9b 	bl	80802498 <pxPortInitialiseStack>
80800b62:	4602      	mov	r2, r0
80800b64:	6abb      	ldr	r3, [r7, #40]	; 0x28
80800b66:	601a      	str	r2, [r3, #0]
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( ( void * ) pxCreatedTask != NULL )
80800b68:	6a7b      	ldr	r3, [r7, #36]	; 0x24
80800b6a:	2b00      	cmp	r3, #0
80800b6c:	d002      	beq.n	80800b74 <prvInitialiseNewTask+0xd0>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
80800b6e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
80800b70:	6aba      	ldr	r2, [r7, #40]	; 0x28
80800b72:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
80800b74:	bf00      	nop
80800b76:	3718      	adds	r7, #24
80800b78:	46bd      	mov	sp, r7
80800b7a:	bd80      	pop	{r7, pc}

80800b7c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
80800b7c:	b580      	push	{r7, lr}
80800b7e:	b082      	sub	sp, #8
80800b80:	af00      	add	r7, sp, #0
80800b82:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
80800b84:	f001 fc6e 	bl	80802464 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
80800b88:	f642 03a0 	movw	r3, #10400	; 0x28a0
80800b8c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800b90:	681b      	ldr	r3, [r3, #0]
80800b92:	1c5a      	adds	r2, r3, #1
80800b94:	f642 03a0 	movw	r3, #10400	; 0x28a0
80800b98:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800b9c:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
80800b9e:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800ba2:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800ba6:	681b      	ldr	r3, [r3, #0]
80800ba8:	2b00      	cmp	r3, #0
80800baa:	d10f      	bne.n	80800bcc <prvAddNewTaskToReadyList+0x50>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
80800bac:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800bb0:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800bb4:	687a      	ldr	r2, [r7, #4]
80800bb6:	601a      	str	r2, [r3, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
80800bb8:	f642 03a0 	movw	r3, #10400	; 0x28a0
80800bbc:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800bc0:	681b      	ldr	r3, [r3, #0]
80800bc2:	2b01      	cmp	r3, #1
80800bc4:	d119      	bne.n	80800bfa <prvAddNewTaskToReadyList+0x7e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
80800bc6:	f000 ff69 	bl	80801a9c <prvInitialiseTaskLists>
80800bca:	e016      	b.n	80800bfa <prvAddNewTaskToReadyList+0x7e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
80800bcc:	f642 03ac 	movw	r3, #10412	; 0x28ac
80800bd0:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800bd4:	681b      	ldr	r3, [r3, #0]
80800bd6:	2b00      	cmp	r3, #0
80800bd8:	d10f      	bne.n	80800bfa <prvAddNewTaskToReadyList+0x7e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
80800bda:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800bde:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800be2:	681b      	ldr	r3, [r3, #0]
80800be4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80800be6:	687b      	ldr	r3, [r7, #4]
80800be8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800bea:	429a      	cmp	r2, r3
80800bec:	d805      	bhi.n	80800bfa <prvAddNewTaskToReadyList+0x7e>
				{
					pxCurrentTCB = pxNewTCB;
80800bee:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800bf2:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800bf6:	687a      	ldr	r2, [r7, #4]
80800bf8:	601a      	str	r2, [r3, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
80800bfa:	f642 03bc 	movw	r3, #10428	; 0x28bc
80800bfe:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800c02:	681b      	ldr	r3, [r3, #0]
80800c04:	1c5a      	adds	r2, r3, #1
80800c06:	f642 03bc 	movw	r3, #10428	; 0x28bc
80800c0a:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800c0e:	601a      	str	r2, [r3, #0]
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
80800c10:	687b      	ldr	r3, [r7, #4]
80800c12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80800c14:	f642 03a8 	movw	r3, #10408	; 0x28a8
80800c18:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800c1c:	681b      	ldr	r3, [r3, #0]
80800c1e:	429a      	cmp	r2, r3
80800c20:	d906      	bls.n	80800c30 <prvAddNewTaskToReadyList+0xb4>
80800c22:	687b      	ldr	r3, [r7, #4]
80800c24:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80800c26:	f642 03a8 	movw	r3, #10408	; 0x28a8
80800c2a:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800c2e:	601a      	str	r2, [r3, #0]
80800c30:	687b      	ldr	r3, [r7, #4]
80800c32:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800c34:	009b      	lsls	r3, r3, #2
80800c36:	009a      	lsls	r2, r3, #2
80800c38:	4413      	add	r3, r2
80800c3a:	f242 72cc 	movw	r2, #10188	; 0x27cc
80800c3e:	f2c8 0280 	movt	r2, #32896	; 0x8080
80800c42:	441a      	add	r2, r3
80800c44:	687b      	ldr	r3, [r7, #4]
80800c46:	3304      	adds	r3, #4
80800c48:	4619      	mov	r1, r3
80800c4a:	4610      	mov	r0, r2
80800c4c:	f7ff fa24 	bl	80800098 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
80800c50:	f001 fc0e 	bl	80802470 <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
80800c54:	f642 03ac 	movw	r3, #10412	; 0x28ac
80800c58:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800c5c:	681b      	ldr	r3, [r3, #0]
80800c5e:	2b00      	cmp	r3, #0
80800c60:	d00a      	beq.n	80800c78 <prvAddNewTaskToReadyList+0xfc>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
80800c62:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800c66:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800c6a:	681b      	ldr	r3, [r3, #0]
80800c6c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80800c6e:	687b      	ldr	r3, [r7, #4]
80800c70:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800c72:	429a      	cmp	r2, r3
80800c74:	d200      	bcs.n	80800c78 <prvAddNewTaskToReadyList+0xfc>
		{
			taskYIELD_IF_USING_PREEMPTION();
80800c76:	df00      	svc	0
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
80800c78:	bf00      	nop
80800c7a:	3708      	adds	r7, #8
80800c7c:	46bd      	mov	sp, r7
80800c7e:	bd80      	pop	{r7, pc}

80800c80 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
80800c80:	b580      	push	{r7, lr}
80800c82:	b084      	sub	sp, #16
80800c84:	af00      	add	r7, sp, #0
80800c86:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
80800c88:	f001 fbec 	bl	80802464 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
80800c8c:	687b      	ldr	r3, [r7, #4]
80800c8e:	2b00      	cmp	r3, #0
80800c90:	d105      	bne.n	80800c9e <vTaskDelete+0x1e>
80800c92:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800c96:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800c9a:	681b      	ldr	r3, [r3, #0]
80800c9c:	e000      	b.n	80800ca0 <vTaskDelete+0x20>
80800c9e:	687b      	ldr	r3, [r7, #4]
80800ca0:	60fb      	str	r3, [r7, #12]

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80800ca2:	68fb      	ldr	r3, [r7, #12]
80800ca4:	3304      	adds	r3, #4
80800ca6:	4618      	mov	r0, r3
80800ca8:	f7ff fa52 	bl	80800150 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80800cac:	68fb      	ldr	r3, [r7, #12]
80800cae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
80800cb0:	2b00      	cmp	r3, #0
80800cb2:	d004      	beq.n	80800cbe <vTaskDelete+0x3e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80800cb4:	68fb      	ldr	r3, [r7, #12]
80800cb6:	3318      	adds	r3, #24
80800cb8:	4618      	mov	r0, r3
80800cba:	f7ff fa49 	bl	80800150 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
80800cbe:	f642 03bc 	movw	r3, #10428	; 0x28bc
80800cc2:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800cc6:	681b      	ldr	r3, [r3, #0]
80800cc8:	1c5a      	adds	r2, r3, #1
80800cca:	f642 03bc 	movw	r3, #10428	; 0x28bc
80800cce:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800cd2:	601a      	str	r2, [r3, #0]

			if( pxTCB == pxCurrentTCB )
80800cd4:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800cd8:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800cdc:	681b      	ldr	r3, [r3, #0]
80800cde:	68fa      	ldr	r2, [r7, #12]
80800ce0:	429a      	cmp	r2, r3
80800ce2:	d114      	bne.n	80800d0e <vTaskDelete+0x8e>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
80800ce4:	68fb      	ldr	r3, [r7, #12]
80800ce6:	3304      	adds	r3, #4
80800ce8:	4619      	mov	r1, r3
80800cea:	f642 0074 	movw	r0, #10356	; 0x2874
80800cee:	f2c8 0080 	movt	r0, #32896	; 0x8080
80800cf2:	f7ff f9d1 	bl	80800098 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
80800cf6:	f642 0388 	movw	r3, #10376	; 0x2888
80800cfa:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800cfe:	681b      	ldr	r3, [r3, #0]
80800d00:	1c5a      	adds	r2, r3, #1
80800d02:	f642 0388 	movw	r3, #10376	; 0x2888
80800d06:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800d0a:	601a      	str	r2, [r3, #0]
80800d0c:	e00f      	b.n	80800d2e <vTaskDelete+0xae>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
80800d0e:	f642 03a0 	movw	r3, #10400	; 0x28a0
80800d12:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800d16:	681b      	ldr	r3, [r3, #0]
80800d18:	1e5a      	subs	r2, r3, #1
80800d1a:	f642 03a0 	movw	r3, #10400	; 0x28a0
80800d1e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800d22:	601a      	str	r2, [r3, #0]
				prvDeleteTCB( pxTCB );
80800d24:	68f8      	ldr	r0, [r7, #12]
80800d26:	f000 ff4f 	bl	80801bc8 <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
80800d2a:	f000 ff5d 	bl	80801be8 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
80800d2e:	f001 fb9f 	bl	80802470 <vPortExitCritical>

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
80800d32:	f642 03ac 	movw	r3, #10412	; 0x28ac
80800d36:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800d3a:	681b      	ldr	r3, [r3, #0]
80800d3c:	2b00      	cmp	r3, #0
80800d3e:	d008      	beq.n	80800d52 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
80800d40:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800d44:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800d48:	681b      	ldr	r3, [r3, #0]
80800d4a:	68fa      	ldr	r2, [r7, #12]
80800d4c:	429a      	cmp	r2, r3
80800d4e:	d100      	bne.n	80800d52 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
80800d50:	df00      	svc	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
80800d52:	bf00      	nop
80800d54:	3710      	adds	r7, #16
80800d56:	46bd      	mov	sp, r7
80800d58:	bd80      	pop	{r7, pc}
80800d5a:	bf00      	nop

80800d5c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
80800d5c:	b580      	push	{r7, lr}
80800d5e:	b086      	sub	sp, #24
80800d60:	af00      	add	r7, sp, #0
80800d62:	6078      	str	r0, [r7, #4]
80800d64:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
80800d66:	2300      	movs	r3, #0
80800d68:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
80800d6a:	f000 faab 	bl	808012c4 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
80800d6e:	f642 03a4 	movw	r3, #10404	; 0x28a4
80800d72:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800d76:	681b      	ldr	r3, [r3, #0]
80800d78:	613b      	str	r3, [r7, #16]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
80800d7a:	687b      	ldr	r3, [r7, #4]
80800d7c:	681a      	ldr	r2, [r3, #0]
80800d7e:	683b      	ldr	r3, [r7, #0]
80800d80:	4413      	add	r3, r2
80800d82:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
80800d84:	687b      	ldr	r3, [r7, #4]
80800d86:	681a      	ldr	r2, [r3, #0]
80800d88:	693b      	ldr	r3, [r7, #16]
80800d8a:	429a      	cmp	r2, r3
80800d8c:	d90b      	bls.n	80800da6 <vTaskDelayUntil+0x4a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
80800d8e:	687b      	ldr	r3, [r7, #4]
80800d90:	681a      	ldr	r2, [r3, #0]
80800d92:	68fb      	ldr	r3, [r7, #12]
80800d94:	429a      	cmp	r2, r3
80800d96:	d911      	bls.n	80800dbc <vTaskDelayUntil+0x60>
80800d98:	68fa      	ldr	r2, [r7, #12]
80800d9a:	693b      	ldr	r3, [r7, #16]
80800d9c:	429a      	cmp	r2, r3
80800d9e:	d90d      	bls.n	80800dbc <vTaskDelayUntil+0x60>
				{
					xShouldDelay = pdTRUE;
80800da0:	2301      	movs	r3, #1
80800da2:	617b      	str	r3, [r7, #20]
80800da4:	e00a      	b.n	80800dbc <vTaskDelayUntil+0x60>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
80800da6:	687b      	ldr	r3, [r7, #4]
80800da8:	681a      	ldr	r2, [r3, #0]
80800daa:	68fb      	ldr	r3, [r7, #12]
80800dac:	429a      	cmp	r2, r3
80800dae:	d803      	bhi.n	80800db8 <vTaskDelayUntil+0x5c>
80800db0:	68fa      	ldr	r2, [r7, #12]
80800db2:	693b      	ldr	r3, [r7, #16]
80800db4:	429a      	cmp	r2, r3
80800db6:	d901      	bls.n	80800dbc <vTaskDelayUntil+0x60>
				{
					xShouldDelay = pdTRUE;
80800db8:	2301      	movs	r3, #1
80800dba:	617b      	str	r3, [r7, #20]
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
80800dbc:	687b      	ldr	r3, [r7, #4]
80800dbe:	68fa      	ldr	r2, [r7, #12]
80800dc0:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
80800dc2:	697b      	ldr	r3, [r7, #20]
80800dc4:	2b00      	cmp	r3, #0
80800dc6:	d006      	beq.n	80800dd6 <vTaskDelayUntil+0x7a>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
80800dc8:	68fa      	ldr	r2, [r7, #12]
80800dca:	693b      	ldr	r3, [r7, #16]
80800dcc:	1ad3      	subs	r3, r2, r3
80800dce:	2100      	movs	r1, #0
80800dd0:	4618      	mov	r0, r3
80800dd2:	f001 f9bb 	bl	8080214c <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
80800dd6:	f000 fa87 	bl	808012e8 <xTaskResumeAll>
80800dda:	60b8      	str	r0, [r7, #8]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
80800ddc:	68bb      	ldr	r3, [r7, #8]
80800dde:	2b00      	cmp	r3, #0
80800de0:	d100      	bne.n	80800de4 <vTaskDelayUntil+0x88>
		{
			portYIELD_WITHIN_API();
80800de2:	df00      	svc	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
80800de4:	bf00      	nop
80800de6:	3718      	adds	r7, #24
80800de8:	46bd      	mov	sp, r7
80800dea:	bd80      	pop	{r7, pc}

80800dec <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
80800dec:	b580      	push	{r7, lr}
80800dee:	b084      	sub	sp, #16
80800df0:	af00      	add	r7, sp, #0
80800df2:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
80800df4:	2300      	movs	r3, #0
80800df6:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
80800df8:	687b      	ldr	r3, [r7, #4]
80800dfa:	2b00      	cmp	r3, #0
80800dfc:	d008      	beq.n	80800e10 <vTaskDelay+0x24>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
80800dfe:	f000 fa61 	bl	808012c4 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
80800e02:	2100      	movs	r1, #0
80800e04:	6878      	ldr	r0, [r7, #4]
80800e06:	f001 f9a1 	bl	8080214c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
80800e0a:	f000 fa6d 	bl	808012e8 <xTaskResumeAll>
80800e0e:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
80800e10:	68fb      	ldr	r3, [r7, #12]
80800e12:	2b00      	cmp	r3, #0
80800e14:	d100      	bne.n	80800e18 <vTaskDelay+0x2c>
		{
			portYIELD_WITHIN_API();
80800e16:	df00      	svc	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
80800e18:	bf00      	nop
80800e1a:	3710      	adds	r7, #16
80800e1c:	46bd      	mov	sp, r7
80800e1e:	bd80      	pop	{r7, pc}

80800e20 <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
	{
80800e20:	b580      	push	{r7, lr}
80800e22:	b084      	sub	sp, #16
80800e24:	af00      	add	r7, sp, #0
80800e26:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
80800e28:	f001 fb1c 	bl	80802464 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the that
			called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
80800e2c:	687b      	ldr	r3, [r7, #4]
80800e2e:	2b00      	cmp	r3, #0
80800e30:	d105      	bne.n	80800e3e <uxTaskPriorityGet+0x1e>
80800e32:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800e36:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800e3a:	681b      	ldr	r3, [r3, #0]
80800e3c:	e000      	b.n	80800e40 <uxTaskPriorityGet+0x20>
80800e3e:	687b      	ldr	r3, [r7, #4]
80800e40:	60fb      	str	r3, [r7, #12]
			uxReturn = pxTCB->uxPriority;
80800e42:	68fb      	ldr	r3, [r7, #12]
80800e44:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800e46:	60bb      	str	r3, [r7, #8]
		}
		taskEXIT_CRITICAL();
80800e48:	f001 fb12 	bl	80802470 <vPortExitCritical>

		return uxReturn;
80800e4c:	68bb      	ldr	r3, [r7, #8]
	}
80800e4e:	4618      	mov	r0, r3
80800e50:	3710      	adds	r7, #16
80800e52:	46bd      	mov	sp, r7
80800e54:	bd80      	pop	{r7, pc}
80800e56:	bf00      	nop

80800e58 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
	{
80800e58:	b480      	push	{r7}
80800e5a:	b087      	sub	sp, #28
80800e5c:	af00      	add	r7, sp, #0
80800e5e:	6078      	str	r0, [r7, #4]
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
80800e60:	2300      	movs	r3, #0
80800e62:	617b      	str	r3, [r7, #20]
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
80800e64:	687b      	ldr	r3, [r7, #4]
80800e66:	2b00      	cmp	r3, #0
80800e68:	d105      	bne.n	80800e76 <uxTaskPriorityGetFromISR+0x1e>
80800e6a:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800e6e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800e72:	681b      	ldr	r3, [r3, #0]
80800e74:	e000      	b.n	80800e78 <uxTaskPriorityGetFromISR+0x20>
80800e76:	687b      	ldr	r3, [r7, #4]
80800e78:	613b      	str	r3, [r7, #16]
			uxReturn = pxTCB->uxPriority;
80800e7a:	693b      	ldr	r3, [r7, #16]
80800e7c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800e7e:	60fb      	str	r3, [r7, #12]
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
80800e80:	68fb      	ldr	r3, [r7, #12]
	}
80800e82:	4618      	mov	r0, r3
80800e84:	371c      	adds	r7, #28
80800e86:	46bd      	mov	sp, r7
80800e88:	bc80      	pop	{r7}
80800e8a:	4770      	bx	lr

80800e8c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
80800e8c:	b580      	push	{r7, lr}
80800e8e:	b086      	sub	sp, #24
80800e90:	af00      	add	r7, sp, #0
80800e92:	6078      	str	r0, [r7, #4]
80800e94:	6039      	str	r1, [r7, #0]
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
80800e96:	2300      	movs	r3, #0
80800e98:	617b      	str	r3, [r7, #20]

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
80800e9a:	683b      	ldr	r3, [r7, #0]
80800e9c:	2b04      	cmp	r3, #4
80800e9e:	d901      	bls.n	80800ea4 <vTaskPrioritySet+0x18>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
80800ea0:	2304      	movs	r3, #4
80800ea2:	603b      	str	r3, [r7, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
80800ea4:	f001 fade 	bl	80802464 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
80800ea8:	687b      	ldr	r3, [r7, #4]
80800eaa:	2b00      	cmp	r3, #0
80800eac:	d105      	bne.n	80800eba <vTaskPrioritySet+0x2e>
80800eae:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800eb2:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800eb6:	681b      	ldr	r3, [r3, #0]
80800eb8:	e000      	b.n	80800ebc <vTaskPrioritySet+0x30>
80800eba:	687b      	ldr	r3, [r7, #4]
80800ebc:	613b      	str	r3, [r7, #16]
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
80800ebe:	693b      	ldr	r3, [r7, #16]
80800ec0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800ec2:	60fb      	str	r3, [r7, #12]
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
80800ec4:	68fa      	ldr	r2, [r7, #12]
80800ec6:	683b      	ldr	r3, [r7, #0]
80800ec8:	429a      	cmp	r2, r3
80800eca:	d06b      	beq.n	80800fa4 <vTaskPrioritySet+0x118>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
80800ecc:	683a      	ldr	r2, [r7, #0]
80800ece:	68fb      	ldr	r3, [r7, #12]
80800ed0:	429a      	cmp	r2, r3
80800ed2:	d913      	bls.n	80800efc <vTaskPrioritySet+0x70>
				{
					if( pxTCB != pxCurrentTCB )
80800ed4:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800ed8:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800edc:	681b      	ldr	r3, [r3, #0]
80800ede:	693a      	ldr	r2, [r7, #16]
80800ee0:	429a      	cmp	r2, r3
80800ee2:	d015      	beq.n	80800f10 <vTaskPrioritySet+0x84>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
80800ee4:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800ee8:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800eec:	681b      	ldr	r3, [r3, #0]
80800eee:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80800ef0:	683b      	ldr	r3, [r7, #0]
80800ef2:	429a      	cmp	r2, r3
80800ef4:	d80c      	bhi.n	80800f10 <vTaskPrioritySet+0x84>
						{
							xYieldRequired = pdTRUE;
80800ef6:	2301      	movs	r3, #1
80800ef8:	617b      	str	r3, [r7, #20]
80800efa:	e009      	b.n	80800f10 <vTaskPrioritySet+0x84>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
80800efc:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800f00:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800f04:	681b      	ldr	r3, [r3, #0]
80800f06:	693a      	ldr	r2, [r7, #16]
80800f08:	429a      	cmp	r2, r3
80800f0a:	d101      	bne.n	80800f10 <vTaskPrioritySet+0x84>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
80800f0c:	2301      	movs	r3, #1
80800f0e:	617b      	str	r3, [r7, #20]
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
80800f10:	693b      	ldr	r3, [r7, #16]
80800f12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800f14:	60bb      	str	r3, [r7, #8]
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
80800f16:	693b      	ldr	r3, [r7, #16]
80800f18:	683a      	ldr	r2, [r7, #0]
80800f1a:	62da      	str	r2, [r3, #44]	; 0x2c
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
80800f1c:	693b      	ldr	r3, [r7, #16]
80800f1e:	699b      	ldr	r3, [r3, #24]
80800f20:	2b00      	cmp	r3, #0
80800f22:	db04      	blt.n	80800f2e <vTaskPrioritySet+0xa2>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80800f24:	683b      	ldr	r3, [r7, #0]
80800f26:	f1c3 0205 	rsb	r2, r3, #5
80800f2a:	693b      	ldr	r3, [r7, #16]
80800f2c:	619a      	str	r2, [r3, #24]

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
80800f2e:	693b      	ldr	r3, [r7, #16]
80800f30:	6959      	ldr	r1, [r3, #20]
80800f32:	68bb      	ldr	r3, [r7, #8]
80800f34:	009b      	lsls	r3, r3, #2
80800f36:	009a      	lsls	r2, r3, #2
80800f38:	4413      	add	r3, r2
80800f3a:	f242 72cc 	movw	r2, #10188	; 0x27cc
80800f3e:	f2c8 0280 	movt	r2, #32896	; 0x8080
80800f42:	4413      	add	r3, r2
80800f44:	4299      	cmp	r1, r3
80800f46:	d101      	bne.n	80800f4c <vTaskPrioritySet+0xc0>
80800f48:	2301      	movs	r3, #1
80800f4a:	e000      	b.n	80800f4e <vTaskPrioritySet+0xc2>
80800f4c:	2300      	movs	r3, #0
80800f4e:	2b00      	cmp	r3, #0
80800f50:	d024      	beq.n	80800f9c <vTaskPrioritySet+0x110>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80800f52:	693b      	ldr	r3, [r7, #16]
80800f54:	3304      	adds	r3, #4
80800f56:	4618      	mov	r0, r3
80800f58:	f7ff f8fa 	bl	80800150 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
80800f5c:	693b      	ldr	r3, [r7, #16]
80800f5e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80800f60:	f642 03a8 	movw	r3, #10408	; 0x28a8
80800f64:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800f68:	681b      	ldr	r3, [r3, #0]
80800f6a:	429a      	cmp	r2, r3
80800f6c:	d906      	bls.n	80800f7c <vTaskPrioritySet+0xf0>
80800f6e:	693b      	ldr	r3, [r7, #16]
80800f70:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80800f72:	f642 03a8 	movw	r3, #10408	; 0x28a8
80800f76:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800f7a:	601a      	str	r2, [r3, #0]
80800f7c:	693b      	ldr	r3, [r7, #16]
80800f7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80800f80:	009b      	lsls	r3, r3, #2
80800f82:	009a      	lsls	r2, r3, #2
80800f84:	4413      	add	r3, r2
80800f86:	f242 72cc 	movw	r2, #10188	; 0x27cc
80800f8a:	f2c8 0280 	movt	r2, #32896	; 0x8080
80800f8e:	441a      	add	r2, r3
80800f90:	693b      	ldr	r3, [r7, #16]
80800f92:	3304      	adds	r3, #4
80800f94:	4619      	mov	r1, r3
80800f96:	4610      	mov	r0, r2
80800f98:	f7ff f87e 	bl	80800098 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
80800f9c:	697b      	ldr	r3, [r7, #20]
80800f9e:	2b00      	cmp	r3, #0
80800fa0:	d000      	beq.n	80800fa4 <vTaskPrioritySet+0x118>
				{
					taskYIELD_IF_USING_PREEMPTION();
80800fa2:	df00      	svc	0
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
80800fa4:	f001 fa64 	bl	80802470 <vPortExitCritical>
	}
80800fa8:	bf00      	nop
80800faa:	3718      	adds	r7, #24
80800fac:	46bd      	mov	sp, r7
80800fae:	bd80      	pop	{r7, pc}

80800fb0 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
80800fb0:	b580      	push	{r7, lr}
80800fb2:	b084      	sub	sp, #16
80800fb4:	af00      	add	r7, sp, #0
80800fb6:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
80800fb8:	f001 fa54 	bl	80802464 <vPortEnterCritical>
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
80800fbc:	687b      	ldr	r3, [r7, #4]
80800fbe:	2b00      	cmp	r3, #0
80800fc0:	d105      	bne.n	80800fce <vTaskSuspend+0x1e>
80800fc2:	f242 73c8 	movw	r3, #10184	; 0x27c8
80800fc6:	f2c8 0380 	movt	r3, #32896	; 0x8080
80800fca:	681b      	ldr	r3, [r3, #0]
80800fcc:	e000      	b.n	80800fd0 <vTaskSuspend+0x20>
80800fce:	687b      	ldr	r3, [r7, #4]
80800fd0:	60fb      	str	r3, [r7, #12]

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80800fd2:	68fb      	ldr	r3, [r7, #12]
80800fd4:	3304      	adds	r3, #4
80800fd6:	4618      	mov	r0, r3
80800fd8:	f7ff f8ba 	bl	80800150 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
80800fdc:	68fb      	ldr	r3, [r7, #12]
80800fde:	6a9b      	ldr	r3, [r3, #40]	; 0x28
80800fe0:	2b00      	cmp	r3, #0
80800fe2:	d004      	beq.n	80800fee <vTaskSuspend+0x3e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
80800fe4:	68fb      	ldr	r3, [r7, #12]
80800fe6:	3318      	adds	r3, #24
80800fe8:	4618      	mov	r0, r3
80800fea:	f7ff f8b1 	bl	80800150 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
80800fee:	68fb      	ldr	r3, [r7, #12]
80800ff0:	3304      	adds	r3, #4
80800ff2:	4619      	mov	r1, r3
80800ff4:	f642 008c 	movw	r0, #10380	; 0x288c
80800ff8:	f2c8 0080 	movt	r0, #32896	; 0x8080
80800ffc:	f7ff f84c 	bl	80800098 <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
80801000:	f001 fa36 	bl	80802470 <vPortExitCritical>

		if( xSchedulerRunning != pdFALSE )
80801004:	f642 03ac 	movw	r3, #10412	; 0x28ac
80801008:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080100c:	681b      	ldr	r3, [r3, #0]
8080100e:	2b00      	cmp	r3, #0
80801010:	d005      	beq.n	8080101e <vTaskSuspend+0x6e>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
80801012:	f001 fa27 	bl	80802464 <vPortEnterCritical>
			{
				prvResetNextTaskUnblockTime();
80801016:	f000 fde7 	bl	80801be8 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
8080101a:	f001 fa29 	bl	80802470 <vPortExitCritical>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
8080101e:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801022:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801026:	681b      	ldr	r3, [r3, #0]
80801028:	68fa      	ldr	r2, [r7, #12]
8080102a:	429a      	cmp	r2, r3
8080102c:	d11d      	bne.n	8080106a <vTaskSuspend+0xba>
		{
			if( xSchedulerRunning != pdFALSE )
8080102e:	f642 03ac 	movw	r3, #10412	; 0x28ac
80801032:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801036:	681b      	ldr	r3, [r3, #0]
80801038:	2b00      	cmp	r3, #0
8080103a:	d001      	beq.n	80801040 <vTaskSuspend+0x90>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
8080103c:	df00      	svc	0
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
8080103e:	e014      	b.n	8080106a <vTaskSuspend+0xba>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
80801040:	f642 038c 	movw	r3, #10380	; 0x288c
80801044:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801048:	681a      	ldr	r2, [r3, #0]
8080104a:	f642 03a0 	movw	r3, #10400	; 0x28a0
8080104e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801052:	681b      	ldr	r3, [r3, #0]
80801054:	429a      	cmp	r2, r3
80801056:	d106      	bne.n	80801066 <vTaskSuspend+0xb6>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
80801058:	f242 73c8 	movw	r3, #10184	; 0x27c8
8080105c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801060:	2200      	movs	r2, #0
80801062:	601a      	str	r2, [r3, #0]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
80801064:	e001      	b.n	8080106a <vTaskSuspend+0xba>
					is. */
					pxCurrentTCB = NULL;
				}
				else
				{
					vTaskSwitchContext();
80801066:	f000 fb5d 	bl	80801724 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
8080106a:	bf00      	nop
8080106c:	3710      	adds	r7, #16
8080106e:	46bd      	mov	sp, r7
80801070:	bd80      	pop	{r7, pc}
80801072:	bf00      	nop

80801074 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
80801074:	b480      	push	{r7}
80801076:	b085      	sub	sp, #20
80801078:	af00      	add	r7, sp, #0
8080107a:	6078      	str	r0, [r7, #4]
	BaseType_t xReturn = pdFALSE;
8080107c:	2300      	movs	r3, #0
8080107e:	60fb      	str	r3, [r7, #12]
	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
80801080:	687b      	ldr	r3, [r7, #4]
80801082:	60bb      	str	r3, [r7, #8]

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
80801084:	68bb      	ldr	r3, [r7, #8]
80801086:	695a      	ldr	r2, [r3, #20]
80801088:	f642 038c 	movw	r3, #10380	; 0x288c
8080108c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801090:	429a      	cmp	r2, r3
80801092:	d101      	bne.n	80801098 <prvTaskIsTaskSuspended+0x24>
80801094:	2301      	movs	r3, #1
80801096:	e000      	b.n	8080109a <prvTaskIsTaskSuspended+0x26>
80801098:	2300      	movs	r3, #0
8080109a:	2b00      	cmp	r3, #0
8080109c:	d012      	beq.n	808010c4 <prvTaskIsTaskSuspended+0x50>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
8080109e:	68bb      	ldr	r3, [r7, #8]
808010a0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
808010a2:	f642 0360 	movw	r3, #10336	; 0x2860
808010a6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808010aa:	429a      	cmp	r2, r3
808010ac:	d00a      	beq.n	808010c4 <prvTaskIsTaskSuspended+0x50>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
808010ae:	68bb      	ldr	r3, [r7, #8]
808010b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
808010b2:	2b00      	cmp	r3, #0
808010b4:	d101      	bne.n	808010ba <prvTaskIsTaskSuspended+0x46>
808010b6:	2301      	movs	r3, #1
808010b8:	e000      	b.n	808010bc <prvTaskIsTaskSuspended+0x48>
808010ba:	2300      	movs	r3, #0
808010bc:	2b00      	cmp	r3, #0
808010be:	d001      	beq.n	808010c4 <prvTaskIsTaskSuspended+0x50>
				{
					xReturn = pdTRUE;
808010c0:	2301      	movs	r3, #1
808010c2:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
808010c4:	68fb      	ldr	r3, [r7, #12]
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
808010c6:	4618      	mov	r0, r3
808010c8:	3714      	adds	r7, #20
808010ca:	46bd      	mov	sp, r7
808010cc:	bc80      	pop	{r7}
808010ce:	4770      	bx	lr

808010d0 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
808010d0:	b580      	push	{r7, lr}
808010d2:	b084      	sub	sp, #16
808010d4:	af00      	add	r7, sp, #0
808010d6:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
808010d8:	687b      	ldr	r3, [r7, #4]
808010da:	60fb      	str	r3, [r7, #12]
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
808010dc:	68fb      	ldr	r3, [r7, #12]
808010de:	2b00      	cmp	r3, #0
808010e0:	d041      	beq.n	80801166 <vTaskResume+0x96>
808010e2:	f242 73c8 	movw	r3, #10184	; 0x27c8
808010e6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808010ea:	681b      	ldr	r3, [r3, #0]
808010ec:	68fa      	ldr	r2, [r7, #12]
808010ee:	429a      	cmp	r2, r3
808010f0:	d039      	beq.n	80801166 <vTaskResume+0x96>
		{
			taskENTER_CRITICAL();
808010f2:	f001 f9b7 	bl	80802464 <vPortEnterCritical>
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
808010f6:	68f8      	ldr	r0, [r7, #12]
808010f8:	f7ff ffbc 	bl	80801074 <prvTaskIsTaskSuspended>
808010fc:	4603      	mov	r3, r0
808010fe:	2b00      	cmp	r3, #0
80801100:	d02f      	beq.n	80801162 <vTaskResume+0x92>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
80801102:	68fb      	ldr	r3, [r7, #12]
80801104:	3304      	adds	r3, #4
80801106:	4618      	mov	r0, r3
80801108:	f7ff f822 	bl	80800150 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
8080110c:	68fb      	ldr	r3, [r7, #12]
8080110e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801110:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801114:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801118:	681b      	ldr	r3, [r3, #0]
8080111a:	429a      	cmp	r2, r3
8080111c:	d906      	bls.n	8080112c <vTaskResume+0x5c>
8080111e:	68fb      	ldr	r3, [r7, #12]
80801120:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801122:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801126:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080112a:	601a      	str	r2, [r3, #0]
8080112c:	68fb      	ldr	r3, [r7, #12]
8080112e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801130:	009b      	lsls	r3, r3, #2
80801132:	009a      	lsls	r2, r3, #2
80801134:	4413      	add	r3, r2
80801136:	f242 72cc 	movw	r2, #10188	; 0x27cc
8080113a:	f2c8 0280 	movt	r2, #32896	; 0x8080
8080113e:	441a      	add	r2, r3
80801140:	68fb      	ldr	r3, [r7, #12]
80801142:	3304      	adds	r3, #4
80801144:	4619      	mov	r1, r3
80801146:	4610      	mov	r0, r2
80801148:	f7fe ffa6 	bl	80800098 <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8080114c:	68fb      	ldr	r3, [r7, #12]
8080114e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801150:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801154:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801158:	681b      	ldr	r3, [r3, #0]
8080115a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
8080115c:	429a      	cmp	r2, r3
8080115e:	d300      	bcc.n	80801162 <vTaskResume+0x92>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
80801160:	df00      	svc	0
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
80801162:	f001 f985 	bl	80802470 <vPortExitCritical>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
80801166:	bf00      	nop
80801168:	3710      	adds	r7, #16
8080116a:	46bd      	mov	sp, r7
8080116c:	bd80      	pop	{r7, pc}
8080116e:	bf00      	nop

80801170 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
80801170:	b580      	push	{r7, lr}
80801172:	b086      	sub	sp, #24
80801174:	af00      	add	r7, sp, #0
80801176:	6078      	str	r0, [r7, #4]
	BaseType_t xYieldRequired = pdFALSE;
80801178:	2300      	movs	r3, #0
8080117a:	617b      	str	r3, [r7, #20]
	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
8080117c:	687b      	ldr	r3, [r7, #4]
8080117e:	613b      	str	r3, [r7, #16]
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80801180:	2300      	movs	r3, #0
80801182:	60fb      	str	r3, [r7, #12]
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
80801184:	6938      	ldr	r0, [r7, #16]
80801186:	f7ff ff75 	bl	80801074 <prvTaskIsTaskSuspended>
8080118a:	4603      	mov	r3, r0
8080118c:	2b00      	cmp	r3, #0
8080118e:	d041      	beq.n	80801214 <xTaskResumeFromISR+0xa4>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80801190:	f642 03c8 	movw	r3, #10440	; 0x28c8
80801194:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801198:	681b      	ldr	r3, [r3, #0]
8080119a:	2b00      	cmp	r3, #0
8080119c:	d131      	bne.n	80801202 <xTaskResumeFromISR+0x92>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
8080119e:	693b      	ldr	r3, [r7, #16]
808011a0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808011a2:	f242 73c8 	movw	r3, #10184	; 0x27c8
808011a6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808011aa:	681b      	ldr	r3, [r3, #0]
808011ac:	6adb      	ldr	r3, [r3, #44]	; 0x2c
808011ae:	429a      	cmp	r2, r3
808011b0:	d301      	bcc.n	808011b6 <xTaskResumeFromISR+0x46>
					{
						xYieldRequired = pdTRUE;
808011b2:	2301      	movs	r3, #1
808011b4:	617b      	str	r3, [r7, #20]
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
808011b6:	693b      	ldr	r3, [r7, #16]
808011b8:	3304      	adds	r3, #4
808011ba:	4618      	mov	r0, r3
808011bc:	f7fe ffc8 	bl	80800150 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
808011c0:	693b      	ldr	r3, [r7, #16]
808011c2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808011c4:	f642 03a8 	movw	r3, #10408	; 0x28a8
808011c8:	f2c8 0380 	movt	r3, #32896	; 0x8080
808011cc:	681b      	ldr	r3, [r3, #0]
808011ce:	429a      	cmp	r2, r3
808011d0:	d906      	bls.n	808011e0 <xTaskResumeFromISR+0x70>
808011d2:	693b      	ldr	r3, [r7, #16]
808011d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808011d6:	f642 03a8 	movw	r3, #10408	; 0x28a8
808011da:	f2c8 0380 	movt	r3, #32896	; 0x8080
808011de:	601a      	str	r2, [r3, #0]
808011e0:	693b      	ldr	r3, [r7, #16]
808011e2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
808011e4:	009b      	lsls	r3, r3, #2
808011e6:	009a      	lsls	r2, r3, #2
808011e8:	4413      	add	r3, r2
808011ea:	f242 72cc 	movw	r2, #10188	; 0x27cc
808011ee:	f2c8 0280 	movt	r2, #32896	; 0x8080
808011f2:	441a      	add	r2, r3
808011f4:	693b      	ldr	r3, [r7, #16]
808011f6:	3304      	adds	r3, #4
808011f8:	4619      	mov	r1, r3
808011fa:	4610      	mov	r0, r2
808011fc:	f7fe ff4c 	bl	80800098 <vListInsertEnd>
80801200:	e008      	b.n	80801214 <xTaskResumeFromISR+0xa4>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80801202:	693b      	ldr	r3, [r7, #16]
80801204:	3318      	adds	r3, #24
80801206:	4619      	mov	r1, r3
80801208:	f642 0060 	movw	r0, #10336	; 0x2860
8080120c:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801210:	f7fe ff42 	bl	80800098 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
80801214:	697b      	ldr	r3, [r7, #20]
	}
80801216:	4618      	mov	r0, r3
80801218:	3718      	adds	r7, #24
8080121a:	46bd      	mov	sp, r7
8080121c:	bd80      	pop	{r7, pc}
8080121e:	bf00      	nop

80801220 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
80801220:	b580      	push	{r7, lr}
80801222:	b084      	sub	sp, #16
80801224:	af02      	add	r7, sp, #8
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
80801226:	f642 03c4 	movw	r3, #10436	; 0x28c4
8080122a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080122e:	9301      	str	r3, [sp, #4]
80801230:	2300      	movs	r3, #0
80801232:	9300      	str	r3, [sp, #0]
80801234:	2300      	movs	r3, #0
80801236:	2280      	movs	r2, #128	; 0x80
80801238:	f242 71b0 	movw	r1, #10160	; 0x27b0
8080123c:	f2c8 0180 	movt	r1, #32896	; 0x8080
80801240:	f641 207d 	movw	r0, #6781	; 0x1a7d
80801244:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801248:	f7ff fbea 	bl	80800a20 <xTaskCreate>
8080124c:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
8080124e:	687b      	ldr	r3, [r7, #4]
80801250:	2b01      	cmp	r3, #1
80801252:	d11d      	bne.n	80801290 <vTaskStartScheduler+0x70>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
80801254:	f84d 0d04 	str.w	r0, [sp, #-4]!
80801258:	f3ef 8000 	mrs	r0, CPSR
8080125c:	f040 00c0 	orr.w	r0, r0, #192	; 0xc0
80801260:	f380 8900 	msr	CPSR_fc, r0
80801264:	bc01      	pop	{r0}
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
80801266:	f642 03c0 	movw	r3, #10432	; 0x28c0
8080126a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080126e:	f04f 32ff 	mov.w	r2, #4294967295
80801272:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
80801274:	f642 03ac 	movw	r3, #10412	; 0x28ac
80801278:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080127c:	2201      	movs	r2, #1
8080127e:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
80801280:	f642 03a4 	movw	r3, #10404	; 0x28a4
80801284:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801288:	2200      	movs	r2, #0
8080128a:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
8080128c:	f001 f8f6 	bl	8080247c <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
80801290:	bf00      	nop
80801292:	3708      	adds	r7, #8
80801294:	46bd      	mov	sp, r7
80801296:	bd80      	pop	{r7, pc}

80801298 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
80801298:	b580      	push	{r7, lr}
8080129a:	af00      	add	r7, sp, #0
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
8080129c:	f84d 0d04 	str.w	r0, [sp, #-4]!
808012a0:	f3ef 8000 	mrs	r0, CPSR
808012a4:	f040 00c0 	orr.w	r0, r0, #192	; 0xc0
808012a8:	f380 8900 	msr	CPSR_fc, r0
808012ac:	bc01      	pop	{r0}
	xSchedulerRunning = pdFALSE;
808012ae:	f642 03ac 	movw	r3, #10412	; 0x28ac
808012b2:	f2c8 0380 	movt	r3, #32896	; 0x8080
808012b6:	2200      	movs	r2, #0
808012b8:	601a      	str	r2, [r3, #0]
	vPortEndScheduler();
808012ba:	f001 f8e7 	bl	8080248c <vPortEndScheduler>
}
808012be:	bf00      	nop
808012c0:	bd80      	pop	{r7, pc}
808012c2:	bf00      	nop

808012c4 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
808012c4:	b480      	push	{r7}
808012c6:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
808012c8:	f642 03c8 	movw	r3, #10440	; 0x28c8
808012cc:	f2c8 0380 	movt	r3, #32896	; 0x8080
808012d0:	681b      	ldr	r3, [r3, #0]
808012d2:	1c5a      	adds	r2, r3, #1
808012d4:	f642 03c8 	movw	r3, #10440	; 0x28c8
808012d8:	f2c8 0380 	movt	r3, #32896	; 0x8080
808012dc:	601a      	str	r2, [r3, #0]
}
808012de:	bf00      	nop
808012e0:	46bd      	mov	sp, r7
808012e2:	bc80      	pop	{r7}
808012e4:	4770      	bx	lr
808012e6:	bf00      	nop

808012e8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
808012e8:	b580      	push	{r7, lr}
808012ea:	b084      	sub	sp, #16
808012ec:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
808012ee:	2300      	movs	r3, #0
808012f0:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
808012f2:	2300      	movs	r3, #0
808012f4:	60bb      	str	r3, [r7, #8]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
808012f6:	f001 f8b5 	bl	80802464 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
808012fa:	f642 03c8 	movw	r3, #10440	; 0x28c8
808012fe:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801302:	681b      	ldr	r3, [r3, #0]
80801304:	1e5a      	subs	r2, r3, #1
80801306:	f642 03c8 	movw	r3, #10440	; 0x28c8
8080130a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080130e:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80801310:	f642 03c8 	movw	r3, #10440	; 0x28c8
80801314:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801318:	681b      	ldr	r3, [r3, #0]
8080131a:	2b00      	cmp	r3, #0
8080131c:	d17e      	bne.n	8080141c <xTaskResumeAll+0x134>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
8080131e:	f642 03a0 	movw	r3, #10400	; 0x28a0
80801322:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801326:	681b      	ldr	r3, [r3, #0]
80801328:	2b00      	cmp	r3, #0
8080132a:	d077      	beq.n	8080141c <xTaskResumeAll+0x134>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
8080132c:	e040      	b.n	808013b0 <xTaskResumeAll+0xc8>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
8080132e:	f642 0360 	movw	r3, #10336	; 0x2860
80801332:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801336:	68db      	ldr	r3, [r3, #12]
80801338:	68db      	ldr	r3, [r3, #12]
8080133a:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
8080133c:	68fb      	ldr	r3, [r7, #12]
8080133e:	3318      	adds	r3, #24
80801340:	4618      	mov	r0, r3
80801342:	f7fe ff05 	bl	80800150 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80801346:	68fb      	ldr	r3, [r7, #12]
80801348:	3304      	adds	r3, #4
8080134a:	4618      	mov	r0, r3
8080134c:	f7fe ff00 	bl	80800150 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80801350:	68fb      	ldr	r3, [r7, #12]
80801352:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801354:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801358:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080135c:	681b      	ldr	r3, [r3, #0]
8080135e:	429a      	cmp	r2, r3
80801360:	d906      	bls.n	80801370 <xTaskResumeAll+0x88>
80801362:	68fb      	ldr	r3, [r7, #12]
80801364:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801366:	f642 03a8 	movw	r3, #10408	; 0x28a8
8080136a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080136e:	601a      	str	r2, [r3, #0]
80801370:	68fb      	ldr	r3, [r7, #12]
80801372:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801374:	009b      	lsls	r3, r3, #2
80801376:	009a      	lsls	r2, r3, #2
80801378:	4413      	add	r3, r2
8080137a:	f242 72cc 	movw	r2, #10188	; 0x27cc
8080137e:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801382:	441a      	add	r2, r3
80801384:	68fb      	ldr	r3, [r7, #12]
80801386:	3304      	adds	r3, #4
80801388:	4619      	mov	r1, r3
8080138a:	4610      	mov	r0, r2
8080138c:	f7fe fe84 	bl	80800098 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
80801390:	68fb      	ldr	r3, [r7, #12]
80801392:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801394:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801398:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080139c:	681b      	ldr	r3, [r3, #0]
8080139e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
808013a0:	429a      	cmp	r2, r3
808013a2:	d305      	bcc.n	808013b0 <xTaskResumeAll+0xc8>
					{
						xYieldPending = pdTRUE;
808013a4:	f642 03b4 	movw	r3, #10420	; 0x28b4
808013a8:	f2c8 0380 	movt	r3, #32896	; 0x8080
808013ac:	2201      	movs	r2, #1
808013ae:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
808013b0:	f642 0360 	movw	r3, #10336	; 0x2860
808013b4:	f2c8 0380 	movt	r3, #32896	; 0x8080
808013b8:	681b      	ldr	r3, [r3, #0]
808013ba:	2b00      	cmp	r3, #0
808013bc:	d1b7      	bne.n	8080132e <xTaskResumeAll+0x46>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
808013be:	68fb      	ldr	r3, [r7, #12]
808013c0:	2b00      	cmp	r3, #0
808013c2:	d001      	beq.n	808013c8 <xTaskResumeAll+0xe0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
808013c4:	f000 fc10 	bl	80801be8 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
808013c8:	f642 03b0 	movw	r3, #10416	; 0x28b0
808013cc:	f2c8 0380 	movt	r3, #32896	; 0x8080
808013d0:	681b      	ldr	r3, [r3, #0]
808013d2:	607b      	str	r3, [r7, #4]

					if( uxPendedCounts > ( UBaseType_t ) 0U )
808013d4:	687b      	ldr	r3, [r7, #4]
808013d6:	2b00      	cmp	r3, #0
808013d8:	d016      	beq.n	80801408 <xTaskResumeAll+0x120>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
808013da:	f000 f86d 	bl	808014b8 <xTaskIncrementTick>
808013de:	4603      	mov	r3, r0
808013e0:	2b00      	cmp	r3, #0
808013e2:	d005      	beq.n	808013f0 <xTaskResumeAll+0x108>
							{
								xYieldPending = pdTRUE;
808013e4:	f642 03b4 	movw	r3, #10420	; 0x28b4
808013e8:	f2c8 0380 	movt	r3, #32896	; 0x8080
808013ec:	2201      	movs	r2, #1
808013ee:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
808013f0:	687b      	ldr	r3, [r7, #4]
808013f2:	3b01      	subs	r3, #1
808013f4:	607b      	str	r3, [r7, #4]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
808013f6:	687b      	ldr	r3, [r7, #4]
808013f8:	2b00      	cmp	r3, #0
808013fa:	d1ee      	bne.n	808013da <xTaskResumeAll+0xf2>

						uxPendedTicks = 0;
808013fc:	f642 03b0 	movw	r3, #10416	; 0x28b0
80801400:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801404:	2200      	movs	r2, #0
80801406:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
80801408:	f642 03b4 	movw	r3, #10420	; 0x28b4
8080140c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801410:	681b      	ldr	r3, [r3, #0]
80801412:	2b00      	cmp	r3, #0
80801414:	d002      	beq.n	8080141c <xTaskResumeAll+0x134>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
80801416:	2301      	movs	r3, #1
80801418:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
8080141a:	df00      	svc	0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
8080141c:	f001 f828 	bl	80802470 <vPortExitCritical>

	return xAlreadyYielded;
80801420:	68bb      	ldr	r3, [r7, #8]
}
80801422:	4618      	mov	r0, r3
80801424:	3710      	adds	r7, #16
80801426:	46bd      	mov	sp, r7
80801428:	bd80      	pop	{r7, pc}
8080142a:	bf00      	nop

8080142c <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
8080142c:	b580      	push	{r7, lr}
8080142e:	b082      	sub	sp, #8
80801430:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
80801432:	f001 f817 	bl	80802464 <vPortEnterCritical>
	{
		xTicks = xTickCount;
80801436:	f642 03a4 	movw	r3, #10404	; 0x28a4
8080143a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080143e:	681b      	ldr	r3, [r3, #0]
80801440:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();
80801442:	f001 f815 	bl	80802470 <vPortExitCritical>

	return xTicks;
80801446:	687b      	ldr	r3, [r7, #4]
}
80801448:	4618      	mov	r0, r3
8080144a:	3708      	adds	r7, #8
8080144c:	46bd      	mov	sp, r7
8080144e:	bd80      	pop	{r7, pc}

80801450 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
80801450:	b480      	push	{r7}
80801452:	b083      	sub	sp, #12
80801454:	af00      	add	r7, sp, #0
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
80801456:	2300      	movs	r3, #0
80801458:	607b      	str	r3, [r7, #4]
	{
		xReturn = xTickCount;
8080145a:	f642 03a4 	movw	r3, #10404	; 0x28a4
8080145e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801462:	681b      	ldr	r3, [r3, #0]
80801464:	603b      	str	r3, [r7, #0]
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
80801466:	683b      	ldr	r3, [r7, #0]
}
80801468:	4618      	mov	r0, r3
8080146a:	370c      	adds	r7, #12
8080146c:	46bd      	mov	sp, r7
8080146e:	bc80      	pop	{r7}
80801470:	4770      	bx	lr
80801472:	bf00      	nop

80801474 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
80801474:	b480      	push	{r7}
80801476:	af00      	add	r7, sp, #0
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
80801478:	f642 03a0 	movw	r3, #10400	; 0x28a0
8080147c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801480:	681b      	ldr	r3, [r3, #0]
}
80801482:	4618      	mov	r0, r3
80801484:	46bd      	mov	sp, r7
80801486:	bc80      	pop	{r7}
80801488:	4770      	bx	lr
8080148a:	bf00      	nop

8080148c <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
8080148c:	b480      	push	{r7}
8080148e:	b085      	sub	sp, #20
80801490:	af00      	add	r7, sp, #0
80801492:	6078      	str	r0, [r7, #4]
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
80801494:	687b      	ldr	r3, [r7, #4]
80801496:	2b00      	cmp	r3, #0
80801498:	d105      	bne.n	808014a6 <pcTaskGetName+0x1a>
8080149a:	f242 73c8 	movw	r3, #10184	; 0x27c8
8080149e:	f2c8 0380 	movt	r3, #32896	; 0x8080
808014a2:	681b      	ldr	r3, [r3, #0]
808014a4:	e000      	b.n	808014a8 <pcTaskGetName+0x1c>
808014a6:	687b      	ldr	r3, [r7, #4]
808014a8:	60fb      	str	r3, [r7, #12]
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
808014aa:	68fb      	ldr	r3, [r7, #12]
808014ac:	3334      	adds	r3, #52	; 0x34
}
808014ae:	4618      	mov	r0, r3
808014b0:	3714      	adds	r7, #20
808014b2:	46bd      	mov	sp, r7
808014b4:	bc80      	pop	{r7}
808014b6:	4770      	bx	lr

808014b8 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
808014b8:	b580      	push	{r7, lr}
808014ba:	b086      	sub	sp, #24
808014bc:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
808014be:	2300      	movs	r3, #0
808014c0:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
808014c2:	f642 03c8 	movw	r3, #10440	; 0x28c8
808014c6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808014ca:	681b      	ldr	r3, [r3, #0]
808014cc:	2b00      	cmp	r3, #0
808014ce:	f040 80b5 	bne.w	8080163c <xTaskIncrementTick+0x184>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
808014d2:	f642 03a4 	movw	r3, #10404	; 0x28a4
808014d6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808014da:	681b      	ldr	r3, [r3, #0]
808014dc:	3301      	adds	r3, #1
808014de:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
808014e0:	f642 03a4 	movw	r3, #10404	; 0x28a4
808014e4:	f2c8 0380 	movt	r3, #32896	; 0x8080
808014e8:	693a      	ldr	r2, [r7, #16]
808014ea:	601a      	str	r2, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U )
808014ec:	693b      	ldr	r3, [r7, #16]
808014ee:	2b00      	cmp	r3, #0
808014f0:	d122      	bne.n	80801538 <xTaskIncrementTick+0x80>
		{
			taskSWITCH_DELAYED_LISTS();
808014f2:	f642 0358 	movw	r3, #10328	; 0x2858
808014f6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808014fa:	681b      	ldr	r3, [r3, #0]
808014fc:	60fb      	str	r3, [r7, #12]
808014fe:	f642 035c 	movw	r3, #10332	; 0x285c
80801502:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801506:	681a      	ldr	r2, [r3, #0]
80801508:	f642 0358 	movw	r3, #10328	; 0x2858
8080150c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801510:	601a      	str	r2, [r3, #0]
80801512:	f642 035c 	movw	r3, #10332	; 0x285c
80801516:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080151a:	68fa      	ldr	r2, [r7, #12]
8080151c:	601a      	str	r2, [r3, #0]
8080151e:	f642 03b8 	movw	r3, #10424	; 0x28b8
80801522:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801526:	681b      	ldr	r3, [r3, #0]
80801528:	1c5a      	adds	r2, r3, #1
8080152a:	f642 03b8 	movw	r3, #10424	; 0x28b8
8080152e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801532:	601a      	str	r2, [r3, #0]
80801534:	f000 fb58 	bl	80801be8 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
80801538:	f642 03c0 	movw	r3, #10432	; 0x28c0
8080153c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801540:	681b      	ldr	r3, [r3, #0]
80801542:	693a      	ldr	r2, [r7, #16]
80801544:	429a      	cmp	r2, r3
80801546:	d365      	bcc.n	80801614 <xTaskIncrementTick+0x15c>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80801548:	f642 0358 	movw	r3, #10328	; 0x2858
8080154c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801550:	681b      	ldr	r3, [r3, #0]
80801552:	681b      	ldr	r3, [r3, #0]
80801554:	2b00      	cmp	r3, #0
80801556:	d101      	bne.n	8080155c <xTaskIncrementTick+0xa4>
80801558:	2301      	movs	r3, #1
8080155a:	e000      	b.n	8080155e <xTaskIncrementTick+0xa6>
8080155c:	2300      	movs	r3, #0
8080155e:	2b00      	cmp	r3, #0
80801560:	d007      	beq.n	80801572 <xTaskIncrementTick+0xba>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80801562:	f642 03c0 	movw	r3, #10432	; 0x28c0
80801566:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080156a:	f04f 32ff 	mov.w	r2, #4294967295
8080156e:	601a      	str	r2, [r3, #0]
					break;
80801570:	e050      	b.n	80801614 <xTaskIncrementTick+0x15c>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80801572:	f642 0358 	movw	r3, #10328	; 0x2858
80801576:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080157a:	681b      	ldr	r3, [r3, #0]
8080157c:	68db      	ldr	r3, [r3, #12]
8080157e:	68db      	ldr	r3, [r3, #12]
80801580:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
80801582:	68bb      	ldr	r3, [r7, #8]
80801584:	685b      	ldr	r3, [r3, #4]
80801586:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
80801588:	693a      	ldr	r2, [r7, #16]
8080158a:	687b      	ldr	r3, [r7, #4]
8080158c:	429a      	cmp	r2, r3
8080158e:	d206      	bcs.n	8080159e <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
80801590:	f642 03c0 	movw	r3, #10432	; 0x28c0
80801594:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801598:	687a      	ldr	r2, [r7, #4]
8080159a:	601a      	str	r2, [r3, #0]
						break;
8080159c:	e03a      	b.n	80801614 <xTaskIncrementTick+0x15c>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
8080159e:	68bb      	ldr	r3, [r7, #8]
808015a0:	3304      	adds	r3, #4
808015a2:	4618      	mov	r0, r3
808015a4:	f7fe fdd4 	bl	80800150 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
808015a8:	68bb      	ldr	r3, [r7, #8]
808015aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
808015ac:	2b00      	cmp	r3, #0
808015ae:	d004      	beq.n	808015ba <xTaskIncrementTick+0x102>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
808015b0:	68bb      	ldr	r3, [r7, #8]
808015b2:	3318      	adds	r3, #24
808015b4:	4618      	mov	r0, r3
808015b6:	f7fe fdcb 	bl	80800150 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
808015ba:	68bb      	ldr	r3, [r7, #8]
808015bc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808015be:	f642 03a8 	movw	r3, #10408	; 0x28a8
808015c2:	f2c8 0380 	movt	r3, #32896	; 0x8080
808015c6:	681b      	ldr	r3, [r3, #0]
808015c8:	429a      	cmp	r2, r3
808015ca:	d906      	bls.n	808015da <xTaskIncrementTick+0x122>
808015cc:	68bb      	ldr	r3, [r7, #8]
808015ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808015d0:	f642 03a8 	movw	r3, #10408	; 0x28a8
808015d4:	f2c8 0380 	movt	r3, #32896	; 0x8080
808015d8:	601a      	str	r2, [r3, #0]
808015da:	68bb      	ldr	r3, [r7, #8]
808015dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
808015de:	009b      	lsls	r3, r3, #2
808015e0:	009a      	lsls	r2, r3, #2
808015e2:	4413      	add	r3, r2
808015e4:	f242 72cc 	movw	r2, #10188	; 0x27cc
808015e8:	f2c8 0280 	movt	r2, #32896	; 0x8080
808015ec:	441a      	add	r2, r3
808015ee:	68bb      	ldr	r3, [r7, #8]
808015f0:	3304      	adds	r3, #4
808015f2:	4619      	mov	r1, r3
808015f4:	4610      	mov	r0, r2
808015f6:	f7fe fd4f 	bl	80800098 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
808015fa:	68bb      	ldr	r3, [r7, #8]
808015fc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808015fe:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801602:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801606:	681b      	ldr	r3, [r3, #0]
80801608:	6adb      	ldr	r3, [r3, #44]	; 0x2c
8080160a:	429a      	cmp	r2, r3
8080160c:	d39c      	bcc.n	80801548 <xTaskIncrementTick+0x90>
						{
							xSwitchRequired = pdTRUE;
8080160e:	2301      	movs	r3, #1
80801610:	617b      	str	r3, [r7, #20]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_PREEMPTION */
				}
			}
80801612:	e799      	b.n	80801548 <xTaskIncrementTick+0x90>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
80801614:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801618:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080161c:	681b      	ldr	r3, [r3, #0]
8080161e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801620:	f242 72cc 	movw	r2, #10188	; 0x27cc
80801624:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801628:	009b      	lsls	r3, r3, #2
8080162a:	0099      	lsls	r1, r3, #2
8080162c:	440b      	add	r3, r1
8080162e:	4413      	add	r3, r2
80801630:	681b      	ldr	r3, [r3, #0]
80801632:	2b01      	cmp	r3, #1
80801634:	d90d      	bls.n	80801652 <xTaskIncrementTick+0x19a>
			{
				xSwitchRequired = pdTRUE;
80801636:	2301      	movs	r3, #1
80801638:	617b      	str	r3, [r7, #20]
8080163a:	e00a      	b.n	80801652 <xTaskIncrementTick+0x19a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
8080163c:	f642 03b0 	movw	r3, #10416	; 0x28b0
80801640:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801644:	681b      	ldr	r3, [r3, #0]
80801646:	1c5a      	adds	r2, r3, #1
80801648:	f642 03b0 	movw	r3, #10416	; 0x28b0
8080164c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801650:	601a      	str	r2, [r3, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
80801652:	f642 03b4 	movw	r3, #10420	; 0x28b4
80801656:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080165a:	681b      	ldr	r3, [r3, #0]
8080165c:	2b00      	cmp	r3, #0
8080165e:	d001      	beq.n	80801664 <xTaskIncrementTick+0x1ac>
		{
			xSwitchRequired = pdTRUE;
80801660:	2301      	movs	r3, #1
80801662:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
80801664:	697b      	ldr	r3, [r7, #20]
}
80801666:	4618      	mov	r0, r3
80801668:	3718      	adds	r7, #24
8080166a:	46bd      	mov	sp, r7
8080166c:	bd80      	pop	{r7, pc}
8080166e:	bf00      	nop

80801670 <vTaskSetApplicationTaskTag>:
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
	{
80801670:	b580      	push	{r7, lr}
80801672:	b084      	sub	sp, #16
80801674:	af00      	add	r7, sp, #0
80801676:	6078      	str	r0, [r7, #4]
80801678:	6039      	str	r1, [r7, #0]
	TCB_t *xTCB;

		/* If xTask is NULL then it is the task hook of the calling task that is
		getting set. */
		if( xTask == NULL )
8080167a:	687b      	ldr	r3, [r7, #4]
8080167c:	2b00      	cmp	r3, #0
8080167e:	d106      	bne.n	8080168e <vTaskSetApplicationTaskTag+0x1e>
		{
			xTCB = ( TCB_t * ) pxCurrentTCB;
80801680:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801684:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801688:	681b      	ldr	r3, [r3, #0]
8080168a:	60fb      	str	r3, [r7, #12]
8080168c:	e001      	b.n	80801692 <vTaskSetApplicationTaskTag+0x22>
		}
		else
		{
			xTCB = ( TCB_t * ) xTask;
8080168e:	687b      	ldr	r3, [r7, #4]
80801690:	60fb      	str	r3, [r7, #12]
		}

		/* Save the hook function in the TCB.  A critical section is required as
		the value can be accessed from an interrupt. */
		taskENTER_CRITICAL();
80801692:	f000 fee7 	bl	80802464 <vPortEnterCritical>
			xTCB->pxTaskTag = pxHookFunction;
80801696:	68fb      	ldr	r3, [r7, #12]
80801698:	683a      	ldr	r2, [r7, #0]
8080169a:	645a      	str	r2, [r3, #68]	; 0x44
		taskEXIT_CRITICAL();
8080169c:	f000 fee8 	bl	80802470 <vPortExitCritical>
	}
808016a0:	bf00      	nop
808016a2:	3710      	adds	r7, #16
808016a4:	46bd      	mov	sp, r7
808016a6:	bd80      	pop	{r7, pc}

808016a8 <xTaskGetApplicationTaskTag>:
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
	{
808016a8:	b580      	push	{r7, lr}
808016aa:	b084      	sub	sp, #16
808016ac:	af00      	add	r7, sp, #0
808016ae:	6078      	str	r0, [r7, #4]
	TCB_t *xTCB;
	TaskHookFunction_t xReturn;

		/* If xTask is NULL then we are setting our own task hook. */
		if( xTask == NULL )
808016b0:	687b      	ldr	r3, [r7, #4]
808016b2:	2b00      	cmp	r3, #0
808016b4:	d106      	bne.n	808016c4 <xTaskGetApplicationTaskTag+0x1c>
		{
			xTCB = ( TCB_t * ) pxCurrentTCB;
808016b6:	f242 73c8 	movw	r3, #10184	; 0x27c8
808016ba:	f2c8 0380 	movt	r3, #32896	; 0x8080
808016be:	681b      	ldr	r3, [r3, #0]
808016c0:	60fb      	str	r3, [r7, #12]
808016c2:	e001      	b.n	808016c8 <xTaskGetApplicationTaskTag+0x20>
		}
		else
		{
			xTCB = ( TCB_t * ) xTask;
808016c4:	687b      	ldr	r3, [r7, #4]
808016c6:	60fb      	str	r3, [r7, #12]
		}

		/* Save the hook function in the TCB.  A critical section is required as
		the value can be accessed from an interrupt. */
		taskENTER_CRITICAL();
808016c8:	f000 fecc 	bl	80802464 <vPortEnterCritical>
		{
			xReturn = xTCB->pxTaskTag;
808016cc:	68fb      	ldr	r3, [r7, #12]
808016ce:	6c5b      	ldr	r3, [r3, #68]	; 0x44
808016d0:	60bb      	str	r3, [r7, #8]
		}
		taskEXIT_CRITICAL();
808016d2:	f000 fecd 	bl	80802470 <vPortExitCritical>

		return xReturn;
808016d6:	68bb      	ldr	r3, [r7, #8]
	}
808016d8:	4618      	mov	r0, r3
808016da:	3710      	adds	r7, #16
808016dc:	46bd      	mov	sp, r7
808016de:	bd80      	pop	{r7, pc}

808016e0 <xTaskCallApplicationTaskHook>:
/*-----------------------------------------------------------*/

#if ( configUSE_APPLICATION_TASK_TAG == 1 )

	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
	{
808016e0:	b580      	push	{r7, lr}
808016e2:	b084      	sub	sp, #16
808016e4:	af00      	add	r7, sp, #0
808016e6:	6078      	str	r0, [r7, #4]
808016e8:	6039      	str	r1, [r7, #0]
	TCB_t *xTCB;
	BaseType_t xReturn;

		/* If xTask is NULL then we are calling our own task hook. */
		if( xTask == NULL )
808016ea:	687b      	ldr	r3, [r7, #4]
808016ec:	2b00      	cmp	r3, #0
808016ee:	d106      	bne.n	808016fe <xTaskCallApplicationTaskHook+0x1e>
		{
			xTCB = ( TCB_t * ) pxCurrentTCB;
808016f0:	f242 73c8 	movw	r3, #10184	; 0x27c8
808016f4:	f2c8 0380 	movt	r3, #32896	; 0x8080
808016f8:	681b      	ldr	r3, [r3, #0]
808016fa:	60fb      	str	r3, [r7, #12]
808016fc:	e001      	b.n	80801702 <xTaskCallApplicationTaskHook+0x22>
		}
		else
		{
			xTCB = ( TCB_t * ) xTask;
808016fe:	687b      	ldr	r3, [r7, #4]
80801700:	60fb      	str	r3, [r7, #12]
		}

		if( xTCB->pxTaskTag != NULL )
80801702:	68fb      	ldr	r3, [r7, #12]
80801704:	6c5b      	ldr	r3, [r3, #68]	; 0x44
80801706:	2b00      	cmp	r3, #0
80801708:	d005      	beq.n	80801716 <xTaskCallApplicationTaskHook+0x36>
		{
			xReturn = xTCB->pxTaskTag( pvParameter );
8080170a:	68fb      	ldr	r3, [r7, #12]
8080170c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
8080170e:	6838      	ldr	r0, [r7, #0]
80801710:	4798      	blx	r3
80801712:	60b8      	str	r0, [r7, #8]
80801714:	e001      	b.n	8080171a <xTaskCallApplicationTaskHook+0x3a>
		}
		else
		{
			xReturn = pdFAIL;
80801716:	2300      	movs	r3, #0
80801718:	60bb      	str	r3, [r7, #8]
		}

		return xReturn;
8080171a:	68bb      	ldr	r3, [r7, #8]
	}
8080171c:	4618      	mov	r0, r3
8080171e:	3710      	adds	r7, #16
80801720:	46bd      	mov	sp, r7
80801722:	bd80      	pop	{r7, pc}

80801724 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
80801724:	b480      	push	{r7}
80801726:	b083      	sub	sp, #12
80801728:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
8080172a:	f642 03c8 	movw	r3, #10440	; 0x28c8
8080172e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801732:	681b      	ldr	r3, [r3, #0]
80801734:	2b00      	cmp	r3, #0
80801736:	d006      	beq.n	80801746 <vTaskSwitchContext+0x22>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
80801738:	f642 03b4 	movw	r3, #10420	; 0x28b4
8080173c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801740:	2201      	movs	r2, #1
80801742:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
80801744:	e043      	b.n	808017ce <vTaskSwitchContext+0xaa>
		switch. */
		xYieldPending = pdTRUE;
	}
	else
	{
		xYieldPending = pdFALSE;
80801746:	f642 03b4 	movw	r3, #10420	; 0x28b4
8080174a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080174e:	2200      	movs	r2, #0
80801750:	601a      	str	r2, [r3, #0]
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
80801752:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801756:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080175a:	681b      	ldr	r3, [r3, #0]
8080175c:	607b      	str	r3, [r7, #4]
8080175e:	e002      	b.n	80801766 <vTaskSwitchContext+0x42>
80801760:	687b      	ldr	r3, [r7, #4]
80801762:	3b01      	subs	r3, #1
80801764:	607b      	str	r3, [r7, #4]
80801766:	f242 72cc 	movw	r2, #10188	; 0x27cc
8080176a:	f2c8 0280 	movt	r2, #32896	; 0x8080
8080176e:	687b      	ldr	r3, [r7, #4]
80801770:	009b      	lsls	r3, r3, #2
80801772:	0099      	lsls	r1, r3, #2
80801774:	440b      	add	r3, r1
80801776:	4413      	add	r3, r2
80801778:	681b      	ldr	r3, [r3, #0]
8080177a:	2b00      	cmp	r3, #0
8080177c:	d0f0      	beq.n	80801760 <vTaskSwitchContext+0x3c>
8080177e:	687b      	ldr	r3, [r7, #4]
80801780:	009b      	lsls	r3, r3, #2
80801782:	009a      	lsls	r2, r3, #2
80801784:	4413      	add	r3, r2
80801786:	f242 72cc 	movw	r2, #10188	; 0x27cc
8080178a:	f2c8 0280 	movt	r2, #32896	; 0x8080
8080178e:	4413      	add	r3, r2
80801790:	603b      	str	r3, [r7, #0]
80801792:	683b      	ldr	r3, [r7, #0]
80801794:	685b      	ldr	r3, [r3, #4]
80801796:	685a      	ldr	r2, [r3, #4]
80801798:	683b      	ldr	r3, [r7, #0]
8080179a:	605a      	str	r2, [r3, #4]
8080179c:	683b      	ldr	r3, [r7, #0]
8080179e:	685a      	ldr	r2, [r3, #4]
808017a0:	683b      	ldr	r3, [r7, #0]
808017a2:	3308      	adds	r3, #8
808017a4:	429a      	cmp	r2, r3
808017a6:	d104      	bne.n	808017b2 <vTaskSwitchContext+0x8e>
808017a8:	683b      	ldr	r3, [r7, #0]
808017aa:	685b      	ldr	r3, [r3, #4]
808017ac:	685a      	ldr	r2, [r3, #4]
808017ae:	683b      	ldr	r3, [r7, #0]
808017b0:	605a      	str	r2, [r3, #4]
808017b2:	683b      	ldr	r3, [r7, #0]
808017b4:	685b      	ldr	r3, [r3, #4]
808017b6:	68da      	ldr	r2, [r3, #12]
808017b8:	f242 73c8 	movw	r3, #10184	; 0x27c8
808017bc:	f2c8 0380 	movt	r3, #32896	; 0x8080
808017c0:	601a      	str	r2, [r3, #0]
808017c2:	f642 03a8 	movw	r3, #10408	; 0x28a8
808017c6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808017ca:	687a      	ldr	r2, [r7, #4]
808017cc:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
808017ce:	bf00      	nop
808017d0:	370c      	adds	r7, #12
808017d2:	46bd      	mov	sp, r7
808017d4:	bc80      	pop	{r7}
808017d6:	4770      	bx	lr

808017d8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
808017d8:	b580      	push	{r7, lr}
808017da:	b082      	sub	sp, #8
808017dc:	af00      	add	r7, sp, #0
808017de:	6078      	str	r0, [r7, #4]
808017e0:	6039      	str	r1, [r7, #0]

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
808017e2:	f242 73c8 	movw	r3, #10184	; 0x27c8
808017e6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808017ea:	681b      	ldr	r3, [r3, #0]
808017ec:	3318      	adds	r3, #24
808017ee:	4619      	mov	r1, r3
808017f0:	6878      	ldr	r0, [r7, #4]
808017f2:	f7fe fc75 	bl	808000e0 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
808017f6:	2101      	movs	r1, #1
808017f8:	6838      	ldr	r0, [r7, #0]
808017fa:	f000 fca7 	bl	8080214c <prvAddCurrentTaskToDelayedList>
}
808017fe:	bf00      	nop
80801800:	3708      	adds	r7, #8
80801802:	46bd      	mov	sp, r7
80801804:	bd80      	pop	{r7, pc}
80801806:	bf00      	nop

80801808 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
80801808:	b580      	push	{r7, lr}
8080180a:	b084      	sub	sp, #16
8080180c:	af00      	add	r7, sp, #0
8080180e:	60f8      	str	r0, [r7, #12]
80801810:	60b9      	str	r1, [r7, #8]
80801812:	607a      	str	r2, [r7, #4]
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
80801814:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801818:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080181c:	681b      	ldr	r3, [r3, #0]
8080181e:	68ba      	ldr	r2, [r7, #8]
80801820:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
80801824:	619a      	str	r2, [r3, #24]
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
80801826:	f242 73c8 	movw	r3, #10184	; 0x27c8
8080182a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080182e:	681b      	ldr	r3, [r3, #0]
80801830:	3318      	adds	r3, #24
80801832:	4619      	mov	r1, r3
80801834:	68f8      	ldr	r0, [r7, #12]
80801836:	f7fe fc2f 	bl	80800098 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
8080183a:	2101      	movs	r1, #1
8080183c:	6878      	ldr	r0, [r7, #4]
8080183e:	f000 fc85 	bl	8080214c <prvAddCurrentTaskToDelayedList>
}
80801842:	bf00      	nop
80801844:	3710      	adds	r7, #16
80801846:	46bd      	mov	sp, r7
80801848:	bd80      	pop	{r7, pc}
8080184a:	bf00      	nop

8080184c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
8080184c:	b580      	push	{r7, lr}
8080184e:	b084      	sub	sp, #16
80801850:	af00      	add	r7, sp, #0
80801852:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
80801854:	687b      	ldr	r3, [r7, #4]
80801856:	68db      	ldr	r3, [r3, #12]
80801858:	68db      	ldr	r3, [r3, #12]
8080185a:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
8080185c:	68bb      	ldr	r3, [r7, #8]
8080185e:	3318      	adds	r3, #24
80801860:	4618      	mov	r0, r3
80801862:	f7fe fc75 	bl	80800150 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80801866:	f642 03c8 	movw	r3, #10440	; 0x28c8
8080186a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080186e:	681b      	ldr	r3, [r3, #0]
80801870:	2b00      	cmp	r3, #0
80801872:	d125      	bne.n	808018c0 <xTaskRemoveFromEventList+0x74>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80801874:	68bb      	ldr	r3, [r7, #8]
80801876:	3304      	adds	r3, #4
80801878:	4618      	mov	r0, r3
8080187a:	f7fe fc69 	bl	80800150 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
8080187e:	68bb      	ldr	r3, [r7, #8]
80801880:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801882:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801886:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080188a:	681b      	ldr	r3, [r3, #0]
8080188c:	429a      	cmp	r2, r3
8080188e:	d906      	bls.n	8080189e <xTaskRemoveFromEventList+0x52>
80801890:	68bb      	ldr	r3, [r7, #8]
80801892:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801894:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801898:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080189c:	601a      	str	r2, [r3, #0]
8080189e:	68bb      	ldr	r3, [r7, #8]
808018a0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
808018a2:	009b      	lsls	r3, r3, #2
808018a4:	009a      	lsls	r2, r3, #2
808018a6:	4413      	add	r3, r2
808018a8:	f242 72cc 	movw	r2, #10188	; 0x27cc
808018ac:	f2c8 0280 	movt	r2, #32896	; 0x8080
808018b0:	441a      	add	r2, r3
808018b2:	68bb      	ldr	r3, [r7, #8]
808018b4:	3304      	adds	r3, #4
808018b6:	4619      	mov	r1, r3
808018b8:	4610      	mov	r0, r2
808018ba:	f7fe fbed 	bl	80800098 <vListInsertEnd>
808018be:	e008      	b.n	808018d2 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
808018c0:	68bb      	ldr	r3, [r7, #8]
808018c2:	3318      	adds	r3, #24
808018c4:	4619      	mov	r1, r3
808018c6:	f642 0060 	movw	r0, #10336	; 0x2860
808018ca:	f2c8 0080 	movt	r0, #32896	; 0x8080
808018ce:	f7fe fbe3 	bl	80800098 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
808018d2:	68bb      	ldr	r3, [r7, #8]
808018d4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808018d6:	f242 73c8 	movw	r3, #10184	; 0x27c8
808018da:	f2c8 0380 	movt	r3, #32896	; 0x8080
808018de:	681b      	ldr	r3, [r3, #0]
808018e0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
808018e2:	429a      	cmp	r2, r3
808018e4:	d908      	bls.n	808018f8 <xTaskRemoveFromEventList+0xac>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
808018e6:	2301      	movs	r3, #1
808018e8:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
808018ea:	f642 03b4 	movw	r3, #10420	; 0x28b4
808018ee:	f2c8 0380 	movt	r3, #32896	; 0x8080
808018f2:	2201      	movs	r2, #1
808018f4:	601a      	str	r2, [r3, #0]
808018f6:	e001      	b.n	808018fc <xTaskRemoveFromEventList+0xb0>
	}
	else
	{
		xReturn = pdFALSE;
808018f8:	2300      	movs	r3, #0
808018fa:	60fb      	str	r3, [r7, #12]
		ensure it is updated at the earliest possible time. */
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
808018fc:	68fb      	ldr	r3, [r7, #12]
}
808018fe:	4618      	mov	r0, r3
80801900:	3710      	adds	r7, #16
80801902:	46bd      	mov	sp, r7
80801904:	bd80      	pop	{r7, pc}
80801906:	bf00      	nop

80801908 <xTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
80801908:	b580      	push	{r7, lr}
8080190a:	b084      	sub	sp, #16
8080190c:	af00      	add	r7, sp, #0
8080190e:	6078      	str	r0, [r7, #4]
80801910:	6039      	str	r1, [r7, #0]
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
80801912:	683b      	ldr	r3, [r7, #0]
80801914:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
80801918:	687b      	ldr	r3, [r7, #4]
8080191a:	601a      	str	r2, [r3, #0]

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
8080191c:	687b      	ldr	r3, [r7, #4]
8080191e:	68db      	ldr	r3, [r3, #12]
80801920:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
80801922:	6878      	ldr	r0, [r7, #4]
80801924:	f7fe fc14 	bl	80800150 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
80801928:	68bb      	ldr	r3, [r7, #8]
8080192a:	3304      	adds	r3, #4
8080192c:	4618      	mov	r0, r3
8080192e:	f7fe fc0f 	bl	80800150 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
80801932:	68bb      	ldr	r3, [r7, #8]
80801934:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801936:	f642 03a8 	movw	r3, #10408	; 0x28a8
8080193a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080193e:	681b      	ldr	r3, [r3, #0]
80801940:	429a      	cmp	r2, r3
80801942:	d906      	bls.n	80801952 <xTaskRemoveFromUnorderedEventList+0x4a>
80801944:	68bb      	ldr	r3, [r7, #8]
80801946:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801948:	f642 03a8 	movw	r3, #10408	; 0x28a8
8080194c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801950:	601a      	str	r2, [r3, #0]
80801952:	68bb      	ldr	r3, [r7, #8]
80801954:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801956:	009b      	lsls	r3, r3, #2
80801958:	009a      	lsls	r2, r3, #2
8080195a:	4413      	add	r3, r2
8080195c:	f242 72cc 	movw	r2, #10188	; 0x27cc
80801960:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801964:	441a      	add	r2, r3
80801966:	68bb      	ldr	r3, [r7, #8]
80801968:	3304      	adds	r3, #4
8080196a:	4619      	mov	r1, r3
8080196c:	4610      	mov	r0, r2
8080196e:	f7fe fb93 	bl	80800098 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
80801972:	68bb      	ldr	r3, [r7, #8]
80801974:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801976:	f242 73c8 	movw	r3, #10184	; 0x27c8
8080197a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080197e:	681b      	ldr	r3, [r3, #0]
80801980:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801982:	429a      	cmp	r2, r3
80801984:	d908      	bls.n	80801998 <xTaskRemoveFromUnorderedEventList+0x90>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
80801986:	2301      	movs	r3, #1
80801988:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
8080198a:	f642 03b4 	movw	r3, #10420	; 0x28b4
8080198e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801992:	2201      	movs	r2, #1
80801994:	601a      	str	r2, [r3, #0]
80801996:	e001      	b.n	8080199c <xTaskRemoveFromUnorderedEventList+0x94>
	}
	else
	{
		xReturn = pdFALSE;
80801998:	2300      	movs	r3, #0
8080199a:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
8080199c:	68fb      	ldr	r3, [r7, #12]
}
8080199e:	4618      	mov	r0, r3
808019a0:	3710      	adds	r7, #16
808019a2:	46bd      	mov	sp, r7
808019a4:	bd80      	pop	{r7, pc}
808019a6:	bf00      	nop

808019a8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
808019a8:	b480      	push	{r7}
808019aa:	b083      	sub	sp, #12
808019ac:	af00      	add	r7, sp, #0
808019ae:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
808019b0:	f642 03b8 	movw	r3, #10424	; 0x28b8
808019b4:	f2c8 0380 	movt	r3, #32896	; 0x8080
808019b8:	681a      	ldr	r2, [r3, #0]
808019ba:	687b      	ldr	r3, [r7, #4]
808019bc:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
808019be:	f642 03a4 	movw	r3, #10404	; 0x28a4
808019c2:	f2c8 0380 	movt	r3, #32896	; 0x8080
808019c6:	681a      	ldr	r2, [r3, #0]
808019c8:	687b      	ldr	r3, [r7, #4]
808019ca:	605a      	str	r2, [r3, #4]
}
808019cc:	bf00      	nop
808019ce:	370c      	adds	r7, #12
808019d0:	46bd      	mov	sp, r7
808019d2:	bc80      	pop	{r7}
808019d4:	4770      	bx	lr
808019d6:	bf00      	nop

808019d8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
808019d8:	b580      	push	{r7, lr}
808019da:	b084      	sub	sp, #16
808019dc:	af00      	add	r7, sp, #0
808019de:	6078      	str	r0, [r7, #4]
808019e0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
808019e2:	f000 fd3f 	bl	80802464 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
808019e6:	f642 03a4 	movw	r3, #10404	; 0x28a4
808019ea:	f2c8 0380 	movt	r3, #32896	; 0x8080
808019ee:	681b      	ldr	r3, [r3, #0]
808019f0:	60bb      	str	r3, [r7, #8]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
808019f2:	683b      	ldr	r3, [r7, #0]
808019f4:	681b      	ldr	r3, [r3, #0]
808019f6:	f1b3 3fff 	cmp.w	r3, #4294967295
808019fa:	d102      	bne.n	80801a02 <xTaskCheckForTimeOut+0x2a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
808019fc:	2300      	movs	r3, #0
808019fe:	60fb      	str	r3, [r7, #12]
80801a00:	e029      	b.n	80801a56 <xTaskCheckForTimeOut+0x7e>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
80801a02:	687b      	ldr	r3, [r7, #4]
80801a04:	681a      	ldr	r2, [r3, #0]
80801a06:	f642 03b8 	movw	r3, #10424	; 0x28b8
80801a0a:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801a0e:	681b      	ldr	r3, [r3, #0]
80801a10:	429a      	cmp	r2, r3
80801a12:	d007      	beq.n	80801a24 <xTaskCheckForTimeOut+0x4c>
80801a14:	687b      	ldr	r3, [r7, #4]
80801a16:	685a      	ldr	r2, [r3, #4]
80801a18:	68bb      	ldr	r3, [r7, #8]
80801a1a:	429a      	cmp	r2, r3
80801a1c:	d802      	bhi.n	80801a24 <xTaskCheckForTimeOut+0x4c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
80801a1e:	2301      	movs	r3, #1
80801a20:	60fb      	str	r3, [r7, #12]
80801a22:	e018      	b.n	80801a56 <xTaskCheckForTimeOut+0x7e>
		}
		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
80801a24:	687b      	ldr	r3, [r7, #4]
80801a26:	685b      	ldr	r3, [r3, #4]
80801a28:	68ba      	ldr	r2, [r7, #8]
80801a2a:	1ad2      	subs	r2, r2, r3
80801a2c:	683b      	ldr	r3, [r7, #0]
80801a2e:	681b      	ldr	r3, [r3, #0]
80801a30:	429a      	cmp	r2, r3
80801a32:	d20e      	bcs.n	80801a52 <xTaskCheckForTimeOut+0x7a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
80801a34:	683b      	ldr	r3, [r7, #0]
80801a36:	681a      	ldr	r2, [r3, #0]
80801a38:	687b      	ldr	r3, [r7, #4]
80801a3a:	6859      	ldr	r1, [r3, #4]
80801a3c:	68bb      	ldr	r3, [r7, #8]
80801a3e:	1acb      	subs	r3, r1, r3
80801a40:	441a      	add	r2, r3
80801a42:	683b      	ldr	r3, [r7, #0]
80801a44:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
80801a46:	6878      	ldr	r0, [r7, #4]
80801a48:	f7ff ffae 	bl	808019a8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
80801a4c:	2300      	movs	r3, #0
80801a4e:	60fb      	str	r3, [r7, #12]
80801a50:	e001      	b.n	80801a56 <xTaskCheckForTimeOut+0x7e>
		}
		else
		{
			xReturn = pdTRUE;
80801a52:	2301      	movs	r3, #1
80801a54:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
80801a56:	f000 fd0b 	bl	80802470 <vPortExitCritical>

	return xReturn;
80801a5a:	68fb      	ldr	r3, [r7, #12]
}
80801a5c:	4618      	mov	r0, r3
80801a5e:	3710      	adds	r7, #16
80801a60:	46bd      	mov	sp, r7
80801a62:	bd80      	pop	{r7, pc}

80801a64 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
80801a64:	b480      	push	{r7}
80801a66:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
80801a68:	f642 03b4 	movw	r3, #10420	; 0x28b4
80801a6c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801a70:	2201      	movs	r2, #1
80801a72:	601a      	str	r2, [r3, #0]
}
80801a74:	bf00      	nop
80801a76:	46bd      	mov	sp, r7
80801a78:	bc80      	pop	{r7}
80801a7a:	4770      	bx	lr

80801a7c <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
80801a7c:	b580      	push	{r7, lr}
80801a7e:	b082      	sub	sp, #8
80801a80:	af00      	add	r7, sp, #0
80801a82:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
80801a84:	f000 f856 	bl	80801b34 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
80801a88:	f242 73cc 	movw	r3, #10188	; 0x27cc
80801a8c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801a90:	681b      	ldr	r3, [r3, #0]
80801a92:	2b01      	cmp	r3, #1
80801a94:	d9f6      	bls.n	80801a84 <prvIdleTask+0x8>
			{
				taskYIELD();
80801a96:	df00      	svc	0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
80801a98:	e7f4      	b.n	80801a84 <prvIdleTask+0x8>
80801a9a:	bf00      	nop

80801a9c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
80801a9c:	b580      	push	{r7, lr}
80801a9e:	b082      	sub	sp, #8
80801aa0:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80801aa2:	2300      	movs	r3, #0
80801aa4:	607b      	str	r3, [r7, #4]
80801aa6:	e00e      	b.n	80801ac6 <prvInitialiseTaskLists+0x2a>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
80801aa8:	687b      	ldr	r3, [r7, #4]
80801aaa:	009b      	lsls	r3, r3, #2
80801aac:	009a      	lsls	r2, r3, #2
80801aae:	4413      	add	r3, r2
80801ab0:	f242 72cc 	movw	r2, #10188	; 0x27cc
80801ab4:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801ab8:	4413      	add	r3, r2
80801aba:	4618      	mov	r0, r3
80801abc:	f7fe fac0 	bl	80800040 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
80801ac0:	687b      	ldr	r3, [r7, #4]
80801ac2:	3301      	adds	r3, #1
80801ac4:	607b      	str	r3, [r7, #4]
80801ac6:	687b      	ldr	r3, [r7, #4]
80801ac8:	2b04      	cmp	r3, #4
80801aca:	d9ed      	bls.n	80801aa8 <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
80801acc:	f642 0030 	movw	r0, #10288	; 0x2830
80801ad0:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801ad4:	f7fe fab4 	bl	80800040 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
80801ad8:	f642 0044 	movw	r0, #10308	; 0x2844
80801adc:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801ae0:	f7fe faae 	bl	80800040 <vListInitialise>
	vListInitialise( &xPendingReadyList );
80801ae4:	f642 0060 	movw	r0, #10336	; 0x2860
80801ae8:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801aec:	f7fe faa8 	bl	80800040 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
80801af0:	f642 0074 	movw	r0, #10356	; 0x2874
80801af4:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801af8:	f7fe faa2 	bl	80800040 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
80801afc:	f642 008c 	movw	r0, #10380	; 0x288c
80801b00:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801b04:	f7fe fa9c 	bl	80800040 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
80801b08:	f642 0358 	movw	r3, #10328	; 0x2858
80801b0c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801b10:	f642 0230 	movw	r2, #10288	; 0x2830
80801b14:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801b18:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
80801b1a:	f642 035c 	movw	r3, #10332	; 0x285c
80801b1e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801b22:	f642 0244 	movw	r2, #10308	; 0x2844
80801b26:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801b2a:	601a      	str	r2, [r3, #0]
}
80801b2c:	bf00      	nop
80801b2e:	3708      	adds	r7, #8
80801b30:	46bd      	mov	sp, r7
80801b32:	bd80      	pop	{r7, pc}

80801b34 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
80801b34:	b580      	push	{r7, lr}
80801b36:	b082      	sub	sp, #8
80801b38:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80801b3a:	e03a      	b.n	80801bb2 <prvCheckTasksWaitingTermination+0x7e>
		{
			vTaskSuspendAll();
80801b3c:	f7ff fbc2 	bl	808012c4 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
80801b40:	f642 0374 	movw	r3, #10356	; 0x2874
80801b44:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801b48:	681b      	ldr	r3, [r3, #0]
80801b4a:	2b00      	cmp	r3, #0
80801b4c:	bf0c      	ite	eq
80801b4e:	2301      	moveq	r3, #1
80801b50:	2300      	movne	r3, #0
80801b52:	b2db      	uxtb	r3, r3
80801b54:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
80801b56:	f7ff fbc7 	bl	808012e8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
80801b5a:	687b      	ldr	r3, [r7, #4]
80801b5c:	2b00      	cmp	r3, #0
80801b5e:	d128      	bne.n	80801bb2 <prvCheckTasksWaitingTermination+0x7e>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
80801b60:	f000 fc80 	bl	80802464 <vPortEnterCritical>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
80801b64:	f642 0374 	movw	r3, #10356	; 0x2874
80801b68:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801b6c:	68db      	ldr	r3, [r3, #12]
80801b6e:	68db      	ldr	r3, [r3, #12]
80801b70:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80801b72:	683b      	ldr	r3, [r7, #0]
80801b74:	3304      	adds	r3, #4
80801b76:	4618      	mov	r0, r3
80801b78:	f7fe faea 	bl	80800150 <uxListRemove>
					--uxCurrentNumberOfTasks;
80801b7c:	f642 03a0 	movw	r3, #10400	; 0x28a0
80801b80:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801b84:	681b      	ldr	r3, [r3, #0]
80801b86:	1e5a      	subs	r2, r3, #1
80801b88:	f642 03a0 	movw	r3, #10400	; 0x28a0
80801b8c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801b90:	601a      	str	r2, [r3, #0]
					--uxDeletedTasksWaitingCleanUp;
80801b92:	f642 0388 	movw	r3, #10376	; 0x2888
80801b96:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801b9a:	681b      	ldr	r3, [r3, #0]
80801b9c:	1e5a      	subs	r2, r3, #1
80801b9e:	f642 0388 	movw	r3, #10376	; 0x2888
80801ba2:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801ba6:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
80801ba8:	f000 fc62 	bl	80802470 <vPortExitCritical>

				prvDeleteTCB( pxTCB );
80801bac:	6838      	ldr	r0, [r7, #0]
80801bae:	f000 f80b 	bl	80801bc8 <prvDeleteTCB>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
80801bb2:	f642 0388 	movw	r3, #10376	; 0x2888
80801bb6:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801bba:	681b      	ldr	r3, [r3, #0]
80801bbc:	2b00      	cmp	r3, #0
80801bbe:	d1bd      	bne.n	80801b3c <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
80801bc0:	bf00      	nop
80801bc2:	3708      	adds	r7, #8
80801bc4:	46bd      	mov	sp, r7
80801bc6:	bd80      	pop	{r7, pc}

80801bc8 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
80801bc8:	b580      	push	{r7, lr}
80801bca:	b082      	sub	sp, #8
80801bcc:	af00      	add	r7, sp, #0
80801bce:	6078      	str	r0, [r7, #4]

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
80801bd0:	687b      	ldr	r3, [r7, #4]
80801bd2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
80801bd4:	4618      	mov	r0, r3
80801bd6:	f000 fbc1 	bl	8080235c <vPortFree>
			vPortFree( pxTCB );
80801bda:	6878      	ldr	r0, [r7, #4]
80801bdc:	f000 fbbe 	bl	8080235c <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
80801be0:	bf00      	nop
80801be2:	3708      	adds	r7, #8
80801be4:	46bd      	mov	sp, r7
80801be6:	bd80      	pop	{r7, pc}

80801be8 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
80801be8:	b480      	push	{r7}
80801bea:	b083      	sub	sp, #12
80801bec:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
80801bee:	f642 0358 	movw	r3, #10328	; 0x2858
80801bf2:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801bf6:	681b      	ldr	r3, [r3, #0]
80801bf8:	681b      	ldr	r3, [r3, #0]
80801bfa:	2b00      	cmp	r3, #0
80801bfc:	d101      	bne.n	80801c02 <prvResetNextTaskUnblockTime+0x1a>
80801bfe:	2301      	movs	r3, #1
80801c00:	e000      	b.n	80801c04 <prvResetNextTaskUnblockTime+0x1c>
80801c02:	2300      	movs	r3, #0
80801c04:	2b00      	cmp	r3, #0
80801c06:	d007      	beq.n	80801c18 <prvResetNextTaskUnblockTime+0x30>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
80801c08:	f642 03c0 	movw	r3, #10432	; 0x28c0
80801c0c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801c10:	f04f 32ff 	mov.w	r2, #4294967295
80801c14:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
80801c16:	e00e      	b.n	80801c36 <prvResetNextTaskUnblockTime+0x4e>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
80801c18:	f642 0358 	movw	r3, #10328	; 0x2858
80801c1c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801c20:	681b      	ldr	r3, [r3, #0]
80801c22:	68db      	ldr	r3, [r3, #12]
80801c24:	68db      	ldr	r3, [r3, #12]
80801c26:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
80801c28:	687b      	ldr	r3, [r7, #4]
80801c2a:	685a      	ldr	r2, [r3, #4]
80801c2c:	f642 03c0 	movw	r3, #10432	; 0x28c0
80801c30:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801c34:	601a      	str	r2, [r3, #0]
	}
}
80801c36:	bf00      	nop
80801c38:	370c      	adds	r7, #12
80801c3a:	46bd      	mov	sp, r7
80801c3c:	bc80      	pop	{r7}
80801c3e:	4770      	bx	lr

80801c40 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
80801c40:	b480      	push	{r7}
80801c42:	b083      	sub	sp, #12
80801c44:	af00      	add	r7, sp, #0
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
80801c46:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801c4a:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801c4e:	681b      	ldr	r3, [r3, #0]
80801c50:	699b      	ldr	r3, [r3, #24]
80801c52:	607b      	str	r3, [r7, #4]

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
80801c54:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801c58:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801c5c:	681a      	ldr	r2, [r3, #0]
80801c5e:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801c62:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801c66:	681b      	ldr	r3, [r3, #0]
80801c68:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801c6a:	f1c3 0305 	rsb	r3, r3, #5
80801c6e:	6193      	str	r3, [r2, #24]

	return uxReturn;
80801c70:	687b      	ldr	r3, [r7, #4]
}
80801c72:	4618      	mov	r0, r3
80801c74:	370c      	adds	r7, #12
80801c76:	46bd      	mov	sp, r7
80801c78:	bc80      	pop	{r7}
80801c7a:	4770      	bx	lr

80801c7c <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
80801c7c:	b580      	push	{r7, lr}
80801c7e:	b084      	sub	sp, #16
80801c80:	af00      	add	r7, sp, #0
80801c82:	6078      	str	r0, [r7, #4]
80801c84:	6039      	str	r1, [r7, #0]
	uint32_t ulReturn;

		taskENTER_CRITICAL();
80801c86:	f000 fbed 	bl	80802464 <vPortEnterCritical>
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
80801c8a:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801c8e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801c92:	681b      	ldr	r3, [r3, #0]
80801c94:	6c9b      	ldr	r3, [r3, #72]	; 0x48
80801c96:	2b00      	cmp	r3, #0
80801c98:	d10f      	bne.n	80801cba <ulTaskNotifyTake+0x3e>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
80801c9a:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801c9e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801ca2:	681b      	ldr	r3, [r3, #0]
80801ca4:	2201      	movs	r2, #1
80801ca6:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

				if( xTicksToWait > ( TickType_t ) 0 )
80801caa:	683b      	ldr	r3, [r7, #0]
80801cac:	2b00      	cmp	r3, #0
80801cae:	d004      	beq.n	80801cba <ulTaskNotifyTake+0x3e>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80801cb0:	2101      	movs	r1, #1
80801cb2:	6838      	ldr	r0, [r7, #0]
80801cb4:	f000 fa4a 	bl	8080214c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
80801cb8:	df00      	svc	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
80801cba:	f000 fbd9 	bl	80802470 <vPortExitCritical>

		taskENTER_CRITICAL();
80801cbe:	f000 fbd1 	bl	80802464 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
80801cc2:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801cc6:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801cca:	681b      	ldr	r3, [r3, #0]
80801ccc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
80801cce:	60fb      	str	r3, [r7, #12]

			if( ulReturn != 0UL )
80801cd0:	68fb      	ldr	r3, [r7, #12]
80801cd2:	2b00      	cmp	r3, #0
80801cd4:	d012      	beq.n	80801cfc <ulTaskNotifyTake+0x80>
			{
				if( xClearCountOnExit != pdFALSE )
80801cd6:	687b      	ldr	r3, [r7, #4]
80801cd8:	2b00      	cmp	r3, #0
80801cda:	d007      	beq.n	80801cec <ulTaskNotifyTake+0x70>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
80801cdc:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801ce0:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801ce4:	681b      	ldr	r3, [r3, #0]
80801ce6:	2200      	movs	r2, #0
80801ce8:	649a      	str	r2, [r3, #72]	; 0x48
80801cea:	e007      	b.n	80801cfc <ulTaskNotifyTake+0x80>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
80801cec:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801cf0:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801cf4:	681b      	ldr	r3, [r3, #0]
80801cf6:	68fa      	ldr	r2, [r7, #12]
80801cf8:	3a01      	subs	r2, #1
80801cfa:	649a      	str	r2, [r3, #72]	; 0x48
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
80801cfc:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801d00:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801d04:	681b      	ldr	r3, [r3, #0]
80801d06:	2200      	movs	r2, #0
80801d08:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		}
		taskEXIT_CRITICAL();
80801d0c:	f000 fbb0 	bl	80802470 <vPortExitCritical>

		return ulReturn;
80801d10:	68fb      	ldr	r3, [r7, #12]
	}
80801d12:	4618      	mov	r0, r3
80801d14:	3710      	adds	r7, #16
80801d16:	46bd      	mov	sp, r7
80801d18:	bd80      	pop	{r7, pc}
80801d1a:	bf00      	nop

80801d1c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
80801d1c:	b580      	push	{r7, lr}
80801d1e:	b086      	sub	sp, #24
80801d20:	af00      	add	r7, sp, #0
80801d22:	60f8      	str	r0, [r7, #12]
80801d24:	60b9      	str	r1, [r7, #8]
80801d26:	607a      	str	r2, [r7, #4]
80801d28:	603b      	str	r3, [r7, #0]
	BaseType_t xReturn;

		taskENTER_CRITICAL();
80801d2a:	f000 fb9b 	bl	80802464 <vPortEnterCritical>
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
80801d2e:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801d32:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801d36:	681b      	ldr	r3, [r3, #0]
80801d38:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
80801d3c:	b2db      	uxtb	r3, r3
80801d3e:	2b02      	cmp	r3, #2
80801d40:	d019      	beq.n	80801d76 <xTaskNotifyWait+0x5a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
80801d42:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801d46:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801d4a:	681b      	ldr	r3, [r3, #0]
80801d4c:	6c99      	ldr	r1, [r3, #72]	; 0x48
80801d4e:	68fa      	ldr	r2, [r7, #12]
80801d50:	43d2      	mvns	r2, r2
80801d52:	400a      	ands	r2, r1
80801d54:	649a      	str	r2, [r3, #72]	; 0x48

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
80801d56:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801d5a:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801d5e:	681b      	ldr	r3, [r3, #0]
80801d60:	2201      	movs	r2, #1
80801d62:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

				if( xTicksToWait > ( TickType_t ) 0 )
80801d66:	683b      	ldr	r3, [r7, #0]
80801d68:	2b00      	cmp	r3, #0
80801d6a:	d004      	beq.n	80801d76 <xTaskNotifyWait+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
80801d6c:	2101      	movs	r1, #1
80801d6e:	6838      	ldr	r0, [r7, #0]
80801d70:	f000 f9ec 	bl	8080214c <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
80801d74:	df00      	svc	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
80801d76:	f000 fb7b 	bl	80802470 <vPortExitCritical>

		taskENTER_CRITICAL();
80801d7a:	f000 fb73 	bl	80802464 <vPortEnterCritical>
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
80801d7e:	687b      	ldr	r3, [r7, #4]
80801d80:	2b00      	cmp	r3, #0
80801d82:	d007      	beq.n	80801d94 <xTaskNotifyWait+0x78>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
80801d84:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801d88:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801d8c:	681b      	ldr	r3, [r3, #0]
80801d8e:	6c9a      	ldr	r2, [r3, #72]	; 0x48
80801d90:	687b      	ldr	r3, [r7, #4]
80801d92:	601a      	str	r2, [r3, #0]

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
80801d94:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801d98:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801d9c:	681b      	ldr	r3, [r3, #0]
80801d9e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
80801da2:	b2db      	uxtb	r3, r3
80801da4:	2b01      	cmp	r3, #1
80801da6:	d102      	bne.n	80801dae <xTaskNotifyWait+0x92>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
80801da8:	2300      	movs	r3, #0
80801daa:	617b      	str	r3, [r7, #20]
80801dac:	e00b      	b.n	80801dc6 <xTaskNotifyWait+0xaa>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
80801dae:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801db2:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801db6:	681b      	ldr	r3, [r3, #0]
80801db8:	6c99      	ldr	r1, [r3, #72]	; 0x48
80801dba:	68ba      	ldr	r2, [r7, #8]
80801dbc:	43d2      	mvns	r2, r2
80801dbe:	400a      	ands	r2, r1
80801dc0:	649a      	str	r2, [r3, #72]	; 0x48
				xReturn = pdTRUE;
80801dc2:	2301      	movs	r3, #1
80801dc4:	617b      	str	r3, [r7, #20]
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
80801dc6:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801dca:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801dce:	681b      	ldr	r3, [r3, #0]
80801dd0:	2200      	movs	r2, #0
80801dd2:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
		}
		taskEXIT_CRITICAL();
80801dd6:	f000 fb4b 	bl	80802470 <vPortExitCritical>

		return xReturn;
80801dda:	697b      	ldr	r3, [r7, #20]
	}
80801ddc:	4618      	mov	r0, r3
80801dde:	3718      	adds	r7, #24
80801de0:	46bd      	mov	sp, r7
80801de2:	bd80      	pop	{r7, pc}

80801de4 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
80801de4:	b580      	push	{r7, lr}
80801de6:	b088      	sub	sp, #32
80801de8:	af00      	add	r7, sp, #0
80801dea:	60f8      	str	r0, [r7, #12]
80801dec:	60b9      	str	r1, [r7, #8]
80801dee:	603b      	str	r3, [r7, #0]
80801df0:	4613      	mov	r3, r2
80801df2:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
80801df4:	2301      	movs	r3, #1
80801df6:	61fb      	str	r3, [r7, #28]
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;
80801df8:	68fb      	ldr	r3, [r7, #12]
80801dfa:	61bb      	str	r3, [r7, #24]

		taskENTER_CRITICAL();
80801dfc:	f000 fb32 	bl	80802464 <vPortEnterCritical>
		{
			if( pulPreviousNotificationValue != NULL )
80801e00:	683b      	ldr	r3, [r7, #0]
80801e02:	2b00      	cmp	r3, #0
80801e04:	d003      	beq.n	80801e0e <xTaskGenericNotify+0x2a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
80801e06:	69bb      	ldr	r3, [r7, #24]
80801e08:	6c9a      	ldr	r2, [r3, #72]	; 0x48
80801e0a:	683b      	ldr	r3, [r7, #0]
80801e0c:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
80801e0e:	69bb      	ldr	r3, [r7, #24]
80801e10:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
80801e14:	75fb      	strb	r3, [r7, #23]

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
80801e16:	69bb      	ldr	r3, [r7, #24]
80801e18:	2202      	movs	r2, #2
80801e1a:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

			switch( eAction )
80801e1e:	79fb      	ldrb	r3, [r7, #7]
80801e20:	2b04      	cmp	r3, #4
80801e22:	d828      	bhi.n	80801e76 <xTaskGenericNotify+0x92>
80801e24:	a201      	add	r2, pc, #4	; (adr r2, 80801e2c <xTaskGenericNotify+0x48>)
80801e26:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
80801e2a:	bf00      	nop
80801e2c:	80801e77 	.word	0x80801e77
80801e30:	80801e41 	.word	0x80801e41
80801e34:	80801e4f 	.word	0x80801e4f
80801e38:	80801e5b 	.word	0x80801e5b
80801e3c:	80801e63 	.word	0x80801e63
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
80801e40:	69bb      	ldr	r3, [r7, #24]
80801e42:	6c9a      	ldr	r2, [r3, #72]	; 0x48
80801e44:	68bb      	ldr	r3, [r7, #8]
80801e46:	431a      	orrs	r2, r3
80801e48:	69bb      	ldr	r3, [r7, #24]
80801e4a:	649a      	str	r2, [r3, #72]	; 0x48
					break;
80801e4c:	e013      	b.n	80801e76 <xTaskGenericNotify+0x92>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
80801e4e:	69bb      	ldr	r3, [r7, #24]
80801e50:	6c9b      	ldr	r3, [r3, #72]	; 0x48
80801e52:	1c5a      	adds	r2, r3, #1
80801e54:	69bb      	ldr	r3, [r7, #24]
80801e56:	649a      	str	r2, [r3, #72]	; 0x48
					break;
80801e58:	e00d      	b.n	80801e76 <xTaskGenericNotify+0x92>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
80801e5a:	69bb      	ldr	r3, [r7, #24]
80801e5c:	68ba      	ldr	r2, [r7, #8]
80801e5e:	649a      	str	r2, [r3, #72]	; 0x48
					break;
80801e60:	e009      	b.n	80801e76 <xTaskGenericNotify+0x92>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80801e62:	7dfb      	ldrb	r3, [r7, #23]
80801e64:	2b02      	cmp	r3, #2
80801e66:	d003      	beq.n	80801e70 <xTaskGenericNotify+0x8c>
					{
						pxTCB->ulNotifiedValue = ulValue;
80801e68:	69bb      	ldr	r3, [r7, #24]
80801e6a:	68ba      	ldr	r2, [r7, #8]
80801e6c:	649a      	str	r2, [r3, #72]	; 0x48
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
80801e6e:	e001      	b.n	80801e74 <xTaskGenericNotify+0x90>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
80801e70:	2300      	movs	r3, #0
80801e72:	61fb      	str	r3, [r7, #28]
					}
					break;
80801e74:	bf00      	nop

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80801e76:	7dfb      	ldrb	r3, [r7, #23]
80801e78:	2b01      	cmp	r3, #1
80801e7a:	d12f      	bne.n	80801edc <xTaskGenericNotify+0xf8>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80801e7c:	69bb      	ldr	r3, [r7, #24]
80801e7e:	3304      	adds	r3, #4
80801e80:	4618      	mov	r0, r3
80801e82:	f7fe f965 	bl	80800150 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
80801e86:	69bb      	ldr	r3, [r7, #24]
80801e88:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801e8a:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801e8e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801e92:	681b      	ldr	r3, [r3, #0]
80801e94:	429a      	cmp	r2, r3
80801e96:	d906      	bls.n	80801ea6 <xTaskGenericNotify+0xc2>
80801e98:	69bb      	ldr	r3, [r7, #24]
80801e9a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801e9c:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801ea0:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801ea4:	601a      	str	r2, [r3, #0]
80801ea6:	69bb      	ldr	r3, [r7, #24]
80801ea8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801eaa:	009b      	lsls	r3, r3, #2
80801eac:	009a      	lsls	r2, r3, #2
80801eae:	4413      	add	r3, r2
80801eb0:	f242 72cc 	movw	r2, #10188	; 0x27cc
80801eb4:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801eb8:	441a      	add	r2, r3
80801eba:	69bb      	ldr	r3, [r7, #24]
80801ebc:	3304      	adds	r3, #4
80801ebe:	4619      	mov	r1, r3
80801ec0:	4610      	mov	r0, r2
80801ec2:	f7fe f8e9 	bl	80800098 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
80801ec6:	69bb      	ldr	r3, [r7, #24]
80801ec8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801eca:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801ece:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801ed2:	681b      	ldr	r3, [r3, #0]
80801ed4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801ed6:	429a      	cmp	r2, r3
80801ed8:	d900      	bls.n	80801edc <xTaskGenericNotify+0xf8>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
80801eda:	df00      	svc	0
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
80801edc:	f000 fac8 	bl	80802470 <vPortExitCritical>

		return xReturn;
80801ee0:	69fb      	ldr	r3, [r7, #28]
	}
80801ee2:	4618      	mov	r0, r3
80801ee4:	3720      	adds	r7, #32
80801ee6:	46bd      	mov	sp, r7
80801ee8:	bd80      	pop	{r7, pc}
80801eea:	bf00      	nop

80801eec <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
80801eec:	b580      	push	{r7, lr}
80801eee:	b088      	sub	sp, #32
80801ef0:	af00      	add	r7, sp, #0
80801ef2:	60f8      	str	r0, [r7, #12]
80801ef4:	60b9      	str	r1, [r7, #8]
80801ef6:	603b      	str	r3, [r7, #0]
80801ef8:	4613      	mov	r3, r2
80801efa:	71fb      	strb	r3, [r7, #7]
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
80801efc:	2301      	movs	r3, #1
80801efe:	61fb      	str	r3, [r7, #28]
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
80801f00:	68fb      	ldr	r3, [r7, #12]
80801f02:	61bb      	str	r3, [r7, #24]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80801f04:	2300      	movs	r3, #0
80801f06:	617b      	str	r3, [r7, #20]
		{
			if( pulPreviousNotificationValue != NULL )
80801f08:	683b      	ldr	r3, [r7, #0]
80801f0a:	2b00      	cmp	r3, #0
80801f0c:	d003      	beq.n	80801f16 <xTaskGenericNotifyFromISR+0x2a>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
80801f0e:	69bb      	ldr	r3, [r7, #24]
80801f10:	6c9a      	ldr	r2, [r3, #72]	; 0x48
80801f12:	683b      	ldr	r3, [r7, #0]
80801f14:	601a      	str	r2, [r3, #0]
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
80801f16:	69bb      	ldr	r3, [r7, #24]
80801f18:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
80801f1c:	74fb      	strb	r3, [r7, #19]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
80801f1e:	69bb      	ldr	r3, [r7, #24]
80801f20:	2202      	movs	r2, #2
80801f22:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

			switch( eAction )
80801f26:	79fb      	ldrb	r3, [r7, #7]
80801f28:	2b04      	cmp	r3, #4
80801f2a:	d828      	bhi.n	80801f7e <xTaskGenericNotifyFromISR+0x92>
80801f2c:	a201      	add	r2, pc, #4	; (adr r2, 80801f34 <xTaskGenericNotifyFromISR+0x48>)
80801f2e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
80801f32:	bf00      	nop
80801f34:	80801f7f 	.word	0x80801f7f
80801f38:	80801f49 	.word	0x80801f49
80801f3c:	80801f57 	.word	0x80801f57
80801f40:	80801f63 	.word	0x80801f63
80801f44:	80801f6b 	.word	0x80801f6b
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
80801f48:	69bb      	ldr	r3, [r7, #24]
80801f4a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
80801f4c:	68bb      	ldr	r3, [r7, #8]
80801f4e:	431a      	orrs	r2, r3
80801f50:	69bb      	ldr	r3, [r7, #24]
80801f52:	649a      	str	r2, [r3, #72]	; 0x48
					break;
80801f54:	e013      	b.n	80801f7e <xTaskGenericNotifyFromISR+0x92>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
80801f56:	69bb      	ldr	r3, [r7, #24]
80801f58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
80801f5a:	1c5a      	adds	r2, r3, #1
80801f5c:	69bb      	ldr	r3, [r7, #24]
80801f5e:	649a      	str	r2, [r3, #72]	; 0x48
					break;
80801f60:	e00d      	b.n	80801f7e <xTaskGenericNotifyFromISR+0x92>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
80801f62:	69bb      	ldr	r3, [r7, #24]
80801f64:	68ba      	ldr	r2, [r7, #8]
80801f66:	649a      	str	r2, [r3, #72]	; 0x48
					break;
80801f68:	e009      	b.n	80801f7e <xTaskGenericNotifyFromISR+0x92>

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
80801f6a:	7cfb      	ldrb	r3, [r7, #19]
80801f6c:	2b02      	cmp	r3, #2
80801f6e:	d003      	beq.n	80801f78 <xTaskGenericNotifyFromISR+0x8c>
					{
						pxTCB->ulNotifiedValue = ulValue;
80801f70:	69bb      	ldr	r3, [r7, #24]
80801f72:	68ba      	ldr	r2, [r7, #8]
80801f74:	649a      	str	r2, [r3, #72]	; 0x48
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
					}
					break;
80801f76:	e001      	b.n	80801f7c <xTaskGenericNotifyFromISR+0x90>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
80801f78:	2300      	movs	r3, #0
80801f7a:	61fb      	str	r3, [r7, #28]
					}
					break;
80801f7c:	bf00      	nop

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80801f7e:	7cfb      	ldrb	r3, [r7, #19]
80801f80:	2b01      	cmp	r3, #1
80801f82:	d14c      	bne.n	8080201e <xTaskGenericNotifyFromISR+0x132>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
80801f84:	f642 03c8 	movw	r3, #10440	; 0x28c8
80801f88:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801f8c:	681b      	ldr	r3, [r3, #0]
80801f8e:	2b00      	cmp	r3, #0
80801f90:	d125      	bne.n	80801fde <xTaskGenericNotifyFromISR+0xf2>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80801f92:	69bb      	ldr	r3, [r7, #24]
80801f94:	3304      	adds	r3, #4
80801f96:	4618      	mov	r0, r3
80801f98:	f7fe f8da 	bl	80800150 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80801f9c:	69bb      	ldr	r3, [r7, #24]
80801f9e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801fa0:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801fa4:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801fa8:	681b      	ldr	r3, [r3, #0]
80801faa:	429a      	cmp	r2, r3
80801fac:	d906      	bls.n	80801fbc <xTaskGenericNotifyFromISR+0xd0>
80801fae:	69bb      	ldr	r3, [r7, #24]
80801fb0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801fb2:	f642 03a8 	movw	r3, #10408	; 0x28a8
80801fb6:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801fba:	601a      	str	r2, [r3, #0]
80801fbc:	69bb      	ldr	r3, [r7, #24]
80801fbe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80801fc0:	009b      	lsls	r3, r3, #2
80801fc2:	009a      	lsls	r2, r3, #2
80801fc4:	4413      	add	r3, r2
80801fc6:	f242 72cc 	movw	r2, #10188	; 0x27cc
80801fca:	f2c8 0280 	movt	r2, #32896	; 0x8080
80801fce:	441a      	add	r2, r3
80801fd0:	69bb      	ldr	r3, [r7, #24]
80801fd2:	3304      	adds	r3, #4
80801fd4:	4619      	mov	r1, r3
80801fd6:	4610      	mov	r0, r2
80801fd8:	f7fe f85e 	bl	80800098 <vListInsertEnd>
80801fdc:	e008      	b.n	80801ff0 <xTaskGenericNotifyFromISR+0x104>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
80801fde:	69bb      	ldr	r3, [r7, #24]
80801fe0:	3318      	adds	r3, #24
80801fe2:	4619      	mov	r1, r3
80801fe4:	f642 0060 	movw	r0, #10336	; 0x2860
80801fe8:	f2c8 0080 	movt	r0, #32896	; 0x8080
80801fec:	f7fe f854 	bl	80800098 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
80801ff0:	69bb      	ldr	r3, [r7, #24]
80801ff2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80801ff4:	f242 73c8 	movw	r3, #10184	; 0x27c8
80801ff8:	f2c8 0380 	movt	r3, #32896	; 0x8080
80801ffc:	681b      	ldr	r3, [r3, #0]
80801ffe:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80802000:	429a      	cmp	r2, r3
80802002:	d90c      	bls.n	8080201e <xTaskGenericNotifyFromISR+0x132>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
80802004:	6abb      	ldr	r3, [r7, #40]	; 0x28
80802006:	2b00      	cmp	r3, #0
80802008:	d003      	beq.n	80802012 <xTaskGenericNotifyFromISR+0x126>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
8080200a:	6abb      	ldr	r3, [r7, #40]	; 0x28
8080200c:	2201      	movs	r2, #1
8080200e:	601a      	str	r2, [r3, #0]
80802010:	e005      	b.n	8080201e <xTaskGenericNotifyFromISR+0x132>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter to an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
80802012:	f642 03b4 	movw	r3, #10420	; 0x28b4
80802016:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080201a:	2201      	movs	r2, #1
8080201c:	601a      	str	r2, [r3, #0]
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
8080201e:	69fb      	ldr	r3, [r7, #28]
	}
80802020:	4618      	mov	r0, r3
80802022:	3720      	adds	r7, #32
80802024:	46bd      	mov	sp, r7
80802026:	bd80      	pop	{r7, pc}

80802028 <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
80802028:	b580      	push	{r7, lr}
8080202a:	b086      	sub	sp, #24
8080202c:	af00      	add	r7, sp, #0
8080202e:	6078      	str	r0, [r7, #4]
80802030:	6039      	str	r1, [r7, #0]
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = ( TCB_t * ) xTaskToNotify;
80802032:	687b      	ldr	r3, [r7, #4]
80802034:	617b      	str	r3, [r7, #20]

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
80802036:	2300      	movs	r3, #0
80802038:	613b      	str	r3, [r7, #16]
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
8080203a:	697b      	ldr	r3, [r7, #20]
8080203c:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
80802040:	73fb      	strb	r3, [r7, #15]
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
80802042:	697b      	ldr	r3, [r7, #20]
80802044:	2202      	movs	r2, #2
80802046:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
8080204a:	697b      	ldr	r3, [r7, #20]
8080204c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
8080204e:	1c5a      	adds	r2, r3, #1
80802050:	697b      	ldr	r3, [r7, #20]
80802052:	649a      	str	r2, [r3, #72]	; 0x48

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
80802054:	7bfb      	ldrb	r3, [r7, #15]
80802056:	2b01      	cmp	r3, #1
80802058:	d14c      	bne.n	808020f4 <vTaskNotifyGiveFromISR+0xcc>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
8080205a:	f642 03c8 	movw	r3, #10440	; 0x28c8
8080205e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802062:	681b      	ldr	r3, [r3, #0]
80802064:	2b00      	cmp	r3, #0
80802066:	d125      	bne.n	808020b4 <vTaskNotifyGiveFromISR+0x8c>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
80802068:	697b      	ldr	r3, [r7, #20]
8080206a:	3304      	adds	r3, #4
8080206c:	4618      	mov	r0, r3
8080206e:	f7fe f86f 	bl	80800150 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
80802072:	697b      	ldr	r3, [r7, #20]
80802074:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80802076:	f642 03a8 	movw	r3, #10408	; 0x28a8
8080207a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080207e:	681b      	ldr	r3, [r3, #0]
80802080:	429a      	cmp	r2, r3
80802082:	d906      	bls.n	80802092 <vTaskNotifyGiveFromISR+0x6a>
80802084:	697b      	ldr	r3, [r7, #20]
80802086:	6ada      	ldr	r2, [r3, #44]	; 0x2c
80802088:	f642 03a8 	movw	r3, #10408	; 0x28a8
8080208c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802090:	601a      	str	r2, [r3, #0]
80802092:	697b      	ldr	r3, [r7, #20]
80802094:	6adb      	ldr	r3, [r3, #44]	; 0x2c
80802096:	009b      	lsls	r3, r3, #2
80802098:	009a      	lsls	r2, r3, #2
8080209a:	4413      	add	r3, r2
8080209c:	f242 72cc 	movw	r2, #10188	; 0x27cc
808020a0:	f2c8 0280 	movt	r2, #32896	; 0x8080
808020a4:	441a      	add	r2, r3
808020a6:	697b      	ldr	r3, [r7, #20]
808020a8:	3304      	adds	r3, #4
808020aa:	4619      	mov	r1, r3
808020ac:	4610      	mov	r0, r2
808020ae:	f7fd fff3 	bl	80800098 <vListInsertEnd>
808020b2:	e008      	b.n	808020c6 <vTaskNotifyGiveFromISR+0x9e>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
808020b4:	697b      	ldr	r3, [r7, #20]
808020b6:	3318      	adds	r3, #24
808020b8:	4619      	mov	r1, r3
808020ba:	f642 0060 	movw	r0, #10336	; 0x2860
808020be:	f2c8 0080 	movt	r0, #32896	; 0x8080
808020c2:	f7fd ffe9 	bl	80800098 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
808020c6:	697b      	ldr	r3, [r7, #20]
808020c8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
808020ca:	f242 73c8 	movw	r3, #10184	; 0x27c8
808020ce:	f2c8 0380 	movt	r3, #32896	; 0x8080
808020d2:	681b      	ldr	r3, [r3, #0]
808020d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
808020d6:	429a      	cmp	r2, r3
808020d8:	d90c      	bls.n	808020f4 <vTaskNotifyGiveFromISR+0xcc>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
808020da:	683b      	ldr	r3, [r7, #0]
808020dc:	2b00      	cmp	r3, #0
808020de:	d003      	beq.n	808020e8 <vTaskNotifyGiveFromISR+0xc0>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
808020e0:	683b      	ldr	r3, [r7, #0]
808020e2:	2201      	movs	r2, #1
808020e4:	601a      	str	r2, [r3, #0]
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
808020e6:	e005      	b.n	808020f4 <vTaskNotifyGiveFromISR+0xcc>
					else
					{
						/* Mark that a yield is pending in case the user is not
						using the "xHigherPriorityTaskWoken" parameter in an ISR
						safe FreeRTOS function. */
						xYieldPending = pdTRUE;
808020e8:	f642 03b4 	movw	r3, #10420	; 0x28b4
808020ec:	f2c8 0380 	movt	r3, #32896	; 0x8080
808020f0:	2201      	movs	r2, #1
808020f2:	601a      	str	r2, [r3, #0]
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
808020f4:	bf00      	nop
808020f6:	3718      	adds	r7, #24
808020f8:	46bd      	mov	sp, r7
808020fa:	bd80      	pop	{r7, pc}

808020fc <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
808020fc:	b580      	push	{r7, lr}
808020fe:	b084      	sub	sp, #16
80802100:	af00      	add	r7, sp, #0
80802102:	6078      	str	r0, [r7, #4]
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
80802104:	687b      	ldr	r3, [r7, #4]
80802106:	2b00      	cmp	r3, #0
80802108:	d105      	bne.n	80802116 <xTaskNotifyStateClear+0x1a>
8080210a:	f242 73c8 	movw	r3, #10184	; 0x27c8
8080210e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802112:	681b      	ldr	r3, [r3, #0]
80802114:	e000      	b.n	80802118 <xTaskNotifyStateClear+0x1c>
80802116:	687b      	ldr	r3, [r7, #4]
80802118:	60bb      	str	r3, [r7, #8]

		taskENTER_CRITICAL();
8080211a:	f000 f9a3 	bl	80802464 <vPortEnterCritical>
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
8080211e:	68bb      	ldr	r3, [r7, #8]
80802120:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
80802124:	b2db      	uxtb	r3, r3
80802126:	2b02      	cmp	r3, #2
80802128:	d106      	bne.n	80802138 <xTaskNotifyStateClear+0x3c>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
8080212a:	68bb      	ldr	r3, [r7, #8]
8080212c:	2200      	movs	r2, #0
8080212e:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
				xReturn = pdPASS;
80802132:	2301      	movs	r3, #1
80802134:	60fb      	str	r3, [r7, #12]
80802136:	e001      	b.n	8080213c <xTaskNotifyStateClear+0x40>
			}
			else
			{
				xReturn = pdFAIL;
80802138:	2300      	movs	r3, #0
8080213a:	60fb      	str	r3, [r7, #12]
			}
		}
		taskEXIT_CRITICAL();
8080213c:	f000 f998 	bl	80802470 <vPortExitCritical>

		return xReturn;
80802140:	68fb      	ldr	r3, [r7, #12]
	}
80802142:	4618      	mov	r0, r3
80802144:	3710      	adds	r7, #16
80802146:	46bd      	mov	sp, r7
80802148:	bd80      	pop	{r7, pc}
8080214a:	bf00      	nop

8080214c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
8080214c:	b580      	push	{r7, lr}
8080214e:	b084      	sub	sp, #16
80802150:	af00      	add	r7, sp, #0
80802152:	6078      	str	r0, [r7, #4]
80802154:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
80802156:	f642 03a4 	movw	r3, #10404	; 0x28a4
8080215a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080215e:	681b      	ldr	r3, [r3, #0]
80802160:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
80802162:	f242 73c8 	movw	r3, #10184	; 0x27c8
80802166:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080216a:	681b      	ldr	r3, [r3, #0]
8080216c:	3304      	adds	r3, #4
8080216e:	4618      	mov	r0, r3
80802170:	f7fd ffee 	bl	80800150 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
80802174:	687b      	ldr	r3, [r7, #4]
80802176:	f1b3 3fff 	cmp.w	r3, #4294967295
8080217a:	d110      	bne.n	8080219e <prvAddCurrentTaskToDelayedList+0x52>
8080217c:	683b      	ldr	r3, [r7, #0]
8080217e:	2b00      	cmp	r3, #0
80802180:	d00d      	beq.n	8080219e <prvAddCurrentTaskToDelayedList+0x52>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
80802182:	f242 73c8 	movw	r3, #10184	; 0x27c8
80802186:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080218a:	681b      	ldr	r3, [r3, #0]
8080218c:	3304      	adds	r3, #4
8080218e:	4619      	mov	r1, r3
80802190:	f642 008c 	movw	r0, #10380	; 0x288c
80802194:	f2c8 0080 	movt	r0, #32896	; 0x8080
80802198:	f7fd ff7e 	bl	80800098 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
8080219c:	e03b      	b.n	80802216 <prvAddCurrentTaskToDelayedList+0xca>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
8080219e:	68fa      	ldr	r2, [r7, #12]
808021a0:	687b      	ldr	r3, [r7, #4]
808021a2:	4413      	add	r3, r2
808021a4:	60bb      	str	r3, [r7, #8]

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
808021a6:	f242 73c8 	movw	r3, #10184	; 0x27c8
808021aa:	f2c8 0380 	movt	r3, #32896	; 0x8080
808021ae:	681b      	ldr	r3, [r3, #0]
808021b0:	68ba      	ldr	r2, [r7, #8]
808021b2:	605a      	str	r2, [r3, #4]

			if( xTimeToWake < xConstTickCount )
808021b4:	68ba      	ldr	r2, [r7, #8]
808021b6:	68fb      	ldr	r3, [r7, #12]
808021b8:	429a      	cmp	r2, r3
808021ba:	d20f      	bcs.n	808021dc <prvAddCurrentTaskToDelayedList+0x90>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
808021bc:	f642 035c 	movw	r3, #10332	; 0x285c
808021c0:	f2c8 0380 	movt	r3, #32896	; 0x8080
808021c4:	681a      	ldr	r2, [r3, #0]
808021c6:	f242 73c8 	movw	r3, #10184	; 0x27c8
808021ca:	f2c8 0380 	movt	r3, #32896	; 0x8080
808021ce:	681b      	ldr	r3, [r3, #0]
808021d0:	3304      	adds	r3, #4
808021d2:	4619      	mov	r1, r3
808021d4:	4610      	mov	r0, r2
808021d6:	f7fd ff83 	bl	808000e0 <vListInsert>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
808021da:	e01c      	b.n	80802216 <prvAddCurrentTaskToDelayedList+0xca>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
808021dc:	f642 0358 	movw	r3, #10328	; 0x2858
808021e0:	f2c8 0380 	movt	r3, #32896	; 0x8080
808021e4:	681a      	ldr	r2, [r3, #0]
808021e6:	f242 73c8 	movw	r3, #10184	; 0x27c8
808021ea:	f2c8 0380 	movt	r3, #32896	; 0x8080
808021ee:	681b      	ldr	r3, [r3, #0]
808021f0:	3304      	adds	r3, #4
808021f2:	4619      	mov	r1, r3
808021f4:	4610      	mov	r0, r2
808021f6:	f7fd ff73 	bl	808000e0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
808021fa:	f642 03c0 	movw	r3, #10432	; 0x28c0
808021fe:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802202:	681b      	ldr	r3, [r3, #0]
80802204:	68ba      	ldr	r2, [r7, #8]
80802206:	429a      	cmp	r2, r3
80802208:	d205      	bcs.n	80802216 <prvAddCurrentTaskToDelayedList+0xca>
				{
					xNextTaskUnblockTime = xTimeToWake;
8080220a:	f642 03c0 	movw	r3, #10432	; 0x28c0
8080220e:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802212:	68ba      	ldr	r2, [r7, #8]
80802214:	601a      	str	r2, [r3, #0]

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
80802216:	bf00      	nop
80802218:	3710      	adds	r7, #16
8080221a:	46bd      	mov	sp, r7
8080221c:	bd80      	pop	{r7, pc}
8080221e:	bf00      	nop

80802220 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
80802220:	b580      	push	{r7, lr}
80802222:	b088      	sub	sp, #32
80802224:	af00      	add	r7, sp, #0
80802226:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
80802228:	2300      	movs	r3, #0
8080222a:	617b      	str	r3, [r7, #20]

	vTaskSuspendAll();
8080222c:	f7ff f84a 	bl	808012c4 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
80802230:	f647 03dc 	movw	r3, #30940	; 0x78dc
80802234:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802238:	681b      	ldr	r3, [r3, #0]
8080223a:	2b00      	cmp	r3, #0
8080223c:	d107      	bne.n	8080224e <pvPortMalloc+0x2e>
		{
			prvHeapInit();
8080223e:	f000 f8dd 	bl	808023fc <prvHeapInit>
			xHeapHasBeenInitialised = pdTRUE;
80802242:	f647 03dc 	movw	r3, #30940	; 0x78dc
80802246:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080224a:	2201      	movs	r2, #1
8080224c:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
8080224e:	687b      	ldr	r3, [r7, #4]
80802250:	2b00      	cmp	r3, #0
80802252:	d00e      	beq.n	80802272 <pvPortMalloc+0x52>
		{
			xWantedSize += heapSTRUCT_SIZE;
80802254:	2308      	movs	r3, #8
80802256:	461a      	mov	r2, r3
80802258:	687b      	ldr	r3, [r7, #4]
8080225a:	4413      	add	r3, r2
8080225c:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0 )
8080225e:	687b      	ldr	r3, [r7, #4]
80802260:	f003 0307 	and.w	r3, r3, #7
80802264:	2b00      	cmp	r3, #0
80802266:	d004      	beq.n	80802272 <pvPortMalloc+0x52>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
80802268:	687b      	ldr	r3, [r7, #4]
8080226a:	f023 0307 	bic.w	r3, r3, #7
8080226e:	3308      	adds	r3, #8
80802270:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
80802272:	687b      	ldr	r3, [r7, #4]
80802274:	2b00      	cmp	r3, #0
80802276:	d069      	beq.n	8080234c <pvPortMalloc+0x12c>
80802278:	687b      	ldr	r3, [r7, #4]
8080227a:	f644 72f7 	movw	r2, #20471	; 0x4ff7
8080227e:	4293      	cmp	r3, r2
80802280:	d864      	bhi.n	8080234c <pvPortMalloc+0x12c>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
80802282:	f647 03cc 	movw	r3, #30924	; 0x78cc
80802286:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080228a:	61bb      	str	r3, [r7, #24]
			pxBlock = xStart.pxNextFreeBlock;
8080228c:	f647 03cc 	movw	r3, #30924	; 0x78cc
80802290:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802294:	681b      	ldr	r3, [r3, #0]
80802296:	61fb      	str	r3, [r7, #28]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
80802298:	e004      	b.n	808022a4 <pvPortMalloc+0x84>
			{
				pxPreviousBlock = pxBlock;
8080229a:	69fb      	ldr	r3, [r7, #28]
8080229c:	61bb      	str	r3, [r7, #24]
				pxBlock = pxBlock->pxNextFreeBlock;
8080229e:	69fb      	ldr	r3, [r7, #28]
808022a0:	681b      	ldr	r3, [r3, #0]
808022a2:	61fb      	str	r3, [r7, #28]
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
808022a4:	69fb      	ldr	r3, [r7, #28]
808022a6:	685a      	ldr	r2, [r3, #4]
808022a8:	687b      	ldr	r3, [r7, #4]
808022aa:	429a      	cmp	r2, r3
808022ac:	d203      	bcs.n	808022b6 <pvPortMalloc+0x96>
808022ae:	69fb      	ldr	r3, [r7, #28]
808022b0:	681b      	ldr	r3, [r3, #0]
808022b2:	2b00      	cmp	r3, #0
808022b4:	d1f1      	bne.n	8080229a <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
808022b6:	69fa      	ldr	r2, [r7, #28]
808022b8:	f647 03d4 	movw	r3, #30932	; 0x78d4
808022bc:	f2c8 0380 	movt	r3, #32896	; 0x8080
808022c0:	429a      	cmp	r2, r3
808022c2:	d043      	beq.n	8080234c <pvPortMalloc+0x12c>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
808022c4:	69bb      	ldr	r3, [r7, #24]
808022c6:	681b      	ldr	r3, [r3, #0]
808022c8:	2208      	movs	r2, #8
808022ca:	4413      	add	r3, r2
808022cc:	617b      	str	r3, [r7, #20]

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
808022ce:	69fb      	ldr	r3, [r7, #28]
808022d0:	681a      	ldr	r2, [r3, #0]
808022d2:	69bb      	ldr	r3, [r7, #24]
808022d4:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
808022d6:	69fb      	ldr	r3, [r7, #28]
808022d8:	685a      	ldr	r2, [r3, #4]
808022da:	687b      	ldr	r3, [r7, #4]
808022dc:	1ad3      	subs	r3, r2, r3
808022de:	2208      	movs	r2, #8
808022e0:	0052      	lsls	r2, r2, #1
808022e2:	4293      	cmp	r3, r2
808022e4:	d925      	bls.n	80802332 <pvPortMalloc+0x112>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
808022e6:	69fa      	ldr	r2, [r7, #28]
808022e8:	687b      	ldr	r3, [r7, #4]
808022ea:	4413      	add	r3, r2
808022ec:	60fb      	str	r3, [r7, #12]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
808022ee:	69fb      	ldr	r3, [r7, #28]
808022f0:	685a      	ldr	r2, [r3, #4]
808022f2:	687b      	ldr	r3, [r7, #4]
808022f4:	1ad2      	subs	r2, r2, r3
808022f6:	68fb      	ldr	r3, [r7, #12]
808022f8:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
808022fa:	69fb      	ldr	r3, [r7, #28]
808022fc:	687a      	ldr	r2, [r7, #4]
808022fe:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
80802300:	68fb      	ldr	r3, [r7, #12]
80802302:	685b      	ldr	r3, [r3, #4]
80802304:	60bb      	str	r3, [r7, #8]
80802306:	f647 03cc 	movw	r3, #30924	; 0x78cc
8080230a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080230e:	613b      	str	r3, [r7, #16]
80802310:	e002      	b.n	80802318 <pvPortMalloc+0xf8>
80802312:	693b      	ldr	r3, [r7, #16]
80802314:	681b      	ldr	r3, [r3, #0]
80802316:	613b      	str	r3, [r7, #16]
80802318:	693b      	ldr	r3, [r7, #16]
8080231a:	681b      	ldr	r3, [r3, #0]
8080231c:	685a      	ldr	r2, [r3, #4]
8080231e:	68bb      	ldr	r3, [r7, #8]
80802320:	429a      	cmp	r2, r3
80802322:	d3f6      	bcc.n	80802312 <pvPortMalloc+0xf2>
80802324:	693b      	ldr	r3, [r7, #16]
80802326:	681a      	ldr	r2, [r3, #0]
80802328:	68fb      	ldr	r3, [r7, #12]
8080232a:	601a      	str	r2, [r3, #0]
8080232c:	693b      	ldr	r3, [r7, #16]
8080232e:	68fa      	ldr	r2, [r7, #12]
80802330:	601a      	str	r2, [r3, #0]
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
80802332:	f242 73c4 	movw	r3, #10180	; 0x27c4
80802336:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080233a:	681a      	ldr	r2, [r3, #0]
8080233c:	69fb      	ldr	r3, [r7, #28]
8080233e:	685b      	ldr	r3, [r3, #4]
80802340:	1ad2      	subs	r2, r2, r3
80802342:	f242 73c4 	movw	r3, #10180	; 0x27c4
80802346:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080234a:	601a      	str	r2, [r3, #0]
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
8080234c:	f7fe ffcc 	bl	808012e8 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
80802350:	697b      	ldr	r3, [r7, #20]
}
80802352:	4618      	mov	r0, r3
80802354:	3720      	adds	r7, #32
80802356:	46bd      	mov	sp, r7
80802358:	bd80      	pop	{r7, pc}
8080235a:	bf00      	nop

8080235c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
8080235c:	b580      	push	{r7, lr}
8080235e:	b086      	sub	sp, #24
80802360:	af00      	add	r7, sp, #0
80802362:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
80802364:	687b      	ldr	r3, [r7, #4]
80802366:	613b      	str	r3, [r7, #16]
BlockLink_t *pxLink;

	if( pv != NULL )
80802368:	687b      	ldr	r3, [r7, #4]
8080236a:	2b00      	cmp	r3, #0
8080236c:	d030      	beq.n	808023d0 <vPortFree+0x74>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
8080236e:	2308      	movs	r3, #8
80802370:	425b      	negs	r3, r3
80802372:	693a      	ldr	r2, [r7, #16]
80802374:	4413      	add	r3, r2
80802376:	613b      	str	r3, [r7, #16]

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;
80802378:	693b      	ldr	r3, [r7, #16]
8080237a:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
8080237c:	f7fe ffa2 	bl	808012c4 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
80802380:	68fb      	ldr	r3, [r7, #12]
80802382:	685b      	ldr	r3, [r3, #4]
80802384:	60bb      	str	r3, [r7, #8]
80802386:	f647 03cc 	movw	r3, #30924	; 0x78cc
8080238a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080238e:	617b      	str	r3, [r7, #20]
80802390:	e002      	b.n	80802398 <vPortFree+0x3c>
80802392:	697b      	ldr	r3, [r7, #20]
80802394:	681b      	ldr	r3, [r3, #0]
80802396:	617b      	str	r3, [r7, #20]
80802398:	697b      	ldr	r3, [r7, #20]
8080239a:	681b      	ldr	r3, [r3, #0]
8080239c:	685a      	ldr	r2, [r3, #4]
8080239e:	68bb      	ldr	r3, [r7, #8]
808023a0:	429a      	cmp	r2, r3
808023a2:	d3f6      	bcc.n	80802392 <vPortFree+0x36>
808023a4:	697b      	ldr	r3, [r7, #20]
808023a6:	681a      	ldr	r2, [r3, #0]
808023a8:	68fb      	ldr	r3, [r7, #12]
808023aa:	601a      	str	r2, [r3, #0]
808023ac:	697b      	ldr	r3, [r7, #20]
808023ae:	68fa      	ldr	r2, [r7, #12]
808023b0:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
808023b2:	68fb      	ldr	r3, [r7, #12]
808023b4:	685a      	ldr	r2, [r3, #4]
808023b6:	f242 73c4 	movw	r3, #10180	; 0x27c4
808023ba:	f2c8 0380 	movt	r3, #32896	; 0x8080
808023be:	681b      	ldr	r3, [r3, #0]
808023c0:	441a      	add	r2, r3
808023c2:	f242 73c4 	movw	r3, #10180	; 0x27c4
808023c6:	f2c8 0380 	movt	r3, #32896	; 0x8080
808023ca:	601a      	str	r2, [r3, #0]
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
808023cc:	f7fe ff8c 	bl	808012e8 <xTaskResumeAll>
	}
}
808023d0:	bf00      	nop
808023d2:	3718      	adds	r7, #24
808023d4:	46bd      	mov	sp, r7
808023d6:	bd80      	pop	{r7, pc}

808023d8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
808023d8:	b480      	push	{r7}
808023da:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
808023dc:	f242 73c4 	movw	r3, #10180	; 0x27c4
808023e0:	f2c8 0380 	movt	r3, #32896	; 0x8080
808023e4:	681b      	ldr	r3, [r3, #0]
}
808023e6:	4618      	mov	r0, r3
808023e8:	46bd      	mov	sp, r7
808023ea:	bc80      	pop	{r7}
808023ec:	4770      	bx	lr
808023ee:	bf00      	nop

808023f0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
808023f0:	b480      	push	{r7}
808023f2:	af00      	add	r7, sp, #0
	/* This just exists to keep the linker quiet. */
}
808023f4:	bf00      	nop
808023f6:	46bd      	mov	sp, r7
808023f8:	bc80      	pop	{r7}
808023fa:	4770      	bx	lr

808023fc <prvHeapInit>:
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
808023fc:	b480      	push	{r7}
808023fe:	b083      	sub	sp, #12
80802400:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;

	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
80802402:	f642 03d4 	movw	r3, #10452	; 0x28d4
80802406:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080240a:	f023 0307 	bic.w	r3, r3, #7
8080240e:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
80802410:	f647 03cc 	movw	r3, #30924	; 0x78cc
80802414:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802418:	687a      	ldr	r2, [r7, #4]
8080241a:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
8080241c:	f647 03cc 	movw	r3, #30924	; 0x78cc
80802420:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802424:	2200      	movs	r2, #0
80802426:	605a      	str	r2, [r3, #4]

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
80802428:	f647 03d4 	movw	r3, #30932	; 0x78d4
8080242c:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802430:	f644 72f8 	movw	r2, #20472	; 0x4ff8
80802434:	605a      	str	r2, [r3, #4]
	xEnd.pxNextFreeBlock = NULL;
80802436:	f647 03d4 	movw	r3, #30932	; 0x78d4
8080243a:	f2c8 0380 	movt	r3, #32896	; 0x8080
8080243e:	2200      	movs	r2, #0
80802440:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
80802442:	687b      	ldr	r3, [r7, #4]
80802444:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
80802446:	683b      	ldr	r3, [r7, #0]
80802448:	f644 72f8 	movw	r2, #20472	; 0x4ff8
8080244c:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
8080244e:	683a      	ldr	r2, [r7, #0]
80802450:	f647 03d4 	movw	r3, #30932	; 0x78d4
80802454:	f2c8 0380 	movt	r3, #32896	; 0x8080
80802458:	6013      	str	r3, [r2, #0]
}
8080245a:	bf00      	nop
8080245c:	370c      	adds	r7, #12
8080245e:	46bd      	mov	sp, r7
80802460:	bc80      	pop	{r7}
80802462:	4770      	bx	lr

80802464 <vPortEnterCritical>:
/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"

void vPortEnterCritical( void )
{
80802464:	b480      	push	{r7}
80802466:	af00      	add	r7, sp, #0

}
80802468:	bf00      	nop
8080246a:	46bd      	mov	sp, r7
8080246c:	bc80      	pop	{r7}
8080246e:	4770      	bx	lr

80802470 <vPortExitCritical>:

void vPortExitCritical( void )
{
80802470:	b480      	push	{r7}
80802472:	af00      	add	r7, sp, #0

}
80802474:	bf00      	nop
80802476:	46bd      	mov	sp, r7
80802478:	bc80      	pop	{r7}
8080247a:	4770      	bx	lr

8080247c <xPortStartScheduler>:

BaseType_t xPortStartScheduler( void )
{
8080247c:	b480      	push	{r7}
8080247e:	af00      	add	r7, sp, #0
    return 0;
80802480:	2300      	movs	r3, #0
}
80802482:	4618      	mov	r0, r3
80802484:	46bd      	mov	sp, r7
80802486:	bc80      	pop	{r7}
80802488:	4770      	bx	lr
8080248a:	bf00      	nop

8080248c <vPortEndScheduler>:

void vPortEndScheduler( void )
{
8080248c:	b480      	push	{r7}
8080248e:	af00      	add	r7, sp, #0

}
80802490:	bf00      	nop
80802492:	46bd      	mov	sp, r7
80802494:	bc80      	pop	{r7}
80802496:	4770      	bx	lr

80802498 <pxPortInitialiseStack>:

StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
80802498:	b480      	push	{r7}
8080249a:	b085      	sub	sp, #20
8080249c:	af00      	add	r7, sp, #0
8080249e:	60f8      	str	r0, [r7, #12]
808024a0:	60b9      	str	r1, [r7, #8]
808024a2:	607a      	str	r2, [r7, #4]
    return 0;
808024a4:	2300      	movs	r3, #0
}
808024a6:	4618      	mov	r0, r3
808024a8:	3714      	adds	r7, #20
808024aa:	46bd      	mov	sp, r7
808024ac:	bc80      	pop	{r7}
808024ae:	4770      	bx	lr

808024b0 <kputc>:
#include "task.h"

/* Includes for functions to peripherals' drivers: */

void kputc(char c)
{
808024b0:	b480      	push	{r7}
808024b2:	b085      	sub	sp, #20
808024b4:	af00      	add	r7, sp, #0
808024b6:	4603      	mov	r3, r0
808024b8:	71fb      	strb	r3, [r7, #7]
    volatile unsigned int *lsr = (unsigned int *) 0x48020014;
808024ba:	2314      	movs	r3, #20
808024bc:	f6c4 0302 	movt	r3, #18434	; 0x4802
808024c0:	60fb      	str	r3, [r7, #12]
    volatile unsigned int *thr = (unsigned int *) 0x48020000;
808024c2:	2300      	movs	r3, #0
808024c4:	f6c4 0302 	movt	r3, #18434	; 0x4802
808024c8:	60bb      	str	r3, [r7, #8]

    if (c == '\n') {
808024ca:	79fb      	ldrb	r3, [r7, #7]
808024cc:	2b0a      	cmp	r3, #10
808024ce:	d109      	bne.n	808024e4 <kputc+0x34>
        while (!(*lsr & 0x20));
808024d0:	bf00      	nop
808024d2:	68fb      	ldr	r3, [r7, #12]
808024d4:	681b      	ldr	r3, [r3, #0]
808024d6:	f003 0320 	and.w	r3, r3, #32
808024da:	2b00      	cmp	r3, #0
808024dc:	d0f9      	beq.n	808024d2 <kputc+0x22>
        *thr = '\r';
808024de:	68bb      	ldr	r3, [r7, #8]
808024e0:	220d      	movs	r2, #13
808024e2:	601a      	str	r2, [r3, #0]
    }

    while (!(*lsr & 0x20));
808024e4:	bf00      	nop
808024e6:	68fb      	ldr	r3, [r7, #12]
808024e8:	681b      	ldr	r3, [r3, #0]
808024ea:	f003 0320 	and.w	r3, r3, #32
808024ee:	2b00      	cmp	r3, #0
808024f0:	d0f9      	beq.n	808024e6 <kputc+0x36>
    *thr = c;
808024f2:	79fa      	ldrb	r2, [r7, #7]
808024f4:	68bb      	ldr	r3, [r7, #8]
808024f6:	601a      	str	r2, [r3, #0]
}
808024f8:	bf00      	nop
808024fa:	3714      	adds	r7, #20
808024fc:	46bd      	mov	sp, r7
808024fe:	bc80      	pop	{r7}
80802500:	4770      	bx	lr
80802502:	bf00      	nop

80802504 <kputhex>:

void kputhex(unsigned int value, int digits)
{
80802504:	b580      	push	{r7, lr}
80802506:	b084      	sub	sp, #16
80802508:	af00      	add	r7, sp, #0
8080250a:	6078      	str	r0, [r7, #4]
8080250c:	6039      	str	r1, [r7, #0]
    while (digits-- > 0) {
8080250e:	e016      	b.n	8080253e <kputhex+0x3a>
        unsigned int tmp = (value >> (4 * digits)) & 0xf;
80802510:	683b      	ldr	r3, [r7, #0]
80802512:	009b      	lsls	r3, r3, #2
80802514:	687a      	ldr	r2, [r7, #4]
80802516:	fa22 f303 	lsr.w	r3, r2, r3
8080251a:	f003 030f 	and.w	r3, r3, #15
8080251e:	60fb      	str	r3, [r7, #12]
        kputc(tmp > 9 ? tmp - 10 + 'a' : tmp + '0');
80802520:	68fb      	ldr	r3, [r7, #12]
80802522:	2b09      	cmp	r3, #9
80802524:	d904      	bls.n	80802530 <kputhex+0x2c>
80802526:	68fb      	ldr	r3, [r7, #12]
80802528:	b2db      	uxtb	r3, r3
8080252a:	3357      	adds	r3, #87	; 0x57
8080252c:	b2db      	uxtb	r3, r3
8080252e:	e003      	b.n	80802538 <kputhex+0x34>
80802530:	68fb      	ldr	r3, [r7, #12]
80802532:	b2db      	uxtb	r3, r3
80802534:	3330      	adds	r3, #48	; 0x30
80802536:	b2db      	uxtb	r3, r3
80802538:	4618      	mov	r0, r3
8080253a:	f7ff ffb9 	bl	808024b0 <kputc>
    *thr = c;
}

void kputhex(unsigned int value, int digits)
{
    while (digits-- > 0) {
8080253e:	683b      	ldr	r3, [r7, #0]
80802540:	1e5a      	subs	r2, r3, #1
80802542:	603a      	str	r2, [r7, #0]
80802544:	2b00      	cmp	r3, #0
80802546:	dce3      	bgt.n	80802510 <kputhex+0xc>
        unsigned int tmp = (value >> (4 * digits)) & 0xf;
        kputc(tmp > 9 ? tmp - 10 + 'a' : tmp + '0');
    }
}
80802548:	bf00      	nop
8080254a:	3710      	adds	r7, #16
8080254c:	46bd      	mov	sp, r7
8080254e:	bd80      	pop	{r7, pc}

80802550 <kputs>:

void kputs(char *s)
{
80802550:	b580      	push	{r7, lr}
80802552:	b082      	sub	sp, #8
80802554:	af00      	add	r7, sp, #0
80802556:	6078      	str	r0, [r7, #4]
    while (*s) {
80802558:	e006      	b.n	80802568 <kputs+0x18>
        kputc(*s++);
8080255a:	687b      	ldr	r3, [r7, #4]
8080255c:	1c5a      	adds	r2, r3, #1
8080255e:	607a      	str	r2, [r7, #4]
80802560:	781b      	ldrb	r3, [r3, #0]
80802562:	4618      	mov	r0, r3
80802564:	f7ff ffa4 	bl	808024b0 <kputc>
    }
}

void kputs(char *s)
{
    while (*s) {
80802568:	687b      	ldr	r3, [r7, #4]
8080256a:	781b      	ldrb	r3, [r3, #0]
8080256c:	2b00      	cmp	r3, #0
8080256e:	d1f4      	bne.n	8080255a <kputs+0xa>
        kputc(*s++);
    }
}
80802570:	bf00      	nop
80802572:	3708      	adds	r7, #8
80802574:	46bd      	mov	sp, r7
80802576:	bd80      	pop	{r7, pc}

80802578 <mgpio_set>:


void mgpio_set(int en)
{
80802578:	b480      	push	{r7}
8080257a:	b083      	sub	sp, #12
8080257c:	af00      	add	r7, sp, #0
8080257e:	6078      	str	r0, [r7, #4]
    if (en) {
80802580:	687b      	ldr	r3, [r7, #4]
80802582:	2b00      	cmp	r3, #0
80802584:	d003      	beq.n	8080258e <mgpio_set+0x16>
        asm volatile ("nop\n\t"
80802586:	bf00      	nop
80802588:	f44f 4280 	mov.w	r2, #16384	; 0x4000
8080258c:	e002      	b.n	80802594 <mgpio_set+0x1c>
                "ldr r2, =0x4000\n\t");
    } else {
        asm volatile ("nop\n\t"
8080258e:	bf00      	nop
80802590:	f46f 4280 	mvn.w	r2, #16384	; 0x4000
                "ldr r2, =0xffffbfff\n\t");
    }

    asm volatile ("nop\n\t"
80802594:	bf00      	nop
80802596:	4b24      	ldr	r3, [pc, #144]	; (80802628 <_main+0x1c>)
80802598:	601a      	str	r2, [r3, #0]
            "ldr r3, =0x4805913C\n\t"
            "str r2, [r3, #0]\n\t");

    asm volatile (
8080259a:	4a24      	ldr	r2, [pc, #144]	; (8080262c <_main+0x20>)

8080259c <__mgpio_set_l2>:
8080259c:	6813      	ldr	r3, [r2, #0]
8080259e:	f003 0320 	and.w	r3, r3, #32
808025a2:	2b00      	cmp	r3, #0
808025a4:	d0fa      	beq.n	8080259c <__mgpio_set_l2>
808025a6:	f04f 0223 	mov.w	r2, #35	; 0x23
808025aa:	4b21      	ldr	r3, [pc, #132]	; (80802630 <_main+0x24>)
808025ac:	601a      	str	r2, [r3, #0]
            "mov r2, '#'\n\t"
            "ldr r3, =0x48020000\n\t"
            "str r2, [r3, #0]\n\t"
    );

}
808025ae:	bf00      	nop
808025b0:	370c      	adds	r7, #12
808025b2:	46bd      	mov	sp, r7
808025b4:	bc80      	pop	{r7}
808025b6:	4770      	bx	lr

808025b8 <_init>:

void _init(void)
{
808025b8:	b580      	push	{r7, lr}
808025ba:	b082      	sub	sp, #8
808025bc:	af00      	add	r7, sp, #0
    kputc('#');
808025be:	2023      	movs	r0, #35	; 0x23
808025c0:	f7ff ff76 	bl	808024b0 <kputc>

    {
        #define TIME_OUT 0x1fffff
        volatile u32 i;

        writel(0x0, 0x48059134);
808025c4:	f249 1334 	movw	r3, #37172	; 0x9134
808025c8:	f6c4 0305 	movt	r3, #18437	; 0x4805
808025cc:	2200      	movs	r2, #0
808025ce:	601a      	str	r2, [r3, #0]

        while(1) {
            mgpio_set(1);
808025d0:	2001      	movs	r0, #1
808025d2:	f7ff ffd1 	bl	80802578 <mgpio_set>
            i = TIME_OUT;
808025d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
808025da:	f2c0 031f 	movt	r3, #31
808025de:	607b      	str	r3, [r7, #4]
            while (i--) ;
808025e0:	bf00      	nop
808025e2:	687b      	ldr	r3, [r7, #4]
808025e4:	1e5a      	subs	r2, r3, #1
808025e6:	607a      	str	r2, [r7, #4]
808025e8:	2b00      	cmp	r3, #0
808025ea:	d1fa      	bne.n	808025e2 <_init+0x2a>

            mgpio_set(0);
808025ec:	2000      	movs	r0, #0
808025ee:	f7ff ffc3 	bl	80802578 <mgpio_set>
            i = TIME_OUT;
808025f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
808025f6:	f2c0 031f 	movt	r3, #31
808025fa:	607b      	str	r3, [r7, #4]
            while (i--) ;
808025fc:	bf00      	nop
808025fe:	687b      	ldr	r3, [r7, #4]
80802600:	1e5a      	subs	r2, r3, #1
80802602:	607a      	str	r2, [r7, #4]
80802604:	2b00      	cmp	r3, #0
80802606:	d1fa      	bne.n	808025fe <_init+0x46>

        }
80802608:	e7e2      	b.n	808025d0 <_init+0x18>
8080260a:	bf00      	nop

8080260c <_main>:

}


int _main(void)
{
8080260c:	b580      	push	{r7, lr}
8080260e:	af00      	add	r7, sp, #0
    kputc('$');
80802610:	2024      	movs	r0, #36	; 0x24
80802612:	f7ff ff4d 	bl	808024b0 <kputc>
    kputs("xxxinit\n");
80802616:	f242 70b8 	movw	r0, #10168	; 0x27b8
8080261a:	f2c8 0080 	movt	r0, #32896	; 0x8080
8080261e:	f7ff ff97 	bl	80802550 <kputs>





    return 0;
80802622:	2300      	movs	r3, #0
}
80802624:	4618      	mov	r0, r3
80802626:	bd80      	pop	{r7, pc}
80802628:	4805913c 	.word	0x4805913c
8080262c:	48020014 	.word	0x48020014
80802630:	48020000 	.word	0x48020000

80802634 <reset_handler>:
 *
 * Note: 'stack_top', 'irq_stack_top' and 'svc_stack_top' are allocated in qemu.ld
 */
reset_handler:
    @ The handler is always entered in Supervisor mode
    LDR sp, =svc_stack_top                 @ stack for the supervisor mode
80802634:	e59fd074 	ldr	sp, [pc, #116]	; 808026b0 <svc_stack_addr+0x4>
    #BL _init

    @ Clear the whole BSS section to 0:
    LDR r0, __bss_begin_addr
80802638:	e59f0064 	ldr	r0, [pc, #100]	; 808026a4 <__bss_begin_addr>
    LDR r1, __bss_end_addr
8080263c:	e59f1064 	ldr	r1, [pc, #100]	; 808026a8 <__bss_end_addr>
    MOV r2, #0
80802640:	e3a02000 	mov	r2, #0

80802644 <bss_clear_loop>:
bss_clear_loop:
    CMP r0, r1                     @ if (r0<r1) ....
80802644:	e1500001 	cmp	r0, r1
    STRLTB r2, [r0], #1            @ ...store a byte of r2 (i.r. 0) to location pointed by r0++
80802648:	b4c02001 	strblt	r2, [r0], #1
    BLT bss_clear_loop             @ ...and continue the loop
8080264c:	bafffffc 	blt	80802644 <bss_clear_loop>

    @ Set stack pointers and IRQ/FIQ bits for all supported operating modes
    MRS r0, cpsr                           @ copy Program Status Register (CPSR) to r0
80802650:	e10f0000 	mrs	r0, CPSR

    @ Disable IRQ and FIQ interrupts for the Supervisor mode
    @ This should be disabled by default, but it doesn't hurt...
    ORR r1, r0, #IRQ_BIT|FIQ_BIT
80802654:	e38010c0 	orr	r1, r0, #192	; 0xc0
    MSR cpsr, r1
80802658:	e129f001 	msr	CPSR_fc, r1

    @ Switch to System mode and disable IRQ/FIQ
    BIC r1, r0, #PSR_MASK                  @ clear lowest 5 bits
8080265c:	e3c0101f 	bic	r1, r0, #31
    ORR r1, r1, #MODE_SYS                  @ and set them to the System mode
80802660:	e381101f 	orr	r1, r1, #31
    ORR r1, r1, #IRQ_BIT|FIQ_BIT           @ disable IRQ and FIQ triggering
80802664:	e38110c0 	orr	r1, r1, #192	; 0xc0
    MSR cpsr, r1                           @ update CPSR and enter System mode
80802668:	e129f001 	msr	CPSR_fc, r1
    LDR sp, =stack_top                     @ set stack for System mode
8080266c:	e59fd040 	ldr	sp, [pc, #64]	; 808026b4 <svc_stack_addr+0x8>

    @ Set and switch into IRQ mode
    BIC r1, r0, #PSR_MASK                  @ clear least significant 5 bits...
80802670:	e3c0101f 	bic	r1, r0, #31
    ORR r1, r1, #MODE_IRQ                  @ and set them to b10010 (0x12), i.e set IRQ mode
80802674:	e3811012 	orr	r1, r1, #18
    ORR r1, r1, #IRQ_BIT|FIQ_BIT           @ also disable IRQ and FIQ triggering (a default setting, but...)
80802678:	e38110c0 	orr	r1, r1, #192	; 0xc0
    MSR cpsr, r1                           @ update CPSR (program status register) for IRQ mode
8080267c:	e129f001 	msr	CPSR_fc, r1

    @ When in IRQ mode, set its stack pointer
    LDR sp, =irq_stack_top                 @ stack for the IRQ mode
80802680:	e59fd030 	ldr	sp, [pc, #48]	; 808026b8 <svc_stack_addr+0xc>

    @ Prepare and enter into System mode.
    BIC r1, r0, #PSR_MASK                  @ clear lowest 5 bits
80802684:	e3c0101f 	bic	r1, r0, #31
    ORR r1, r1, #MODE_SYS                  @ and set them to the System mode
80802688:	e381101f 	orr	r1, r1, #31

    @ Return to Supervisor mode. When the first task starts it will switch
    @ to System mode and enable IRQ triggering.
    BIC r1, r1, #PSR_MASK
8080268c:	e3c1101f 	bic	r1, r1, #31
    ORR r1, r1, #MODE_SVC
80802690:	e3811013 	orr	r1, r1, #19
    MSR cpsr, r1
80802694:	e129f001 	msr	CPSR_fc, r1

    BL _init                               @ before the application is started, initialize all hardware
80802698:	faffffc6 	blx	808025b8 <_init>

    B _main                                 @ and finally start the application
8080269c:	ea000041 	b	808027a8 <___main_from_arm>

808026a0 <unhandled>:

unhandled:
    B .                                    @ infinite loop for unsupported exceptions
808026a0:	eafffffe 	b	808026a0 <unhandled>

808026a4 <__bss_begin_addr>:
808026a4:	808027c8 	.word	0x808027c8

808026a8 <__bss_end_addr>:
808026a8:	808078e0 	.word	0x808078e0

808026ac <svc_stack_addr>:
808026ac:	80001000 	.word	0x80001000
 *
 * Note: 'stack_top', 'irq_stack_top' and 'svc_stack_top' are allocated in qemu.ld
 */
reset_handler:
    @ The handler is always entered in Supervisor mode
    LDR sp, =svc_stack_top                 @ stack for the supervisor mode
808026b0:	80001000 	.word	0x80001000
    @ Switch to System mode and disable IRQ/FIQ
    BIC r1, r0, #PSR_MASK                  @ clear lowest 5 bits
    ORR r1, r1, #MODE_SYS                  @ and set them to the System mode
    ORR r1, r1, #IRQ_BIT|FIQ_BIT           @ disable IRQ and FIQ triggering
    MSR cpsr, r1                           @ update CPSR and enter System mode
    LDR sp, =stack_top                     @ set stack for System mode
808026b4:	807ffffc 	.word	0x807ffffc
    ORR r1, r1, #MODE_IRQ                  @ and set them to b10010 (0x12), i.e set IRQ mode
    ORR r1, r1, #IRQ_BIT|FIQ_BIT           @ also disable IRQ and FIQ triggering (a default setting, but...)
    MSR cpsr, r1                           @ update CPSR (program status register) for IRQ mode

    @ When in IRQ mode, set its stack pointer
    LDR sp, =irq_stack_top                 @ stack for the IRQ mode
808026b8:	80002000 	.word	0x80002000

808026bc <memcpy>:
808026bc:	4684      	mov	ip, r0
808026be:	ea41 0300 	orr.w	r3, r1, r0
808026c2:	f013 0303 	ands.w	r3, r3, #3
808026c6:	d149      	bne.n	8080275c <memcpy+0xa0>
808026c8:	3a40      	subs	r2, #64	; 0x40
808026ca:	d323      	bcc.n	80802714 <memcpy+0x58>
808026cc:	680b      	ldr	r3, [r1, #0]
808026ce:	6003      	str	r3, [r0, #0]
808026d0:	684b      	ldr	r3, [r1, #4]
808026d2:	6043      	str	r3, [r0, #4]
808026d4:	688b      	ldr	r3, [r1, #8]
808026d6:	6083      	str	r3, [r0, #8]
808026d8:	68cb      	ldr	r3, [r1, #12]
808026da:	60c3      	str	r3, [r0, #12]
808026dc:	690b      	ldr	r3, [r1, #16]
808026de:	6103      	str	r3, [r0, #16]
808026e0:	694b      	ldr	r3, [r1, #20]
808026e2:	6143      	str	r3, [r0, #20]
808026e4:	698b      	ldr	r3, [r1, #24]
808026e6:	6183      	str	r3, [r0, #24]
808026e8:	69cb      	ldr	r3, [r1, #28]
808026ea:	61c3      	str	r3, [r0, #28]
808026ec:	6a0b      	ldr	r3, [r1, #32]
808026ee:	6203      	str	r3, [r0, #32]
808026f0:	6a4b      	ldr	r3, [r1, #36]	; 0x24
808026f2:	6243      	str	r3, [r0, #36]	; 0x24
808026f4:	6a8b      	ldr	r3, [r1, #40]	; 0x28
808026f6:	6283      	str	r3, [r0, #40]	; 0x28
808026f8:	6acb      	ldr	r3, [r1, #44]	; 0x2c
808026fa:	62c3      	str	r3, [r0, #44]	; 0x2c
808026fc:	6b0b      	ldr	r3, [r1, #48]	; 0x30
808026fe:	6303      	str	r3, [r0, #48]	; 0x30
80802700:	6b4b      	ldr	r3, [r1, #52]	; 0x34
80802702:	6343      	str	r3, [r0, #52]	; 0x34
80802704:	6b8b      	ldr	r3, [r1, #56]	; 0x38
80802706:	6383      	str	r3, [r0, #56]	; 0x38
80802708:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
8080270a:	63c3      	str	r3, [r0, #60]	; 0x3c
8080270c:	3040      	adds	r0, #64	; 0x40
8080270e:	3140      	adds	r1, #64	; 0x40
80802710:	3a40      	subs	r2, #64	; 0x40
80802712:	d2db      	bcs.n	808026cc <memcpy+0x10>
80802714:	3230      	adds	r2, #48	; 0x30
80802716:	d30b      	bcc.n	80802730 <memcpy+0x74>
80802718:	680b      	ldr	r3, [r1, #0]
8080271a:	6003      	str	r3, [r0, #0]
8080271c:	684b      	ldr	r3, [r1, #4]
8080271e:	6043      	str	r3, [r0, #4]
80802720:	688b      	ldr	r3, [r1, #8]
80802722:	6083      	str	r3, [r0, #8]
80802724:	68cb      	ldr	r3, [r1, #12]
80802726:	60c3      	str	r3, [r0, #12]
80802728:	3010      	adds	r0, #16
8080272a:	3110      	adds	r1, #16
8080272c:	3a10      	subs	r2, #16
8080272e:	d2f3      	bcs.n	80802718 <memcpy+0x5c>
80802730:	320c      	adds	r2, #12
80802732:	d305      	bcc.n	80802740 <memcpy+0x84>
80802734:	f851 3b04 	ldr.w	r3, [r1], #4
80802738:	f840 3b04 	str.w	r3, [r0], #4
8080273c:	3a04      	subs	r2, #4
8080273e:	d2f9      	bcs.n	80802734 <memcpy+0x78>
80802740:	3204      	adds	r2, #4
80802742:	d008      	beq.n	80802756 <memcpy+0x9a>
80802744:	07d2      	lsls	r2, r2, #31
80802746:	bf1c      	itt	ne
80802748:	f811 3b01 	ldrbne.w	r3, [r1], #1
8080274c:	f800 3b01 	strbne.w	r3, [r0], #1
80802750:	d301      	bcc.n	80802756 <memcpy+0x9a>
80802752:	880b      	ldrh	r3, [r1, #0]
80802754:	8003      	strh	r3, [r0, #0]
80802756:	4660      	mov	r0, ip
80802758:	4770      	bx	lr
8080275a:	bf00      	nop
8080275c:	2a08      	cmp	r2, #8
8080275e:	d313      	bcc.n	80802788 <memcpy+0xcc>
80802760:	078b      	lsls	r3, r1, #30
80802762:	d0b1      	beq.n	808026c8 <memcpy+0xc>
80802764:	f010 0303 	ands.w	r3, r0, #3
80802768:	d0ae      	beq.n	808026c8 <memcpy+0xc>
8080276a:	f1c3 0304 	rsb	r3, r3, #4
8080276e:	1ad2      	subs	r2, r2, r3
80802770:	07db      	lsls	r3, r3, #31
80802772:	bf1c      	itt	ne
80802774:	f811 3b01 	ldrbne.w	r3, [r1], #1
80802778:	f800 3b01 	strbne.w	r3, [r0], #1
8080277c:	d3a4      	bcc.n	808026c8 <memcpy+0xc>
8080277e:	f831 3b02 	ldrh.w	r3, [r1], #2
80802782:	f820 3b02 	strh.w	r3, [r0], #2
80802786:	e79f      	b.n	808026c8 <memcpy+0xc>
80802788:	3a04      	subs	r2, #4
8080278a:	d3d9      	bcc.n	80802740 <memcpy+0x84>
8080278c:	3a01      	subs	r2, #1
8080278e:	f811 3b01 	ldrb.w	r3, [r1], #1
80802792:	f800 3b01 	strb.w	r3, [r0], #1
80802796:	d2f9      	bcs.n	8080278c <memcpy+0xd0>
80802798:	780b      	ldrb	r3, [r1, #0]
8080279a:	7003      	strb	r3, [r0, #0]
8080279c:	784b      	ldrb	r3, [r1, #1]
8080279e:	7043      	strb	r3, [r0, #1]
808027a0:	788b      	ldrb	r3, [r1, #2]
808027a2:	7083      	strb	r3, [r0, #2]
808027a4:	4660      	mov	r0, ip
808027a6:	4770      	bx	lr

808027a8 <___main_from_arm>:
808027a8:	e51ff004 	ldr	pc, [pc, #-4]	; 808027ac <___main_from_arm+0x4>
808027ac:	8080260d 	.word	0x8080260d
